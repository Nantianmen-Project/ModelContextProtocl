// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mcp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mcp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mcp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mcp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mcp_2eproto;
namespace mcp {
class Annotations;
struct AnnotationsDefaultTypeInternal;
extern AnnotationsDefaultTypeInternal _Annotations_default_instance_;
class AudioContent;
struct AudioContentDefaultTypeInternal;
extern AudioContentDefaultTypeInternal _AudioContent_default_instance_;
class BlobResourceContents;
struct BlobResourceContentsDefaultTypeInternal;
extern BlobResourceContentsDefaultTypeInternal _BlobResourceContents_default_instance_;
class ClientCapabilities;
struct ClientCapabilitiesDefaultTypeInternal;
extern ClientCapabilitiesDefaultTypeInternal _ClientCapabilities_default_instance_;
class ClientCapabilities_ExperimentalEntry_DoNotUse;
struct ClientCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal;
extern ClientCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal _ClientCapabilities_ExperimentalEntry_DoNotUse_default_instance_;
class CompletionsCapability;
struct CompletionsCapabilityDefaultTypeInternal;
extern CompletionsCapabilityDefaultTypeInternal _CompletionsCapability_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class ImageContent;
struct ImageContentDefaultTypeInternal;
extern ImageContentDefaultTypeInternal _ImageContent_default_instance_;
class Implementation;
struct ImplementationDefaultTypeInternal;
extern ImplementationDefaultTypeInternal _Implementation_default_instance_;
class InitializeParams;
struct InitializeParamsDefaultTypeInternal;
extern InitializeParamsDefaultTypeInternal _InitializeParams_default_instance_;
class InitializeRequest;
struct InitializeRequestDefaultTypeInternal;
extern InitializeRequestDefaultTypeInternal _InitializeRequest_default_instance_;
class InitializeResult;
struct InitializeResultDefaultTypeInternal;
extern InitializeResultDefaultTypeInternal _InitializeResult_default_instance_;
class InputSchema;
struct InputSchemaDefaultTypeInternal;
extern InputSchemaDefaultTypeInternal _InputSchema_default_instance_;
class InputSchema_PropertiesEntry_DoNotUse;
struct InputSchema_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern InputSchema_PropertiesEntry_DoNotUseDefaultTypeInternal _InputSchema_PropertiesEntry_DoNotUse_default_instance_;
class JSONRPCBatchRequest;
struct JSONRPCBatchRequestDefaultTypeInternal;
extern JSONRPCBatchRequestDefaultTypeInternal _JSONRPCBatchRequest_default_instance_;
class JSONRPCBatchResponse;
struct JSONRPCBatchResponseDefaultTypeInternal;
extern JSONRPCBatchResponseDefaultTypeInternal _JSONRPCBatchResponse_default_instance_;
class JSONRPCError;
struct JSONRPCErrorDefaultTypeInternal;
extern JSONRPCErrorDefaultTypeInternal _JSONRPCError_default_instance_;
class JSONRPCMessage;
struct JSONRPCMessageDefaultTypeInternal;
extern JSONRPCMessageDefaultTypeInternal _JSONRPCMessage_default_instance_;
class JSONRPCNotification;
struct JSONRPCNotificationDefaultTypeInternal;
extern JSONRPCNotificationDefaultTypeInternal _JSONRPCNotification_default_instance_;
class JSONRPCRequest;
struct JSONRPCRequestDefaultTypeInternal;
extern JSONRPCRequestDefaultTypeInternal _JSONRPCRequest_default_instance_;
class JSONRPCResponse;
struct JSONRPCResponseDefaultTypeInternal;
extern JSONRPCResponseDefaultTypeInternal _JSONRPCResponse_default_instance_;
class ListResourcesRequest;
struct ListResourcesRequestDefaultTypeInternal;
extern ListResourcesRequestDefaultTypeInternal _ListResourcesRequest_default_instance_;
class ListResourcesResult;
struct ListResourcesResultDefaultTypeInternal;
extern ListResourcesResultDefaultTypeInternal _ListResourcesResult_default_instance_;
class LoggingCapability;
struct LoggingCapabilityDefaultTypeInternal;
extern LoggingCapabilityDefaultTypeInternal _LoggingCapability_default_instance_;
class MetaParams;
struct MetaParamsDefaultTypeInternal;
extern MetaParamsDefaultTypeInternal _MetaParams_default_instance_;
class MetaParams_AdditionalMetaEntry_DoNotUse;
struct MetaParams_AdditionalMetaEntry_DoNotUseDefaultTypeInternal;
extern MetaParams_AdditionalMetaEntry_DoNotUseDefaultTypeInternal _MetaParams_AdditionalMetaEntry_DoNotUse_default_instance_;
class MetaResult;
struct MetaResultDefaultTypeInternal;
extern MetaResultDefaultTypeInternal _MetaResult_default_instance_;
class MetaResult_AdditionalMetaEntry_DoNotUse;
struct MetaResult_AdditionalMetaEntry_DoNotUseDefaultTypeInternal;
extern MetaResult_AdditionalMetaEntry_DoNotUseDefaultTypeInternal _MetaResult_AdditionalMetaEntry_DoNotUse_default_instance_;
class ModelHint;
struct ModelHintDefaultTypeInternal;
extern ModelHintDefaultTypeInternal _ModelHint_default_instance_;
class ModelPreferences;
struct ModelPreferencesDefaultTypeInternal;
extern ModelPreferencesDefaultTypeInternal _ModelPreferences_default_instance_;
class NotificationParams;
struct NotificationParamsDefaultTypeInternal;
extern NotificationParamsDefaultTypeInternal _NotificationParams_default_instance_;
class NotificationParams_AdditionalParamsEntry_DoNotUse;
struct NotificationParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal;
extern NotificationParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal _NotificationParams_AdditionalParamsEntry_DoNotUse_default_instance_;
class PaginatedParams;
struct PaginatedParamsDefaultTypeInternal;
extern PaginatedParamsDefaultTypeInternal _PaginatedParams_default_instance_;
class PromptReference;
struct PromptReferenceDefaultTypeInternal;
extern PromptReferenceDefaultTypeInternal _PromptReference_default_instance_;
class PromptsCapability;
struct PromptsCapabilityDefaultTypeInternal;
extern PromptsCapabilityDefaultTypeInternal _PromptsCapability_default_instance_;
class ReadResourceParams;
struct ReadResourceParamsDefaultTypeInternal;
extern ReadResourceParamsDefaultTypeInternal _ReadResourceParams_default_instance_;
class ReadResourceRequest;
struct ReadResourceRequestDefaultTypeInternal;
extern ReadResourceRequestDefaultTypeInternal _ReadResourceRequest_default_instance_;
class ReadResourceResult;
struct ReadResourceResultDefaultTypeInternal;
extern ReadResourceResultDefaultTypeInternal _ReadResourceResult_default_instance_;
class RequestParams;
struct RequestParamsDefaultTypeInternal;
extern RequestParamsDefaultTypeInternal _RequestParams_default_instance_;
class RequestParams_AdditionalParamsEntry_DoNotUse;
struct RequestParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal;
extern RequestParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal _RequestParams_AdditionalParamsEntry_DoNotUse_default_instance_;
class Resource;
struct ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class ResourceContents;
struct ResourceContentsDefaultTypeInternal;
extern ResourceContentsDefaultTypeInternal _ResourceContents_default_instance_;
class ResourceReference;
struct ResourceReferenceDefaultTypeInternal;
extern ResourceReferenceDefaultTypeInternal _ResourceReference_default_instance_;
class ResourceTemplate;
struct ResourceTemplateDefaultTypeInternal;
extern ResourceTemplateDefaultTypeInternal _ResourceTemplate_default_instance_;
class ResourcesCapability;
struct ResourcesCapabilityDefaultTypeInternal;
extern ResourcesCapabilityDefaultTypeInternal _ResourcesCapability_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Result_AdditionalResultEntry_DoNotUse;
struct Result_AdditionalResultEntry_DoNotUseDefaultTypeInternal;
extern Result_AdditionalResultEntry_DoNotUseDefaultTypeInternal _Result_AdditionalResultEntry_DoNotUse_default_instance_;
class Root;
struct RootDefaultTypeInternal;
extern RootDefaultTypeInternal _Root_default_instance_;
class RootsCapability;
struct RootsCapabilityDefaultTypeInternal;
extern RootsCapabilityDefaultTypeInternal _RootsCapability_default_instance_;
class SamplingCapability;
struct SamplingCapabilityDefaultTypeInternal;
extern SamplingCapabilityDefaultTypeInternal _SamplingCapability_default_instance_;
class ServerCapabilities;
struct ServerCapabilitiesDefaultTypeInternal;
extern ServerCapabilitiesDefaultTypeInternal _ServerCapabilities_default_instance_;
class ServerCapabilities_ExperimentalEntry_DoNotUse;
struct ServerCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal;
extern ServerCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal _ServerCapabilities_ExperimentalEntry_DoNotUse_default_instance_;
class TextContent;
struct TextContentDefaultTypeInternal;
extern TextContentDefaultTypeInternal _TextContent_default_instance_;
class TextResourceContents;
struct TextResourceContentsDefaultTypeInternal;
extern TextResourceContentsDefaultTypeInternal _TextResourceContents_default_instance_;
class Tool;
struct ToolDefaultTypeInternal;
extern ToolDefaultTypeInternal _Tool_default_instance_;
class ToolAnnotations;
struct ToolAnnotationsDefaultTypeInternal;
extern ToolAnnotationsDefaultTypeInternal _ToolAnnotations_default_instance_;
class ToolsCapability;
struct ToolsCapabilityDefaultTypeInternal;
extern ToolsCapabilityDefaultTypeInternal _ToolsCapability_default_instance_;
}  // namespace mcp
PROTOBUF_NAMESPACE_OPEN
template<> ::mcp::Annotations* Arena::CreateMaybeMessage<::mcp::Annotations>(Arena*);
template<> ::mcp::AudioContent* Arena::CreateMaybeMessage<::mcp::AudioContent>(Arena*);
template<> ::mcp::BlobResourceContents* Arena::CreateMaybeMessage<::mcp::BlobResourceContents>(Arena*);
template<> ::mcp::ClientCapabilities* Arena::CreateMaybeMessage<::mcp::ClientCapabilities>(Arena*);
template<> ::mcp::ClientCapabilities_ExperimentalEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::ClientCapabilities_ExperimentalEntry_DoNotUse>(Arena*);
template<> ::mcp::CompletionsCapability* Arena::CreateMaybeMessage<::mcp::CompletionsCapability>(Arena*);
template<> ::mcp::Error* Arena::CreateMaybeMessage<::mcp::Error>(Arena*);
template<> ::mcp::ImageContent* Arena::CreateMaybeMessage<::mcp::ImageContent>(Arena*);
template<> ::mcp::Implementation* Arena::CreateMaybeMessage<::mcp::Implementation>(Arena*);
template<> ::mcp::InitializeParams* Arena::CreateMaybeMessage<::mcp::InitializeParams>(Arena*);
template<> ::mcp::InitializeRequest* Arena::CreateMaybeMessage<::mcp::InitializeRequest>(Arena*);
template<> ::mcp::InitializeResult* Arena::CreateMaybeMessage<::mcp::InitializeResult>(Arena*);
template<> ::mcp::InputSchema* Arena::CreateMaybeMessage<::mcp::InputSchema>(Arena*);
template<> ::mcp::InputSchema_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::InputSchema_PropertiesEntry_DoNotUse>(Arena*);
template<> ::mcp::JSONRPCBatchRequest* Arena::CreateMaybeMessage<::mcp::JSONRPCBatchRequest>(Arena*);
template<> ::mcp::JSONRPCBatchResponse* Arena::CreateMaybeMessage<::mcp::JSONRPCBatchResponse>(Arena*);
template<> ::mcp::JSONRPCError* Arena::CreateMaybeMessage<::mcp::JSONRPCError>(Arena*);
template<> ::mcp::JSONRPCMessage* Arena::CreateMaybeMessage<::mcp::JSONRPCMessage>(Arena*);
template<> ::mcp::JSONRPCNotification* Arena::CreateMaybeMessage<::mcp::JSONRPCNotification>(Arena*);
template<> ::mcp::JSONRPCRequest* Arena::CreateMaybeMessage<::mcp::JSONRPCRequest>(Arena*);
template<> ::mcp::JSONRPCResponse* Arena::CreateMaybeMessage<::mcp::JSONRPCResponse>(Arena*);
template<> ::mcp::ListResourcesRequest* Arena::CreateMaybeMessage<::mcp::ListResourcesRequest>(Arena*);
template<> ::mcp::ListResourcesResult* Arena::CreateMaybeMessage<::mcp::ListResourcesResult>(Arena*);
template<> ::mcp::LoggingCapability* Arena::CreateMaybeMessage<::mcp::LoggingCapability>(Arena*);
template<> ::mcp::MetaParams* Arena::CreateMaybeMessage<::mcp::MetaParams>(Arena*);
template<> ::mcp::MetaParams_AdditionalMetaEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::MetaParams_AdditionalMetaEntry_DoNotUse>(Arena*);
template<> ::mcp::MetaResult* Arena::CreateMaybeMessage<::mcp::MetaResult>(Arena*);
template<> ::mcp::MetaResult_AdditionalMetaEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::MetaResult_AdditionalMetaEntry_DoNotUse>(Arena*);
template<> ::mcp::ModelHint* Arena::CreateMaybeMessage<::mcp::ModelHint>(Arena*);
template<> ::mcp::ModelPreferences* Arena::CreateMaybeMessage<::mcp::ModelPreferences>(Arena*);
template<> ::mcp::NotificationParams* Arena::CreateMaybeMessage<::mcp::NotificationParams>(Arena*);
template<> ::mcp::NotificationParams_AdditionalParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::NotificationParams_AdditionalParamsEntry_DoNotUse>(Arena*);
template<> ::mcp::PaginatedParams* Arena::CreateMaybeMessage<::mcp::PaginatedParams>(Arena*);
template<> ::mcp::PromptReference* Arena::CreateMaybeMessage<::mcp::PromptReference>(Arena*);
template<> ::mcp::PromptsCapability* Arena::CreateMaybeMessage<::mcp::PromptsCapability>(Arena*);
template<> ::mcp::ReadResourceParams* Arena::CreateMaybeMessage<::mcp::ReadResourceParams>(Arena*);
template<> ::mcp::ReadResourceRequest* Arena::CreateMaybeMessage<::mcp::ReadResourceRequest>(Arena*);
template<> ::mcp::ReadResourceResult* Arena::CreateMaybeMessage<::mcp::ReadResourceResult>(Arena*);
template<> ::mcp::RequestParams* Arena::CreateMaybeMessage<::mcp::RequestParams>(Arena*);
template<> ::mcp::RequestParams_AdditionalParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::RequestParams_AdditionalParamsEntry_DoNotUse>(Arena*);
template<> ::mcp::Resource* Arena::CreateMaybeMessage<::mcp::Resource>(Arena*);
template<> ::mcp::ResourceContents* Arena::CreateMaybeMessage<::mcp::ResourceContents>(Arena*);
template<> ::mcp::ResourceReference* Arena::CreateMaybeMessage<::mcp::ResourceReference>(Arena*);
template<> ::mcp::ResourceTemplate* Arena::CreateMaybeMessage<::mcp::ResourceTemplate>(Arena*);
template<> ::mcp::ResourcesCapability* Arena::CreateMaybeMessage<::mcp::ResourcesCapability>(Arena*);
template<> ::mcp::Result* Arena::CreateMaybeMessage<::mcp::Result>(Arena*);
template<> ::mcp::Result_AdditionalResultEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::Result_AdditionalResultEntry_DoNotUse>(Arena*);
template<> ::mcp::Root* Arena::CreateMaybeMessage<::mcp::Root>(Arena*);
template<> ::mcp::RootsCapability* Arena::CreateMaybeMessage<::mcp::RootsCapability>(Arena*);
template<> ::mcp::SamplingCapability* Arena::CreateMaybeMessage<::mcp::SamplingCapability>(Arena*);
template<> ::mcp::ServerCapabilities* Arena::CreateMaybeMessage<::mcp::ServerCapabilities>(Arena*);
template<> ::mcp::ServerCapabilities_ExperimentalEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::ServerCapabilities_ExperimentalEntry_DoNotUse>(Arena*);
template<> ::mcp::TextContent* Arena::CreateMaybeMessage<::mcp::TextContent>(Arena*);
template<> ::mcp::TextResourceContents* Arena::CreateMaybeMessage<::mcp::TextResourceContents>(Arena*);
template<> ::mcp::Tool* Arena::CreateMaybeMessage<::mcp::Tool>(Arena*);
template<> ::mcp::ToolAnnotations* Arena::CreateMaybeMessage<::mcp::ToolAnnotations>(Arena*);
template<> ::mcp::ToolsCapability* Arena::CreateMaybeMessage<::mcp::ToolsCapability>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mcp {

enum Role : int {
  ROLE_UNSPECIFIED = 0,
  ROLE_USER = 1,
  ROLE_ASSISTANT = 2,
  Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Role_IsValid(int value);
constexpr Role Role_MIN = ROLE_UNSPECIFIED;
constexpr Role Role_MAX = ROLE_ASSISTANT;
constexpr int Role_ARRAYSIZE = Role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Role_descriptor();
template<typename T>
inline const std::string& Role_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Role>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Role_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Role_descriptor(), enum_t_value);
}
inline bool Role_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Role* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Role>(
    Role_descriptor(), name, value);
}
enum LoggingLevel : int {
  LOGGING_LEVEL_UNSPECIFIED = 0,
  LOGGING_LEVEL_DEBUG = 1,
  LOGGING_LEVEL_INFO = 2,
  LOGGING_LEVEL_NOTICE = 3,
  LOGGING_LEVEL_WARNING = 4,
  LOGGING_LEVEL_ERROR = 5,
  LOGGING_LEVEL_CRITICAL = 6,
  LOGGING_LEVEL_ALERT = 7,
  LOGGING_LEVEL_EMERGENCY = 8,
  LoggingLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoggingLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoggingLevel_IsValid(int value);
constexpr LoggingLevel LoggingLevel_MIN = LOGGING_LEVEL_UNSPECIFIED;
constexpr LoggingLevel LoggingLevel_MAX = LOGGING_LEVEL_EMERGENCY;
constexpr int LoggingLevel_ARRAYSIZE = LoggingLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoggingLevel_descriptor();
template<typename T>
inline const std::string& LoggingLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoggingLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoggingLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoggingLevel_descriptor(), enum_t_value);
}
inline bool LoggingLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoggingLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoggingLevel>(
    LoggingLevel_descriptor(), name, value);
}
// ===================================================================

class JSONRPCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCMessage) */ {
 public:
  inline JSONRPCMessage() : JSONRPCMessage(nullptr) {}
  ~JSONRPCMessage() override;
  explicit PROTOBUF_CONSTEXPR JSONRPCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONRPCMessage(const JSONRPCMessage& from);
  JSONRPCMessage(JSONRPCMessage&& from) noexcept
    : JSONRPCMessage() {
    *this = ::std::move(from);
  }

  inline JSONRPCMessage& operator=(const JSONRPCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONRPCMessage& operator=(JSONRPCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONRPCMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kRequest = 1,
    kNotification = 2,
    kBatchRequest = 3,
    kResponse = 4,
    kError = 5,
    kBatchResponse = 6,
    MESSAGE_NOT_SET = 0,
  };

  static inline const JSONRPCMessage* internal_default_instance() {
    return reinterpret_cast<const JSONRPCMessage*>(
               &_JSONRPCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(JSONRPCMessage& a, JSONRPCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONRPCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONRPCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONRPCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONRPCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONRPCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONRPCMessage& from) {
    JSONRPCMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.JSONRPCMessage";
  }
  protected:
  explicit JSONRPCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
    kNotificationFieldNumber = 2,
    kBatchRequestFieldNumber = 3,
    kResponseFieldNumber = 4,
    kErrorFieldNumber = 5,
    kBatchResponseFieldNumber = 6,
  };
  // .mcp.JSONRPCRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::mcp::JSONRPCRequest& request() const;
  PROTOBUF_NODISCARD ::mcp::JSONRPCRequest* release_request();
  ::mcp::JSONRPCRequest* mutable_request();
  void set_allocated_request(::mcp::JSONRPCRequest* request);
  private:
  const ::mcp::JSONRPCRequest& _internal_request() const;
  ::mcp::JSONRPCRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::mcp::JSONRPCRequest* request);
  ::mcp::JSONRPCRequest* unsafe_arena_release_request();

  // .mcp.JSONRPCNotification notification = 2;
  bool has_notification() const;
  private:
  bool _internal_has_notification() const;
  public:
  void clear_notification();
  const ::mcp::JSONRPCNotification& notification() const;
  PROTOBUF_NODISCARD ::mcp::JSONRPCNotification* release_notification();
  ::mcp::JSONRPCNotification* mutable_notification();
  void set_allocated_notification(::mcp::JSONRPCNotification* notification);
  private:
  const ::mcp::JSONRPCNotification& _internal_notification() const;
  ::mcp::JSONRPCNotification* _internal_mutable_notification();
  public:
  void unsafe_arena_set_allocated_notification(
      ::mcp::JSONRPCNotification* notification);
  ::mcp::JSONRPCNotification* unsafe_arena_release_notification();

  // .mcp.JSONRPCBatchRequest batch_request = 3;
  bool has_batch_request() const;
  private:
  bool _internal_has_batch_request() const;
  public:
  void clear_batch_request();
  const ::mcp::JSONRPCBatchRequest& batch_request() const;
  PROTOBUF_NODISCARD ::mcp::JSONRPCBatchRequest* release_batch_request();
  ::mcp::JSONRPCBatchRequest* mutable_batch_request();
  void set_allocated_batch_request(::mcp::JSONRPCBatchRequest* batch_request);
  private:
  const ::mcp::JSONRPCBatchRequest& _internal_batch_request() const;
  ::mcp::JSONRPCBatchRequest* _internal_mutable_batch_request();
  public:
  void unsafe_arena_set_allocated_batch_request(
      ::mcp::JSONRPCBatchRequest* batch_request);
  ::mcp::JSONRPCBatchRequest* unsafe_arena_release_batch_request();

  // .mcp.JSONRPCResponse response = 4;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::mcp::JSONRPCResponse& response() const;
  PROTOBUF_NODISCARD ::mcp::JSONRPCResponse* release_response();
  ::mcp::JSONRPCResponse* mutable_response();
  void set_allocated_response(::mcp::JSONRPCResponse* response);
  private:
  const ::mcp::JSONRPCResponse& _internal_response() const;
  ::mcp::JSONRPCResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::mcp::JSONRPCResponse* response);
  ::mcp::JSONRPCResponse* unsafe_arena_release_response();

  // .mcp.JSONRPCError error = 5;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::mcp::JSONRPCError& error() const;
  PROTOBUF_NODISCARD ::mcp::JSONRPCError* release_error();
  ::mcp::JSONRPCError* mutable_error();
  void set_allocated_error(::mcp::JSONRPCError* error);
  private:
  const ::mcp::JSONRPCError& _internal_error() const;
  ::mcp::JSONRPCError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::mcp::JSONRPCError* error);
  ::mcp::JSONRPCError* unsafe_arena_release_error();

  // .mcp.JSONRPCBatchResponse batch_response = 6;
  bool has_batch_response() const;
  private:
  bool _internal_has_batch_response() const;
  public:
  void clear_batch_response();
  const ::mcp::JSONRPCBatchResponse& batch_response() const;
  PROTOBUF_NODISCARD ::mcp::JSONRPCBatchResponse* release_batch_response();
  ::mcp::JSONRPCBatchResponse* mutable_batch_response();
  void set_allocated_batch_response(::mcp::JSONRPCBatchResponse* batch_response);
  private:
  const ::mcp::JSONRPCBatchResponse& _internal_batch_response() const;
  ::mcp::JSONRPCBatchResponse* _internal_mutable_batch_response();
  public:
  void unsafe_arena_set_allocated_batch_response(
      ::mcp::JSONRPCBatchResponse* batch_response);
  ::mcp::JSONRPCBatchResponse* unsafe_arena_release_batch_response();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:mcp.JSONRPCMessage)
 private:
  class _Internal;
  void set_has_request();
  void set_has_notification();
  void set_has_batch_request();
  void set_has_response();
  void set_has_error();
  void set_has_batch_response();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::mcp::JSONRPCRequest* request_;
      ::mcp::JSONRPCNotification* notification_;
      ::mcp::JSONRPCBatchRequest* batch_request_;
      ::mcp::JSONRPCResponse* response_;
      ::mcp::JSONRPCError* error_;
      ::mcp::JSONRPCBatchResponse* batch_response_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class JSONRPCRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCRequest) */ {
 public:
  inline JSONRPCRequest() : JSONRPCRequest(nullptr) {}
  ~JSONRPCRequest() override;
  explicit PROTOBUF_CONSTEXPR JSONRPCRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONRPCRequest(const JSONRPCRequest& from);
  JSONRPCRequest(JSONRPCRequest&& from) noexcept
    : JSONRPCRequest() {
    *this = ::std::move(from);
  }

  inline JSONRPCRequest& operator=(const JSONRPCRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONRPCRequest& operator=(JSONRPCRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONRPCRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONRPCRequest* internal_default_instance() {
    return reinterpret_cast<const JSONRPCRequest*>(
               &_JSONRPCRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(JSONRPCRequest& a, JSONRPCRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONRPCRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONRPCRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONRPCRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONRPCRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONRPCRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONRPCRequest& from) {
    JSONRPCRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.JSONRPCRequest";
  }
  protected:
  explicit JSONRPCRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonrpcFieldNumber = 1,
    kIdFieldNumber = 2,
    kMethodFieldNumber = 3,
    kParamsFieldNumber = 4,
  };
  // string jsonrpc = 1;
  void clear_jsonrpc();
  const std::string& jsonrpc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsonrpc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsonrpc();
  PROTOBUF_NODISCARD std::string* release_jsonrpc();
  void set_allocated_jsonrpc(std::string* jsonrpc);
  private:
  const std::string& _internal_jsonrpc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonrpc(const std::string& value);
  std::string* _internal_mutable_jsonrpc();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string method = 3;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .mcp.RequestParams params = 4;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::mcp::RequestParams& params() const;
  PROTOBUF_NODISCARD ::mcp::RequestParams* release_params();
  ::mcp::RequestParams* mutable_params();
  void set_allocated_params(::mcp::RequestParams* params);
  private:
  const ::mcp::RequestParams& _internal_params() const;
  ::mcp::RequestParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::mcp::RequestParams* params);
  ::mcp::RequestParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsonrpc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::mcp::RequestParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class JSONRPCNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCNotification) */ {
 public:
  inline JSONRPCNotification() : JSONRPCNotification(nullptr) {}
  ~JSONRPCNotification() override;
  explicit PROTOBUF_CONSTEXPR JSONRPCNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONRPCNotification(const JSONRPCNotification& from);
  JSONRPCNotification(JSONRPCNotification&& from) noexcept
    : JSONRPCNotification() {
    *this = ::std::move(from);
  }

  inline JSONRPCNotification& operator=(const JSONRPCNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONRPCNotification& operator=(JSONRPCNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONRPCNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONRPCNotification* internal_default_instance() {
    return reinterpret_cast<const JSONRPCNotification*>(
               &_JSONRPCNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(JSONRPCNotification& a, JSONRPCNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONRPCNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONRPCNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONRPCNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONRPCNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONRPCNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONRPCNotification& from) {
    JSONRPCNotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.JSONRPCNotification";
  }
  protected:
  explicit JSONRPCNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonrpcFieldNumber = 1,
    kMethodFieldNumber = 2,
    kParamsFieldNumber = 3,
  };
  // string jsonrpc = 1;
  void clear_jsonrpc();
  const std::string& jsonrpc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsonrpc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsonrpc();
  PROTOBUF_NODISCARD std::string* release_jsonrpc();
  void set_allocated_jsonrpc(std::string* jsonrpc);
  private:
  const std::string& _internal_jsonrpc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonrpc(const std::string& value);
  std::string* _internal_mutable_jsonrpc();
  public:

  // string method = 2;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .mcp.NotificationParams params = 3;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::mcp::NotificationParams& params() const;
  PROTOBUF_NODISCARD ::mcp::NotificationParams* release_params();
  ::mcp::NotificationParams* mutable_params();
  void set_allocated_params(::mcp::NotificationParams* params);
  private:
  const ::mcp::NotificationParams& _internal_params() const;
  ::mcp::NotificationParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::mcp::NotificationParams* params);
  ::mcp::NotificationParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsonrpc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::mcp::NotificationParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class JSONRPCResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCResponse) */ {
 public:
  inline JSONRPCResponse() : JSONRPCResponse(nullptr) {}
  ~JSONRPCResponse() override;
  explicit PROTOBUF_CONSTEXPR JSONRPCResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONRPCResponse(const JSONRPCResponse& from);
  JSONRPCResponse(JSONRPCResponse&& from) noexcept
    : JSONRPCResponse() {
    *this = ::std::move(from);
  }

  inline JSONRPCResponse& operator=(const JSONRPCResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONRPCResponse& operator=(JSONRPCResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONRPCResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONRPCResponse* internal_default_instance() {
    return reinterpret_cast<const JSONRPCResponse*>(
               &_JSONRPCResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(JSONRPCResponse& a, JSONRPCResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONRPCResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONRPCResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONRPCResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONRPCResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONRPCResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONRPCResponse& from) {
    JSONRPCResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.JSONRPCResponse";
  }
  protected:
  explicit JSONRPCResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonrpcFieldNumber = 1,
    kIdFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // string jsonrpc = 1;
  void clear_jsonrpc();
  const std::string& jsonrpc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsonrpc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsonrpc();
  PROTOBUF_NODISCARD std::string* release_jsonrpc();
  void set_allocated_jsonrpc(std::string* jsonrpc);
  private:
  const std::string& _internal_jsonrpc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonrpc(const std::string& value);
  std::string* _internal_mutable_jsonrpc();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .mcp.Result result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::mcp::Result& result() const;
  PROTOBUF_NODISCARD ::mcp::Result* release_result();
  ::mcp::Result* mutable_result();
  void set_allocated_result(::mcp::Result* result);
  private:
  const ::mcp::Result& _internal_result() const;
  ::mcp::Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::mcp::Result* result);
  ::mcp::Result* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsonrpc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::mcp::Result* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class JSONRPCError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCError) */ {
 public:
  inline JSONRPCError() : JSONRPCError(nullptr) {}
  ~JSONRPCError() override;
  explicit PROTOBUF_CONSTEXPR JSONRPCError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONRPCError(const JSONRPCError& from);
  JSONRPCError(JSONRPCError&& from) noexcept
    : JSONRPCError() {
    *this = ::std::move(from);
  }

  inline JSONRPCError& operator=(const JSONRPCError& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONRPCError& operator=(JSONRPCError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONRPCError& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONRPCError* internal_default_instance() {
    return reinterpret_cast<const JSONRPCError*>(
               &_JSONRPCError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JSONRPCError& a, JSONRPCError& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONRPCError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONRPCError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONRPCError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONRPCError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONRPCError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONRPCError& from) {
    JSONRPCError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.JSONRPCError";
  }
  protected:
  explicit JSONRPCError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonrpcFieldNumber = 1,
    kIdFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string jsonrpc = 1;
  void clear_jsonrpc();
  const std::string& jsonrpc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsonrpc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsonrpc();
  PROTOBUF_NODISCARD std::string* release_jsonrpc();
  void set_allocated_jsonrpc(std::string* jsonrpc);
  private:
  const std::string& _internal_jsonrpc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonrpc(const std::string& value);
  std::string* _internal_mutable_jsonrpc();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .mcp.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::mcp::Error& error() const;
  PROTOBUF_NODISCARD ::mcp::Error* release_error();
  ::mcp::Error* mutable_error();
  void set_allocated_error(::mcp::Error* error);
  private:
  const ::mcp::Error& _internal_error() const;
  ::mcp::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::mcp::Error* error);
  ::mcp::Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsonrpc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::mcp::Error* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class JSONRPCBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCBatchRequest) */ {
 public:
  inline JSONRPCBatchRequest() : JSONRPCBatchRequest(nullptr) {}
  ~JSONRPCBatchRequest() override;
  explicit PROTOBUF_CONSTEXPR JSONRPCBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONRPCBatchRequest(const JSONRPCBatchRequest& from);
  JSONRPCBatchRequest(JSONRPCBatchRequest&& from) noexcept
    : JSONRPCBatchRequest() {
    *this = ::std::move(from);
  }

  inline JSONRPCBatchRequest& operator=(const JSONRPCBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONRPCBatchRequest& operator=(JSONRPCBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONRPCBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONRPCBatchRequest* internal_default_instance() {
    return reinterpret_cast<const JSONRPCBatchRequest*>(
               &_JSONRPCBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JSONRPCBatchRequest& a, JSONRPCBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONRPCBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONRPCBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONRPCBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONRPCBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONRPCBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONRPCBatchRequest& from) {
    JSONRPCBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.JSONRPCBatchRequest";
  }
  protected:
  explicit JSONRPCBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .mcp.JSONRPCRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::mcp::JSONRPCRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCRequest >*
      mutable_requests();
  private:
  const ::mcp::JSONRPCRequest& _internal_requests(int index) const;
  ::mcp::JSONRPCRequest* _internal_add_requests();
  public:
  const ::mcp::JSONRPCRequest& requests(int index) const;
  ::mcp::JSONRPCRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class JSONRPCBatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCBatchResponse) */ {
 public:
  inline JSONRPCBatchResponse() : JSONRPCBatchResponse(nullptr) {}
  ~JSONRPCBatchResponse() override;
  explicit PROTOBUF_CONSTEXPR JSONRPCBatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONRPCBatchResponse(const JSONRPCBatchResponse& from);
  JSONRPCBatchResponse(JSONRPCBatchResponse&& from) noexcept
    : JSONRPCBatchResponse() {
    *this = ::std::move(from);
  }

  inline JSONRPCBatchResponse& operator=(const JSONRPCBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONRPCBatchResponse& operator=(JSONRPCBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONRPCBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONRPCBatchResponse* internal_default_instance() {
    return reinterpret_cast<const JSONRPCBatchResponse*>(
               &_JSONRPCBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JSONRPCBatchResponse& a, JSONRPCBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONRPCBatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONRPCBatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONRPCBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONRPCBatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONRPCBatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONRPCBatchResponse& from) {
    JSONRPCBatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCBatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.JSONRPCBatchResponse";
  }
  protected:
  explicit JSONRPCBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 1,
  };
  // repeated .mcp.JSONRPCResponse responses = 1;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::mcp::JSONRPCResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCResponse >*
      mutable_responses();
  private:
  const ::mcp::JSONRPCResponse& _internal_responses(int index) const;
  ::mcp::JSONRPCResponse* _internal_add_responses();
  public:
  const ::mcp::JSONRPCResponse& responses(int index) const;
  ::mcp::JSONRPCResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCBatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCResponse > responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class RequestParams_AdditionalParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestParams_AdditionalParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestParams_AdditionalParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  RequestParams_AdditionalParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RequestParams_AdditionalParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RequestParams_AdditionalParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RequestParams_AdditionalParamsEntry_DoNotUse& other);
  static const RequestParams_AdditionalParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RequestParams_AdditionalParamsEntry_DoNotUse*>(&_RequestParams_AdditionalParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.RequestParams.AdditionalParamsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class RequestParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RequestParams) */ {
 public:
  inline RequestParams() : RequestParams(nullptr) {}
  ~RequestParams() override;
  explicit PROTOBUF_CONSTEXPR RequestParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestParams(const RequestParams& from);
  RequestParams(RequestParams&& from) noexcept
    : RequestParams() {
    *this = ::std::move(from);
  }

  inline RequestParams& operator=(const RequestParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestParams& operator=(RequestParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestParams* internal_default_instance() {
    return reinterpret_cast<const RequestParams*>(
               &_RequestParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestParams& a, RequestParams& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestParams& from) {
    RequestParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RequestParams";
  }
  protected:
  explicit RequestParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalParamsFieldNumber = 2,
    kMetaFieldNumber = 1,
  };
  // map<string, bytes> additional_params = 2;
  int additional_params_size() const;
  private:
  int _internal_additional_params_size() const;
  public:
  void clear_additional_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_additional_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_additional_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      additional_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_additional_params();

  // .mcp.MetaParams _meta = 1;
  bool has__meta() const;
  private:
  bool _internal_has__meta() const;
  public:
  void clear__meta();
  const ::mcp::MetaParams& _meta() const;
  PROTOBUF_NODISCARD ::mcp::MetaParams* release__meta();
  ::mcp::MetaParams* mutable__meta();
  void set_allocated__meta(::mcp::MetaParams* _meta);
  private:
  const ::mcp::MetaParams& _internal__meta() const;
  ::mcp::MetaParams* _internal_mutable__meta();
  public:
  void unsafe_arena_set_allocated__meta(
      ::mcp::MetaParams* _meta);
  ::mcp::MetaParams* unsafe_arena_release__meta();

  // @@protoc_insertion_point(class_scope:mcp.RequestParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RequestParams_AdditionalParamsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> additional_params_;
    ::mcp::MetaParams* _meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class NotificationParams_AdditionalParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NotificationParams_AdditionalParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NotificationParams_AdditionalParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  NotificationParams_AdditionalParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR NotificationParams_AdditionalParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NotificationParams_AdditionalParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NotificationParams_AdditionalParamsEntry_DoNotUse& other);
  static const NotificationParams_AdditionalParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NotificationParams_AdditionalParamsEntry_DoNotUse*>(&_NotificationParams_AdditionalParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.NotificationParams.AdditionalParamsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class NotificationParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.NotificationParams) */ {
 public:
  inline NotificationParams() : NotificationParams(nullptr) {}
  ~NotificationParams() override;
  explicit PROTOBUF_CONSTEXPR NotificationParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotificationParams(const NotificationParams& from);
  NotificationParams(NotificationParams&& from) noexcept
    : NotificationParams() {
    *this = ::std::move(from);
  }

  inline NotificationParams& operator=(const NotificationParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationParams& operator=(NotificationParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotificationParams* internal_default_instance() {
    return reinterpret_cast<const NotificationParams*>(
               &_NotificationParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NotificationParams& a, NotificationParams& b) {
    a.Swap(&b);
  }
  inline void Swap(NotificationParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotificationParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotificationParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotificationParams& from) {
    NotificationParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.NotificationParams";
  }
  protected:
  explicit NotificationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalParamsFieldNumber = 2,
    kMetaFieldNumber = 1,
  };
  // map<string, bytes> additional_params = 2;
  int additional_params_size() const;
  private:
  int _internal_additional_params_size() const;
  public:
  void clear_additional_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_additional_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_additional_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      additional_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_additional_params();

  // .mcp.MetaParams _meta = 1;
  bool has__meta() const;
  private:
  bool _internal_has__meta() const;
  public:
  void clear__meta();
  const ::mcp::MetaParams& _meta() const;
  PROTOBUF_NODISCARD ::mcp::MetaParams* release__meta();
  ::mcp::MetaParams* mutable__meta();
  void set_allocated__meta(::mcp::MetaParams* _meta);
  private:
  const ::mcp::MetaParams& _internal__meta() const;
  ::mcp::MetaParams* _internal_mutable__meta();
  public:
  void unsafe_arena_set_allocated__meta(
      ::mcp::MetaParams* _meta);
  ::mcp::MetaParams* unsafe_arena_release__meta();

  // @@protoc_insertion_point(class_scope:mcp.NotificationParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NotificationParams_AdditionalParamsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> additional_params_;
    ::mcp::MetaParams* _meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class MetaParams_AdditionalMetaEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaParams_AdditionalMetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaParams_AdditionalMetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  MetaParams_AdditionalMetaEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR MetaParams_AdditionalMetaEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MetaParams_AdditionalMetaEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MetaParams_AdditionalMetaEntry_DoNotUse& other);
  static const MetaParams_AdditionalMetaEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetaParams_AdditionalMetaEntry_DoNotUse*>(&_MetaParams_AdditionalMetaEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.MetaParams.AdditionalMetaEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class MetaParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.MetaParams) */ {
 public:
  inline MetaParams() : MetaParams(nullptr) {}
  ~MetaParams() override;
  explicit PROTOBUF_CONSTEXPR MetaParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaParams(const MetaParams& from);
  MetaParams(MetaParams&& from) noexcept
    : MetaParams() {
    *this = ::std::move(from);
  }

  inline MetaParams& operator=(const MetaParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaParams& operator=(MetaParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaParams* internal_default_instance() {
    return reinterpret_cast<const MetaParams*>(
               &_MetaParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MetaParams& a, MetaParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetaParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetaParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetaParams& from) {
    MetaParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.MetaParams";
  }
  protected:
  explicit MetaParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalMetaFieldNumber = 2,
    kProgressTokenFieldNumber = 1,
  };
  // map<string, bytes> additional_meta = 2;
  int additional_meta_size() const;
  private:
  int _internal_additional_meta_size() const;
  public:
  void clear_additional_meta();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_additional_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_additional_meta();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      additional_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_additional_meta();

  // string progress_token = 1;
  void clear_progress_token();
  const std::string& progress_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_progress_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_progress_token();
  PROTOBUF_NODISCARD std::string* release_progress_token();
  void set_allocated_progress_token(std::string* progress_token);
  private:
  const std::string& _internal_progress_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_progress_token(const std::string& value);
  std::string* _internal_mutable_progress_token();
  public:

  // @@protoc_insertion_point(class_scope:mcp.MetaParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        MetaParams_AdditionalMetaEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> additional_meta_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr progress_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class Result_AdditionalResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Result_AdditionalResultEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Result_AdditionalResultEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Result_AdditionalResultEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Result_AdditionalResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Result_AdditionalResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Result_AdditionalResultEntry_DoNotUse& other);
  static const Result_AdditionalResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Result_AdditionalResultEntry_DoNotUse*>(&_Result_AdditionalResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.Result.AdditionalResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit PROTOBUF_CONSTEXPR Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Result& from) {
    Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalResultFieldNumber = 2,
    kMetaFieldNumber = 1,
  };
  // map<string, bytes> additional_result = 2;
  int additional_result_size() const;
  private:
  int _internal_additional_result_size() const;
  public:
  void clear_additional_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_additional_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_additional_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      additional_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_additional_result();

  // .mcp.MetaResult _meta = 1;
  bool has__meta() const;
  private:
  bool _internal_has__meta() const;
  public:
  void clear__meta();
  const ::mcp::MetaResult& _meta() const;
  PROTOBUF_NODISCARD ::mcp::MetaResult* release__meta();
  ::mcp::MetaResult* mutable__meta();
  void set_allocated__meta(::mcp::MetaResult* _meta);
  private:
  const ::mcp::MetaResult& _internal__meta() const;
  ::mcp::MetaResult* _internal_mutable__meta();
  public:
  void unsafe_arena_set_allocated__meta(
      ::mcp::MetaResult* _meta);
  ::mcp::MetaResult* unsafe_arena_release__meta();

  // @@protoc_insertion_point(class_scope:mcp.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Result_AdditionalResultEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> additional_result_;
    ::mcp::MetaResult* _meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class MetaResult_AdditionalMetaEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaResult_AdditionalMetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaResult_AdditionalMetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  MetaResult_AdditionalMetaEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR MetaResult_AdditionalMetaEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MetaResult_AdditionalMetaEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MetaResult_AdditionalMetaEntry_DoNotUse& other);
  static const MetaResult_AdditionalMetaEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetaResult_AdditionalMetaEntry_DoNotUse*>(&_MetaResult_AdditionalMetaEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.MetaResult.AdditionalMetaEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class MetaResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.MetaResult) */ {
 public:
  inline MetaResult() : MetaResult(nullptr) {}
  ~MetaResult() override;
  explicit PROTOBUF_CONSTEXPR MetaResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaResult(const MetaResult& from);
  MetaResult(MetaResult&& from) noexcept
    : MetaResult() {
    *this = ::std::move(from);
  }

  inline MetaResult& operator=(const MetaResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaResult& operator=(MetaResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaResult* internal_default_instance() {
    return reinterpret_cast<const MetaResult*>(
               &_MetaResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MetaResult& a, MetaResult& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetaResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetaResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetaResult& from) {
    MetaResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.MetaResult";
  }
  protected:
  explicit MetaResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalMetaFieldNumber = 1,
  };
  // map<string, bytes> additional_meta = 1;
  int additional_meta_size() const;
  private:
  int _internal_additional_meta_size() const;
  public:
  void clear_additional_meta();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_additional_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_additional_meta();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      additional_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_additional_meta();

  // @@protoc_insertion_point(class_scope:mcp.MetaResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        MetaResult_AdditionalMetaEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> additional_meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kDataFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class Implementation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Implementation) */ {
 public:
  inline Implementation() : Implementation(nullptr) {}
  ~Implementation() override;
  explicit PROTOBUF_CONSTEXPR Implementation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Implementation(const Implementation& from);
  Implementation(Implementation&& from) noexcept
    : Implementation() {
    *this = ::std::move(from);
  }

  inline Implementation& operator=(const Implementation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Implementation& operator=(Implementation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Implementation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Implementation* internal_default_instance() {
    return reinterpret_cast<const Implementation*>(
               &_Implementation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Implementation& a, Implementation& b) {
    a.Swap(&b);
  }
  inline void Swap(Implementation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Implementation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Implementation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Implementation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Implementation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Implementation& from) {
    Implementation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Implementation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Implementation";
  }
  protected:
  explicit Implementation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:mcp.Implementation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ClientCapabilities_ExperimentalEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ClientCapabilities_ExperimentalEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ClientCapabilities_ExperimentalEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ClientCapabilities_ExperimentalEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ClientCapabilities_ExperimentalEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ClientCapabilities_ExperimentalEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ClientCapabilities_ExperimentalEntry_DoNotUse& other);
  static const ClientCapabilities_ExperimentalEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ClientCapabilities_ExperimentalEntry_DoNotUse*>(&_ClientCapabilities_ExperimentalEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.ClientCapabilities.ExperimentalEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class ClientCapabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ClientCapabilities) */ {
 public:
  inline ClientCapabilities() : ClientCapabilities(nullptr) {}
  ~ClientCapabilities() override;
  explicit PROTOBUF_CONSTEXPR ClientCapabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientCapabilities(const ClientCapabilities& from);
  ClientCapabilities(ClientCapabilities&& from) noexcept
    : ClientCapabilities() {
    *this = ::std::move(from);
  }

  inline ClientCapabilities& operator=(const ClientCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientCapabilities& operator=(ClientCapabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientCapabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientCapabilities* internal_default_instance() {
    return reinterpret_cast<const ClientCapabilities*>(
               &_ClientCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ClientCapabilities& a, ClientCapabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientCapabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientCapabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientCapabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientCapabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientCapabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientCapabilities& from) {
    ClientCapabilities::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientCapabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ClientCapabilities";
  }
  protected:
  explicit ClientCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExperimentalFieldNumber = 1,
    kRootsFieldNumber = 2,
    kSamplingFieldNumber = 3,
  };
  // map<string, bytes> experimental = 1;
  int experimental_size() const;
  private:
  int _internal_experimental_size() const;
  public:
  void clear_experimental();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_experimental() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_experimental();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      experimental() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_experimental();

  // .mcp.RootsCapability roots = 2;
  bool has_roots() const;
  private:
  bool _internal_has_roots() const;
  public:
  void clear_roots();
  const ::mcp::RootsCapability& roots() const;
  PROTOBUF_NODISCARD ::mcp::RootsCapability* release_roots();
  ::mcp::RootsCapability* mutable_roots();
  void set_allocated_roots(::mcp::RootsCapability* roots);
  private:
  const ::mcp::RootsCapability& _internal_roots() const;
  ::mcp::RootsCapability* _internal_mutable_roots();
  public:
  void unsafe_arena_set_allocated_roots(
      ::mcp::RootsCapability* roots);
  ::mcp::RootsCapability* unsafe_arena_release_roots();

  // .mcp.SamplingCapability sampling = 3;
  bool has_sampling() const;
  private:
  bool _internal_has_sampling() const;
  public:
  void clear_sampling();
  const ::mcp::SamplingCapability& sampling() const;
  PROTOBUF_NODISCARD ::mcp::SamplingCapability* release_sampling();
  ::mcp::SamplingCapability* mutable_sampling();
  void set_allocated_sampling(::mcp::SamplingCapability* sampling);
  private:
  const ::mcp::SamplingCapability& _internal_sampling() const;
  ::mcp::SamplingCapability* _internal_mutable_sampling();
  public:
  void unsafe_arena_set_allocated_sampling(
      ::mcp::SamplingCapability* sampling);
  ::mcp::SamplingCapability* unsafe_arena_release_sampling();

  // @@protoc_insertion_point(class_scope:mcp.ClientCapabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ClientCapabilities_ExperimentalEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> experimental_;
    ::mcp::RootsCapability* roots_;
    ::mcp::SamplingCapability* sampling_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ServerCapabilities_ExperimentalEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServerCapabilities_ExperimentalEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServerCapabilities_ExperimentalEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ServerCapabilities_ExperimentalEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ServerCapabilities_ExperimentalEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ServerCapabilities_ExperimentalEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ServerCapabilities_ExperimentalEntry_DoNotUse& other);
  static const ServerCapabilities_ExperimentalEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServerCapabilities_ExperimentalEntry_DoNotUse*>(&_ServerCapabilities_ExperimentalEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.ServerCapabilities.ExperimentalEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class ServerCapabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ServerCapabilities) */ {
 public:
  inline ServerCapabilities() : ServerCapabilities(nullptr) {}
  ~ServerCapabilities() override;
  explicit PROTOBUF_CONSTEXPR ServerCapabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerCapabilities(const ServerCapabilities& from);
  ServerCapabilities(ServerCapabilities&& from) noexcept
    : ServerCapabilities() {
    *this = ::std::move(from);
  }

  inline ServerCapabilities& operator=(const ServerCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerCapabilities& operator=(ServerCapabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerCapabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerCapabilities* internal_default_instance() {
    return reinterpret_cast<const ServerCapabilities*>(
               &_ServerCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ServerCapabilities& a, ServerCapabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerCapabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerCapabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerCapabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerCapabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerCapabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerCapabilities& from) {
    ServerCapabilities::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerCapabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ServerCapabilities";
  }
  protected:
  explicit ServerCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExperimentalFieldNumber = 1,
    kLoggingFieldNumber = 2,
    kCompletionsFieldNumber = 3,
    kPromptsFieldNumber = 4,
    kResourcesFieldNumber = 5,
    kToolsFieldNumber = 6,
  };
  // map<string, bytes> experimental = 1;
  int experimental_size() const;
  private:
  int _internal_experimental_size() const;
  public:
  void clear_experimental();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_experimental() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_experimental();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      experimental() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_experimental();

  // .mcp.LoggingCapability logging = 2;
  bool has_logging() const;
  private:
  bool _internal_has_logging() const;
  public:
  void clear_logging();
  const ::mcp::LoggingCapability& logging() const;
  PROTOBUF_NODISCARD ::mcp::LoggingCapability* release_logging();
  ::mcp::LoggingCapability* mutable_logging();
  void set_allocated_logging(::mcp::LoggingCapability* logging);
  private:
  const ::mcp::LoggingCapability& _internal_logging() const;
  ::mcp::LoggingCapability* _internal_mutable_logging();
  public:
  void unsafe_arena_set_allocated_logging(
      ::mcp::LoggingCapability* logging);
  ::mcp::LoggingCapability* unsafe_arena_release_logging();

  // .mcp.CompletionsCapability completions = 3;
  bool has_completions() const;
  private:
  bool _internal_has_completions() const;
  public:
  void clear_completions();
  const ::mcp::CompletionsCapability& completions() const;
  PROTOBUF_NODISCARD ::mcp::CompletionsCapability* release_completions();
  ::mcp::CompletionsCapability* mutable_completions();
  void set_allocated_completions(::mcp::CompletionsCapability* completions);
  private:
  const ::mcp::CompletionsCapability& _internal_completions() const;
  ::mcp::CompletionsCapability* _internal_mutable_completions();
  public:
  void unsafe_arena_set_allocated_completions(
      ::mcp::CompletionsCapability* completions);
  ::mcp::CompletionsCapability* unsafe_arena_release_completions();

  // .mcp.PromptsCapability prompts = 4;
  bool has_prompts() const;
  private:
  bool _internal_has_prompts() const;
  public:
  void clear_prompts();
  const ::mcp::PromptsCapability& prompts() const;
  PROTOBUF_NODISCARD ::mcp::PromptsCapability* release_prompts();
  ::mcp::PromptsCapability* mutable_prompts();
  void set_allocated_prompts(::mcp::PromptsCapability* prompts);
  private:
  const ::mcp::PromptsCapability& _internal_prompts() const;
  ::mcp::PromptsCapability* _internal_mutable_prompts();
  public:
  void unsafe_arena_set_allocated_prompts(
      ::mcp::PromptsCapability* prompts);
  ::mcp::PromptsCapability* unsafe_arena_release_prompts();

  // .mcp.ResourcesCapability resources = 5;
  bool has_resources() const;
  private:
  bool _internal_has_resources() const;
  public:
  void clear_resources();
  const ::mcp::ResourcesCapability& resources() const;
  PROTOBUF_NODISCARD ::mcp::ResourcesCapability* release_resources();
  ::mcp::ResourcesCapability* mutable_resources();
  void set_allocated_resources(::mcp::ResourcesCapability* resources);
  private:
  const ::mcp::ResourcesCapability& _internal_resources() const;
  ::mcp::ResourcesCapability* _internal_mutable_resources();
  public:
  void unsafe_arena_set_allocated_resources(
      ::mcp::ResourcesCapability* resources);
  ::mcp::ResourcesCapability* unsafe_arena_release_resources();

  // .mcp.ToolsCapability tools = 6;
  bool has_tools() const;
  private:
  bool _internal_has_tools() const;
  public:
  void clear_tools();
  const ::mcp::ToolsCapability& tools() const;
  PROTOBUF_NODISCARD ::mcp::ToolsCapability* release_tools();
  ::mcp::ToolsCapability* mutable_tools();
  void set_allocated_tools(::mcp::ToolsCapability* tools);
  private:
  const ::mcp::ToolsCapability& _internal_tools() const;
  ::mcp::ToolsCapability* _internal_mutable_tools();
  public:
  void unsafe_arena_set_allocated_tools(
      ::mcp::ToolsCapability* tools);
  ::mcp::ToolsCapability* unsafe_arena_release_tools();

  // @@protoc_insertion_point(class_scope:mcp.ServerCapabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ServerCapabilities_ExperimentalEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> experimental_;
    ::mcp::LoggingCapability* logging_;
    ::mcp::CompletionsCapability* completions_;
    ::mcp::PromptsCapability* prompts_;
    ::mcp::ResourcesCapability* resources_;
    ::mcp::ToolsCapability* tools_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class RootsCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RootsCapability) */ {
 public:
  inline RootsCapability() : RootsCapability(nullptr) {}
  ~RootsCapability() override;
  explicit PROTOBUF_CONSTEXPR RootsCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RootsCapability(const RootsCapability& from);
  RootsCapability(RootsCapability&& from) noexcept
    : RootsCapability() {
    *this = ::std::move(from);
  }

  inline RootsCapability& operator=(const RootsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline RootsCapability& operator=(RootsCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RootsCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const RootsCapability* internal_default_instance() {
    return reinterpret_cast<const RootsCapability*>(
               &_RootsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RootsCapability& a, RootsCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(RootsCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RootsCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RootsCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RootsCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RootsCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RootsCapability& from) {
    RootsCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootsCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RootsCapability";
  }
  protected:
  explicit RootsCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListChangedFieldNumber = 1,
  };
  // bool list_changed = 1;
  void clear_list_changed();
  bool list_changed() const;
  void set_list_changed(bool value);
  private:
  bool _internal_list_changed() const;
  void _internal_set_list_changed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.RootsCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool list_changed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class SamplingCapability final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mcp.SamplingCapability) */ {
 public:
  inline SamplingCapability() : SamplingCapability(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SamplingCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SamplingCapability(const SamplingCapability& from);
  SamplingCapability(SamplingCapability&& from) noexcept
    : SamplingCapability() {
    *this = ::std::move(from);
  }

  inline SamplingCapability& operator=(const SamplingCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline SamplingCapability& operator=(SamplingCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SamplingCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const SamplingCapability* internal_default_instance() {
    return reinterpret_cast<const SamplingCapability*>(
               &_SamplingCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SamplingCapability& a, SamplingCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(SamplingCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SamplingCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SamplingCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SamplingCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SamplingCapability& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SamplingCapability& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.SamplingCapability";
  }
  protected:
  explicit SamplingCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.SamplingCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class LoggingCapability final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mcp.LoggingCapability) */ {
 public:
  inline LoggingCapability() : LoggingCapability(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LoggingCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoggingCapability(const LoggingCapability& from);
  LoggingCapability(LoggingCapability&& from) noexcept
    : LoggingCapability() {
    *this = ::std::move(from);
  }

  inline LoggingCapability& operator=(const LoggingCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggingCapability& operator=(LoggingCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoggingCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoggingCapability* internal_default_instance() {
    return reinterpret_cast<const LoggingCapability*>(
               &_LoggingCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LoggingCapability& a, LoggingCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggingCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoggingCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoggingCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoggingCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LoggingCapability& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LoggingCapability& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.LoggingCapability";
  }
  protected:
  explicit LoggingCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.LoggingCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class CompletionsCapability final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mcp.CompletionsCapability) */ {
 public:
  inline CompletionsCapability() : CompletionsCapability(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CompletionsCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionsCapability(const CompletionsCapability& from);
  CompletionsCapability(CompletionsCapability&& from) noexcept
    : CompletionsCapability() {
    *this = ::std::move(from);
  }

  inline CompletionsCapability& operator=(const CompletionsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionsCapability& operator=(CompletionsCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionsCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionsCapability* internal_default_instance() {
    return reinterpret_cast<const CompletionsCapability*>(
               &_CompletionsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CompletionsCapability& a, CompletionsCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionsCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionsCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionsCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionsCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CompletionsCapability& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CompletionsCapability& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.CompletionsCapability";
  }
  protected:
  explicit CompletionsCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.CompletionsCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class PromptsCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.PromptsCapability) */ {
 public:
  inline PromptsCapability() : PromptsCapability(nullptr) {}
  ~PromptsCapability() override;
  explicit PROTOBUF_CONSTEXPR PromptsCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptsCapability(const PromptsCapability& from);
  PromptsCapability(PromptsCapability&& from) noexcept
    : PromptsCapability() {
    *this = ::std::move(from);
  }

  inline PromptsCapability& operator=(const PromptsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptsCapability& operator=(PromptsCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PromptsCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptsCapability* internal_default_instance() {
    return reinterpret_cast<const PromptsCapability*>(
               &_PromptsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PromptsCapability& a, PromptsCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(PromptsCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptsCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptsCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptsCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PromptsCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PromptsCapability& from) {
    PromptsCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromptsCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.PromptsCapability";
  }
  protected:
  explicit PromptsCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListChangedFieldNumber = 1,
  };
  // bool list_changed = 1;
  void clear_list_changed();
  bool list_changed() const;
  void set_list_changed(bool value);
  private:
  bool _internal_list_changed() const;
  void _internal_set_list_changed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.PromptsCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool list_changed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ResourcesCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ResourcesCapability) */ {
 public:
  inline ResourcesCapability() : ResourcesCapability(nullptr) {}
  ~ResourcesCapability() override;
  explicit PROTOBUF_CONSTEXPR ResourcesCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourcesCapability(const ResourcesCapability& from);
  ResourcesCapability(ResourcesCapability&& from) noexcept
    : ResourcesCapability() {
    *this = ::std::move(from);
  }

  inline ResourcesCapability& operator=(const ResourcesCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourcesCapability& operator=(ResourcesCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourcesCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourcesCapability* internal_default_instance() {
    return reinterpret_cast<const ResourcesCapability*>(
               &_ResourcesCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ResourcesCapability& a, ResourcesCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourcesCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourcesCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourcesCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourcesCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourcesCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourcesCapability& from) {
    ResourcesCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourcesCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ResourcesCapability";
  }
  protected:
  explicit ResourcesCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscribeFieldNumber = 1,
    kListChangedFieldNumber = 2,
  };
  // bool subscribe = 1;
  void clear_subscribe();
  bool subscribe() const;
  void set_subscribe(bool value);
  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);
  public:

  // bool list_changed = 2;
  void clear_list_changed();
  bool list_changed() const;
  void set_list_changed(bool value);
  private:
  bool _internal_list_changed() const;
  void _internal_set_list_changed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.ResourcesCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool subscribe_;
    bool list_changed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ToolsCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ToolsCapability) */ {
 public:
  inline ToolsCapability() : ToolsCapability(nullptr) {}
  ~ToolsCapability() override;
  explicit PROTOBUF_CONSTEXPR ToolsCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolsCapability(const ToolsCapability& from);
  ToolsCapability(ToolsCapability&& from) noexcept
    : ToolsCapability() {
    *this = ::std::move(from);
  }

  inline ToolsCapability& operator=(const ToolsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolsCapability& operator=(ToolsCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolsCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolsCapability* internal_default_instance() {
    return reinterpret_cast<const ToolsCapability*>(
               &_ToolsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ToolsCapability& a, ToolsCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolsCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolsCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolsCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolsCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolsCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolsCapability& from) {
    ToolsCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolsCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ToolsCapability";
  }
  protected:
  explicit ToolsCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListChangedFieldNumber = 1,
  };
  // bool list_changed = 1;
  void clear_list_changed();
  bool list_changed() const;
  void set_list_changed(bool value);
  private:
  bool _internal_list_changed() const;
  void _internal_set_list_changed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.ToolsCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool list_changed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class Resource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Resource) */ {
 public:
  inline Resource() : Resource(nullptr) {}
  ~Resource() override;
  explicit PROTOBUF_CONSTEXPR Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resource(const Resource& from);
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resource& operator=(Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resource& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Resource& from) {
    Resource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Resource";
  }
  protected:
  explicit Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kMimeTypeFieldNumber = 4,
    kAnnotationsFieldNumber = 5,
    kSizeFieldNumber = 6,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string mime_type = 4;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // .mcp.Annotations annotations = 5;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::mcp::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  ::mcp::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::mcp::Annotations* annotations);
  ::mcp::Annotations* unsafe_arena_release_annotations();

  // int64 size = 6;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.Resource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::mcp::Annotations* annotations_;
    int64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ResourceTemplate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ResourceTemplate) */ {
 public:
  inline ResourceTemplate() : ResourceTemplate(nullptr) {}
  ~ResourceTemplate() override;
  explicit PROTOBUF_CONSTEXPR ResourceTemplate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceTemplate(const ResourceTemplate& from);
  ResourceTemplate(ResourceTemplate&& from) noexcept
    : ResourceTemplate() {
    *this = ::std::move(from);
  }

  inline ResourceTemplate& operator=(const ResourceTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceTemplate& operator=(ResourceTemplate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceTemplate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceTemplate* internal_default_instance() {
    return reinterpret_cast<const ResourceTemplate*>(
               &_ResourceTemplate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ResourceTemplate& a, ResourceTemplate& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceTemplate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceTemplate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceTemplate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceTemplate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceTemplate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceTemplate& from) {
    ResourceTemplate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceTemplate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ResourceTemplate";
  }
  protected:
  explicit ResourceTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriTemplateFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kMimeTypeFieldNumber = 4,
    kAnnotationsFieldNumber = 5,
  };
  // string uri_template = 1;
  void clear_uri_template();
  const std::string& uri_template() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri_template(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri_template();
  PROTOBUF_NODISCARD std::string* release_uri_template();
  void set_allocated_uri_template(std::string* uri_template);
  private:
  const std::string& _internal_uri_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri_template(const std::string& value);
  std::string* _internal_mutable_uri_template();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string mime_type = 4;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // .mcp.Annotations annotations = 5;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::mcp::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  ::mcp::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::mcp::Annotations* annotations);
  ::mcp::Annotations* unsafe_arena_release_annotations();

  // @@protoc_insertion_point(class_scope:mcp.ResourceTemplate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_template_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::mcp::Annotations* annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ResourceContents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ResourceContents) */ {
 public:
  inline ResourceContents() : ResourceContents(nullptr) {}
  ~ResourceContents() override;
  explicit PROTOBUF_CONSTEXPR ResourceContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceContents(const ResourceContents& from);
  ResourceContents(ResourceContents&& from) noexcept
    : ResourceContents() {
    *this = ::std::move(from);
  }

  inline ResourceContents& operator=(const ResourceContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceContents& operator=(ResourceContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceContents& default_instance() {
    return *internal_default_instance();
  }
  enum ContentCase {
    kText = 3,
    kBlob = 4,
    CONTENT_NOT_SET = 0,
  };

  static inline const ResourceContents* internal_default_instance() {
    return reinterpret_cast<const ResourceContents*>(
               &_ResourceContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ResourceContents& a, ResourceContents& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceContents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceContents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceContents& from) {
    ResourceContents::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ResourceContents";
  }
  protected:
  explicit ResourceContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kMimeTypeFieldNumber = 2,
    kTextFieldNumber = 3,
    kBlobFieldNumber = 4,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string mime_type = 2;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // .mcp.TextResourceContents text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::mcp::TextResourceContents& text() const;
  PROTOBUF_NODISCARD ::mcp::TextResourceContents* release_text();
  ::mcp::TextResourceContents* mutable_text();
  void set_allocated_text(::mcp::TextResourceContents* text);
  private:
  const ::mcp::TextResourceContents& _internal_text() const;
  ::mcp::TextResourceContents* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::mcp::TextResourceContents* text);
  ::mcp::TextResourceContents* unsafe_arena_release_text();

  // .mcp.BlobResourceContents blob = 4;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::mcp::BlobResourceContents& blob() const;
  PROTOBUF_NODISCARD ::mcp::BlobResourceContents* release_blob();
  ::mcp::BlobResourceContents* mutable_blob();
  void set_allocated_blob(::mcp::BlobResourceContents* blob);
  private:
  const ::mcp::BlobResourceContents& _internal_blob() const;
  ::mcp::BlobResourceContents* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::mcp::BlobResourceContents* blob);
  ::mcp::BlobResourceContents* unsafe_arena_release_blob();

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:mcp.ResourceContents)
 private:
  class _Internal;
  void set_has_text();
  void set_has_blob();

  inline bool has_content() const;
  inline void clear_has_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    union ContentUnion {
      constexpr ContentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::mcp::TextResourceContents* text_;
      ::mcp::BlobResourceContents* blob_;
    } content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class TextResourceContents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.TextResourceContents) */ {
 public:
  inline TextResourceContents() : TextResourceContents(nullptr) {}
  ~TextResourceContents() override;
  explicit PROTOBUF_CONSTEXPR TextResourceContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextResourceContents(const TextResourceContents& from);
  TextResourceContents(TextResourceContents&& from) noexcept
    : TextResourceContents() {
    *this = ::std::move(from);
  }

  inline TextResourceContents& operator=(const TextResourceContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextResourceContents& operator=(TextResourceContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextResourceContents& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextResourceContents* internal_default_instance() {
    return reinterpret_cast<const TextResourceContents*>(
               &_TextResourceContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(TextResourceContents& a, TextResourceContents& b) {
    a.Swap(&b);
  }
  inline void Swap(TextResourceContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextResourceContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextResourceContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextResourceContents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextResourceContents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextResourceContents& from) {
    TextResourceContents::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextResourceContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.TextResourceContents";
  }
  protected:
  explicit TextResourceContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mcp.TextResourceContents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class BlobResourceContents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.BlobResourceContents) */ {
 public:
  inline BlobResourceContents() : BlobResourceContents(nullptr) {}
  ~BlobResourceContents() override;
  explicit PROTOBUF_CONSTEXPR BlobResourceContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlobResourceContents(const BlobResourceContents& from);
  BlobResourceContents(BlobResourceContents&& from) noexcept
    : BlobResourceContents() {
    *this = ::std::move(from);
  }

  inline BlobResourceContents& operator=(const BlobResourceContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobResourceContents& operator=(BlobResourceContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobResourceContents& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobResourceContents* internal_default_instance() {
    return reinterpret_cast<const BlobResourceContents*>(
               &_BlobResourceContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(BlobResourceContents& a, BlobResourceContents& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobResourceContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobResourceContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobResourceContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobResourceContents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlobResourceContents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlobResourceContents& from) {
    BlobResourceContents::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobResourceContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.BlobResourceContents";
  }
  protected:
  explicit BlobResourceContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 1,
  };
  // bytes blob = 1;
  void clear_blob();
  const std::string& blob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob();
  PROTOBUF_NODISCARD std::string* release_blob();
  void set_allocated_blob(std::string* blob);
  private:
  const std::string& _internal_blob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob(const std::string& value);
  std::string* _internal_mutable_blob();
  public:

  // @@protoc_insertion_point(class_scope:mcp.BlobResourceContents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class Tool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Tool) */ {
 public:
  inline Tool() : Tool(nullptr) {}
  ~Tool() override;
  explicit PROTOBUF_CONSTEXPR Tool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tool(const Tool& from);
  Tool(Tool&& from) noexcept
    : Tool() {
    *this = ::std::move(from);
  }

  inline Tool& operator=(const Tool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tool& operator=(Tool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tool* internal_default_instance() {
    return reinterpret_cast<const Tool*>(
               &_Tool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Tool& a, Tool& b) {
    a.Swap(&b);
  }
  inline void Swap(Tool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tool& from) {
    Tool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Tool";
  }
  protected:
  explicit Tool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kInputSchemaFieldNumber = 3,
    kAnnotationsFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .mcp.InputSchema input_schema = 3;
  bool has_input_schema() const;
  private:
  bool _internal_has_input_schema() const;
  public:
  void clear_input_schema();
  const ::mcp::InputSchema& input_schema() const;
  PROTOBUF_NODISCARD ::mcp::InputSchema* release_input_schema();
  ::mcp::InputSchema* mutable_input_schema();
  void set_allocated_input_schema(::mcp::InputSchema* input_schema);
  private:
  const ::mcp::InputSchema& _internal_input_schema() const;
  ::mcp::InputSchema* _internal_mutable_input_schema();
  public:
  void unsafe_arena_set_allocated_input_schema(
      ::mcp::InputSchema* input_schema);
  ::mcp::InputSchema* unsafe_arena_release_input_schema();

  // .mcp.ToolAnnotations annotations = 4;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::mcp::ToolAnnotations& annotations() const;
  PROTOBUF_NODISCARD ::mcp::ToolAnnotations* release_annotations();
  ::mcp::ToolAnnotations* mutable_annotations();
  void set_allocated_annotations(::mcp::ToolAnnotations* annotations);
  private:
  const ::mcp::ToolAnnotations& _internal_annotations() const;
  ::mcp::ToolAnnotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::mcp::ToolAnnotations* annotations);
  ::mcp::ToolAnnotations* unsafe_arena_release_annotations();

  // @@protoc_insertion_point(class_scope:mcp.Tool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::mcp::InputSchema* input_schema_;
    ::mcp::ToolAnnotations* annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class InputSchema_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputSchema_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputSchema_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  InputSchema_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InputSchema_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InputSchema_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InputSchema_PropertiesEntry_DoNotUse& other);
  static const InputSchema_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InputSchema_PropertiesEntry_DoNotUse*>(&_InputSchema_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.InputSchema.PropertiesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_2eproto;
};

// -------------------------------------------------------------------

class InputSchema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.InputSchema) */ {
 public:
  inline InputSchema() : InputSchema(nullptr) {}
  ~InputSchema() override;
  explicit PROTOBUF_CONSTEXPR InputSchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputSchema(const InputSchema& from);
  InputSchema(InputSchema&& from) noexcept
    : InputSchema() {
    *this = ::std::move(from);
  }

  inline InputSchema& operator=(const InputSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputSchema& operator=(InputSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputSchema* internal_default_instance() {
    return reinterpret_cast<const InputSchema*>(
               &_InputSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(InputSchema& a, InputSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(InputSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputSchema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputSchema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputSchema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputSchema& from) {
    InputSchema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputSchema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.InputSchema";
  }
  protected:
  explicit InputSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 2,
    kRequiredFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // map<string, bytes> properties = 2;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // repeated string required = 3;
  int required_size() const;
  private:
  int _internal_required_size() const;
  public:
  void clear_required();
  const std::string& required(int index) const;
  std::string* mutable_required(int index);
  void set_required(int index, const std::string& value);
  void set_required(int index, std::string&& value);
  void set_required(int index, const char* value);
  void set_required(int index, const char* value, size_t size);
  std::string* add_required();
  void add_required(const std::string& value);
  void add_required(std::string&& value);
  void add_required(const char* value);
  void add_required(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required();
  private:
  const std::string& _internal_required(int index) const;
  std::string* _internal_add_required();
  public:

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:mcp.InputSchema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InputSchema_PropertiesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> properties_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ToolAnnotations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ToolAnnotations) */ {
 public:
  inline ToolAnnotations() : ToolAnnotations(nullptr) {}
  ~ToolAnnotations() override;
  explicit PROTOBUF_CONSTEXPR ToolAnnotations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolAnnotations(const ToolAnnotations& from);
  ToolAnnotations(ToolAnnotations&& from) noexcept
    : ToolAnnotations() {
    *this = ::std::move(from);
  }

  inline ToolAnnotations& operator=(const ToolAnnotations& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolAnnotations& operator=(ToolAnnotations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolAnnotations& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolAnnotations* internal_default_instance() {
    return reinterpret_cast<const ToolAnnotations*>(
               &_ToolAnnotations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ToolAnnotations& a, ToolAnnotations& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolAnnotations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolAnnotations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolAnnotations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolAnnotations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolAnnotations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolAnnotations& from) {
    ToolAnnotations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolAnnotations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ToolAnnotations";
  }
  protected:
  explicit ToolAnnotations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kReadOnlyHintFieldNumber = 2,
    kDestructiveHintFieldNumber = 3,
    kIdempotentHintFieldNumber = 4,
    kOpenWorldHintFieldNumber = 5,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // bool read_only_hint = 2;
  void clear_read_only_hint();
  bool read_only_hint() const;
  void set_read_only_hint(bool value);
  private:
  bool _internal_read_only_hint() const;
  void _internal_set_read_only_hint(bool value);
  public:

  // bool destructive_hint = 3;
  void clear_destructive_hint();
  bool destructive_hint() const;
  void set_destructive_hint(bool value);
  private:
  bool _internal_destructive_hint() const;
  void _internal_set_destructive_hint(bool value);
  public:

  // bool idempotent_hint = 4;
  void clear_idempotent_hint();
  bool idempotent_hint() const;
  void set_idempotent_hint(bool value);
  private:
  bool _internal_idempotent_hint() const;
  void _internal_set_idempotent_hint(bool value);
  public:

  // bool open_world_hint = 5;
  void clear_open_world_hint();
  bool open_world_hint() const;
  void set_open_world_hint(bool value);
  private:
  bool _internal_open_world_hint() const;
  void _internal_set_open_world_hint(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.ToolAnnotations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    bool read_only_hint_;
    bool destructive_hint_;
    bool idempotent_hint_;
    bool open_world_hint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class Annotations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Annotations) */ {
 public:
  inline Annotations() : Annotations(nullptr) {}
  ~Annotations() override;
  explicit PROTOBUF_CONSTEXPR Annotations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Annotations(const Annotations& from);
  Annotations(Annotations&& from) noexcept
    : Annotations() {
    *this = ::std::move(from);
  }

  inline Annotations& operator=(const Annotations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Annotations& operator=(Annotations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Annotations& default_instance() {
    return *internal_default_instance();
  }
  static inline const Annotations* internal_default_instance() {
    return reinterpret_cast<const Annotations*>(
               &_Annotations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Annotations& a, Annotations& b) {
    a.Swap(&b);
  }
  inline void Swap(Annotations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Annotations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Annotations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Annotations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Annotations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Annotations& from) {
    Annotations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Annotations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Annotations";
  }
  protected:
  explicit Annotations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudienceFieldNumber = 1,
    kPriorityFieldNumber = 2,
  };
  // repeated .mcp.Role audience = 1;
  int audience_size() const;
  private:
  int _internal_audience_size() const;
  public:
  void clear_audience();
  private:
  ::mcp::Role _internal_audience(int index) const;
  void _internal_add_audience(::mcp::Role value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_audience();
  public:
  ::mcp::Role audience(int index) const;
  void set_audience(int index, ::mcp::Role value);
  void add_audience(::mcp::Role value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& audience() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_audience();

  // float priority = 2;
  void clear_priority();
  float priority() const;
  void set_priority(float value);
  private:
  float _internal_priority() const;
  void _internal_set_priority(float value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.Annotations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> audience_;
    mutable std::atomic<int> _audience_cached_byte_size_;
    float priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class TextContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.TextContent) */ {
 public:
  inline TextContent() : TextContent(nullptr) {}
  ~TextContent() override;
  explicit PROTOBUF_CONSTEXPR TextContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextContent(const TextContent& from);
  TextContent(TextContent&& from) noexcept
    : TextContent() {
    *this = ::std::move(from);
  }

  inline TextContent& operator=(const TextContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextContent& operator=(TextContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextContent* internal_default_instance() {
    return reinterpret_cast<const TextContent*>(
               &_TextContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TextContent& a, TextContent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextContent& from) {
    TextContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.TextContent";
  }
  protected:
  explicit TextContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kTextFieldNumber = 2,
    kAnnotationsFieldNumber = 3,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .mcp.Annotations annotations = 3;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::mcp::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  ::mcp::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::mcp::Annotations* annotations);
  ::mcp::Annotations* unsafe_arena_release_annotations();

  // @@protoc_insertion_point(class_scope:mcp.TextContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::mcp::Annotations* annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ImageContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ImageContent) */ {
 public:
  inline ImageContent() : ImageContent(nullptr) {}
  ~ImageContent() override;
  explicit PROTOBUF_CONSTEXPR ImageContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageContent(const ImageContent& from);
  ImageContent(ImageContent&& from) noexcept
    : ImageContent() {
    *this = ::std::move(from);
  }

  inline ImageContent& operator=(const ImageContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageContent& operator=(ImageContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageContent* internal_default_instance() {
    return reinterpret_cast<const ImageContent*>(
               &_ImageContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ImageContent& a, ImageContent& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageContent& from) {
    ImageContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ImageContent";
  }
  protected:
  explicit ImageContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDataFieldNumber = 2,
    kMimeTypeFieldNumber = 3,
    kAnnotationsFieldNumber = 4,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string mime_type = 3;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // .mcp.Annotations annotations = 4;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::mcp::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  ::mcp::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::mcp::Annotations* annotations);
  ::mcp::Annotations* unsafe_arena_release_annotations();

  // @@protoc_insertion_point(class_scope:mcp.ImageContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::mcp::Annotations* annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class AudioContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.AudioContent) */ {
 public:
  inline AudioContent() : AudioContent(nullptr) {}
  ~AudioContent() override;
  explicit PROTOBUF_CONSTEXPR AudioContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioContent(const AudioContent& from);
  AudioContent(AudioContent&& from) noexcept
    : AudioContent() {
    *this = ::std::move(from);
  }

  inline AudioContent& operator=(const AudioContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioContent& operator=(AudioContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioContent* internal_default_instance() {
    return reinterpret_cast<const AudioContent*>(
               &_AudioContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(AudioContent& a, AudioContent& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioContent& from) {
    AudioContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.AudioContent";
  }
  protected:
  explicit AudioContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDataFieldNumber = 2,
    kMimeTypeFieldNumber = 3,
    kAnnotationsFieldNumber = 4,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string mime_type = 3;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // .mcp.Annotations annotations = 4;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::mcp::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  ::mcp::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::mcp::Annotations* annotations);
  ::mcp::Annotations* unsafe_arena_release_annotations();

  // @@protoc_insertion_point(class_scope:mcp.AudioContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::mcp::Annotations* annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ModelPreferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ModelPreferences) */ {
 public:
  inline ModelPreferences() : ModelPreferences(nullptr) {}
  ~ModelPreferences() override;
  explicit PROTOBUF_CONSTEXPR ModelPreferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelPreferences(const ModelPreferences& from);
  ModelPreferences(ModelPreferences&& from) noexcept
    : ModelPreferences() {
    *this = ::std::move(from);
  }

  inline ModelPreferences& operator=(const ModelPreferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelPreferences& operator=(ModelPreferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelPreferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelPreferences* internal_default_instance() {
    return reinterpret_cast<const ModelPreferences*>(
               &_ModelPreferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ModelPreferences& a, ModelPreferences& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelPreferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelPreferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelPreferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelPreferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelPreferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelPreferences& from) {
    ModelPreferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelPreferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ModelPreferences";
  }
  protected:
  explicit ModelPreferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHintsFieldNumber = 1,
    kCostPriorityFieldNumber = 2,
    kSpeedPriorityFieldNumber = 3,
    kIntelligencePriorityFieldNumber = 4,
  };
  // repeated .mcp.ModelHint hints = 1;
  int hints_size() const;
  private:
  int _internal_hints_size() const;
  public:
  void clear_hints();
  ::mcp::ModelHint* mutable_hints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ModelHint >*
      mutable_hints();
  private:
  const ::mcp::ModelHint& _internal_hints(int index) const;
  ::mcp::ModelHint* _internal_add_hints();
  public:
  const ::mcp::ModelHint& hints(int index) const;
  ::mcp::ModelHint* add_hints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ModelHint >&
      hints() const;

  // float cost_priority = 2;
  void clear_cost_priority();
  float cost_priority() const;
  void set_cost_priority(float value);
  private:
  float _internal_cost_priority() const;
  void _internal_set_cost_priority(float value);
  public:

  // float speed_priority = 3;
  void clear_speed_priority();
  float speed_priority() const;
  void set_speed_priority(float value);
  private:
  float _internal_speed_priority() const;
  void _internal_set_speed_priority(float value);
  public:

  // float intelligence_priority = 4;
  void clear_intelligence_priority();
  float intelligence_priority() const;
  void set_intelligence_priority(float value);
  private:
  float _internal_intelligence_priority() const;
  void _internal_set_intelligence_priority(float value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.ModelPreferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ModelHint > hints_;
    float cost_priority_;
    float speed_priority_;
    float intelligence_priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ModelHint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ModelHint) */ {
 public:
  inline ModelHint() : ModelHint(nullptr) {}
  ~ModelHint() override;
  explicit PROTOBUF_CONSTEXPR ModelHint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelHint(const ModelHint& from);
  ModelHint(ModelHint&& from) noexcept
    : ModelHint() {
    *this = ::std::move(from);
  }

  inline ModelHint& operator=(const ModelHint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelHint& operator=(ModelHint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelHint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelHint* internal_default_instance() {
    return reinterpret_cast<const ModelHint*>(
               &_ModelHint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ModelHint& a, ModelHint& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelHint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelHint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelHint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelHint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelHint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelHint& from) {
    ModelHint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelHint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ModelHint";
  }
  protected:
  explicit ModelHint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mcp.ModelHint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ResourceReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ResourceReference) */ {
 public:
  inline ResourceReference() : ResourceReference(nullptr) {}
  ~ResourceReference() override;
  explicit PROTOBUF_CONSTEXPR ResourceReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceReference(const ResourceReference& from);
  ResourceReference(ResourceReference&& from) noexcept
    : ResourceReference() {
    *this = ::std::move(from);
  }

  inline ResourceReference& operator=(const ResourceReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceReference& operator=(ResourceReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceReference* internal_default_instance() {
    return reinterpret_cast<const ResourceReference*>(
               &_ResourceReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ResourceReference& a, ResourceReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceReference& from) {
    ResourceReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ResourceReference";
  }
  protected:
  explicit ResourceReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kUriFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string uri = 2;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:mcp.ResourceReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class PromptReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.PromptReference) */ {
 public:
  inline PromptReference() : PromptReference(nullptr) {}
  ~PromptReference() override;
  explicit PROTOBUF_CONSTEXPR PromptReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptReference(const PromptReference& from);
  PromptReference(PromptReference&& from) noexcept
    : PromptReference() {
    *this = ::std::move(from);
  }

  inline PromptReference& operator=(const PromptReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptReference& operator=(PromptReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PromptReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptReference* internal_default_instance() {
    return reinterpret_cast<const PromptReference*>(
               &_PromptReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(PromptReference& a, PromptReference& b) {
    a.Swap(&b);
  }
  inline void Swap(PromptReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PromptReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PromptReference& from) {
    PromptReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromptReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.PromptReference";
  }
  protected:
  explicit PromptReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mcp.PromptReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class Root final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Root) */ {
 public:
  inline Root() : Root(nullptr) {}
  ~Root() override;
  explicit PROTOBUF_CONSTEXPR Root(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Root(const Root& from);
  Root(Root&& from) noexcept
    : Root() {
    *this = ::std::move(from);
  }

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }
  inline Root& operator=(Root&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Root& default_instance() {
    return *internal_default_instance();
  }
  static inline const Root* internal_default_instance() {
    return reinterpret_cast<const Root*>(
               &_Root_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(Root& a, Root& b) {
    a.Swap(&b);
  }
  inline void Swap(Root* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Root* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Root* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Root>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Root& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Root& from) {
    Root::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Root* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Root";
  }
  protected:
  explicit Root(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mcp.Root)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class InitializeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.InitializeRequest) */ {
 public:
  inline InitializeRequest() : InitializeRequest(nullptr) {}
  ~InitializeRequest() override;
  explicit PROTOBUF_CONSTEXPR InitializeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeRequest(const InitializeRequest& from);
  InitializeRequest(InitializeRequest&& from) noexcept
    : InitializeRequest() {
    *this = ::std::move(from);
  }

  inline InitializeRequest& operator=(const InitializeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeRequest& operator=(InitializeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeRequest* internal_default_instance() {
    return reinterpret_cast<const InitializeRequest*>(
               &_InitializeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(InitializeRequest& a, InitializeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitializeRequest& from) {
    InitializeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.InitializeRequest";
  }
  protected:
  explicit InitializeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .mcp.InitializeParams params = 2;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::mcp::InitializeParams& params() const;
  PROTOBUF_NODISCARD ::mcp::InitializeParams* release_params();
  ::mcp::InitializeParams* mutable_params();
  void set_allocated_params(::mcp::InitializeParams* params);
  private:
  const ::mcp::InitializeParams& _internal_params() const;
  ::mcp::InitializeParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::mcp::InitializeParams* params);
  ::mcp::InitializeParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:mcp.InitializeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::mcp::InitializeParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class InitializeParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.InitializeParams) */ {
 public:
  inline InitializeParams() : InitializeParams(nullptr) {}
  ~InitializeParams() override;
  explicit PROTOBUF_CONSTEXPR InitializeParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeParams(const InitializeParams& from);
  InitializeParams(InitializeParams&& from) noexcept
    : InitializeParams() {
    *this = ::std::move(from);
  }

  inline InitializeParams& operator=(const InitializeParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeParams& operator=(InitializeParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeParams* internal_default_instance() {
    return reinterpret_cast<const InitializeParams*>(
               &_InitializeParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(InitializeParams& a, InitializeParams& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitializeParams& from) {
    InitializeParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.InitializeParams";
  }
  protected:
  explicit InitializeParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolVersionFieldNumber = 1,
    kCapabilitiesFieldNumber = 2,
    kClientInfoFieldNumber = 3,
  };
  // string protocol_version = 1;
  void clear_protocol_version();
  const std::string& protocol_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol_version();
  PROTOBUF_NODISCARD std::string* release_protocol_version();
  void set_allocated_protocol_version(std::string* protocol_version);
  private:
  const std::string& _internal_protocol_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_version(const std::string& value);
  std::string* _internal_mutable_protocol_version();
  public:

  // .mcp.ClientCapabilities capabilities = 2;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::mcp::ClientCapabilities& capabilities() const;
  PROTOBUF_NODISCARD ::mcp::ClientCapabilities* release_capabilities();
  ::mcp::ClientCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ClientCapabilities* capabilities);
  private:
  const ::mcp::ClientCapabilities& _internal_capabilities() const;
  ::mcp::ClientCapabilities* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::mcp::ClientCapabilities* capabilities);
  ::mcp::ClientCapabilities* unsafe_arena_release_capabilities();

  // .mcp.Implementation client_info = 3;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::mcp::Implementation& client_info() const;
  PROTOBUF_NODISCARD ::mcp::Implementation* release_client_info();
  ::mcp::Implementation* mutable_client_info();
  void set_allocated_client_info(::mcp::Implementation* client_info);
  private:
  const ::mcp::Implementation& _internal_client_info() const;
  ::mcp::Implementation* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::mcp::Implementation* client_info);
  ::mcp::Implementation* unsafe_arena_release_client_info();

  // @@protoc_insertion_point(class_scope:mcp.InitializeParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_version_;
    ::mcp::ClientCapabilities* capabilities_;
    ::mcp::Implementation* client_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class InitializeResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.InitializeResult) */ {
 public:
  inline InitializeResult() : InitializeResult(nullptr) {}
  ~InitializeResult() override;
  explicit PROTOBUF_CONSTEXPR InitializeResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeResult(const InitializeResult& from);
  InitializeResult(InitializeResult&& from) noexcept
    : InitializeResult() {
    *this = ::std::move(from);
  }

  inline InitializeResult& operator=(const InitializeResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeResult& operator=(InitializeResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeResult* internal_default_instance() {
    return reinterpret_cast<const InitializeResult*>(
               &_InitializeResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(InitializeResult& a, InitializeResult& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitializeResult& from) {
    InitializeResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.InitializeResult";
  }
  protected:
  explicit InitializeResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolVersionFieldNumber = 1,
    kInstructionsFieldNumber = 4,
    kCapabilitiesFieldNumber = 2,
    kServerInfoFieldNumber = 3,
  };
  // string protocol_version = 1;
  void clear_protocol_version();
  const std::string& protocol_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol_version();
  PROTOBUF_NODISCARD std::string* release_protocol_version();
  void set_allocated_protocol_version(std::string* protocol_version);
  private:
  const std::string& _internal_protocol_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_version(const std::string& value);
  std::string* _internal_mutable_protocol_version();
  public:

  // string instructions = 4;
  void clear_instructions();
  const std::string& instructions() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instructions(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instructions();
  PROTOBUF_NODISCARD std::string* release_instructions();
  void set_allocated_instructions(std::string* instructions);
  private:
  const std::string& _internal_instructions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instructions(const std::string& value);
  std::string* _internal_mutable_instructions();
  public:

  // .mcp.ServerCapabilities capabilities = 2;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::mcp::ServerCapabilities& capabilities() const;
  PROTOBUF_NODISCARD ::mcp::ServerCapabilities* release_capabilities();
  ::mcp::ServerCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ServerCapabilities* capabilities);
  private:
  const ::mcp::ServerCapabilities& _internal_capabilities() const;
  ::mcp::ServerCapabilities* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::mcp::ServerCapabilities* capabilities);
  ::mcp::ServerCapabilities* unsafe_arena_release_capabilities();

  // .mcp.Implementation server_info = 3;
  bool has_server_info() const;
  private:
  bool _internal_has_server_info() const;
  public:
  void clear_server_info();
  const ::mcp::Implementation& server_info() const;
  PROTOBUF_NODISCARD ::mcp::Implementation* release_server_info();
  ::mcp::Implementation* mutable_server_info();
  void set_allocated_server_info(::mcp::Implementation* server_info);
  private:
  const ::mcp::Implementation& _internal_server_info() const;
  ::mcp::Implementation* _internal_mutable_server_info();
  public:
  void unsafe_arena_set_allocated_server_info(
      ::mcp::Implementation* server_info);
  ::mcp::Implementation* unsafe_arena_release_server_info();

  // @@protoc_insertion_point(class_scope:mcp.InitializeResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instructions_;
    ::mcp::ServerCapabilities* capabilities_;
    ::mcp::Implementation* server_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ListResourcesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ListResourcesRequest) */ {
 public:
  inline ListResourcesRequest() : ListResourcesRequest(nullptr) {}
  ~ListResourcesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListResourcesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResourcesRequest(const ListResourcesRequest& from);
  ListResourcesRequest(ListResourcesRequest&& from) noexcept
    : ListResourcesRequest() {
    *this = ::std::move(from);
  }

  inline ListResourcesRequest& operator=(const ListResourcesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResourcesRequest& operator=(ListResourcesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResourcesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResourcesRequest* internal_default_instance() {
    return reinterpret_cast<const ListResourcesRequest*>(
               &_ListResourcesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ListResourcesRequest& a, ListResourcesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResourcesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResourcesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListResourcesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListResourcesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResourcesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListResourcesRequest& from) {
    ListResourcesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResourcesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ListResourcesRequest";
  }
  protected:
  explicit ListResourcesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .mcp.PaginatedParams params = 2;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::mcp::PaginatedParams& params() const;
  PROTOBUF_NODISCARD ::mcp::PaginatedParams* release_params();
  ::mcp::PaginatedParams* mutable_params();
  void set_allocated_params(::mcp::PaginatedParams* params);
  private:
  const ::mcp::PaginatedParams& _internal_params() const;
  ::mcp::PaginatedParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::mcp::PaginatedParams* params);
  ::mcp::PaginatedParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:mcp.ListResourcesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::mcp::PaginatedParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ListResourcesResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ListResourcesResult) */ {
 public:
  inline ListResourcesResult() : ListResourcesResult(nullptr) {}
  ~ListResourcesResult() override;
  explicit PROTOBUF_CONSTEXPR ListResourcesResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResourcesResult(const ListResourcesResult& from);
  ListResourcesResult(ListResourcesResult&& from) noexcept
    : ListResourcesResult() {
    *this = ::std::move(from);
  }

  inline ListResourcesResult& operator=(const ListResourcesResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResourcesResult& operator=(ListResourcesResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResourcesResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResourcesResult* internal_default_instance() {
    return reinterpret_cast<const ListResourcesResult*>(
               &_ListResourcesResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ListResourcesResult& a, ListResourcesResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResourcesResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResourcesResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListResourcesResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListResourcesResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResourcesResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListResourcesResult& from) {
    ListResourcesResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResourcesResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ListResourcesResult";
  }
  protected:
  explicit ListResourcesResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 1,
    kNextCursorFieldNumber = 2,
  };
  // repeated .mcp.Resource resources = 1;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::mcp::Resource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Resource >*
      mutable_resources();
  private:
  const ::mcp::Resource& _internal_resources(int index) const;
  ::mcp::Resource* _internal_add_resources();
  public:
  const ::mcp::Resource& resources(int index) const;
  ::mcp::Resource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Resource >&
      resources() const;

  // string next_cursor = 2;
  void clear_next_cursor();
  const std::string& next_cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_cursor();
  PROTOBUF_NODISCARD std::string* release_next_cursor();
  void set_allocated_next_cursor(std::string* next_cursor);
  private:
  const std::string& _internal_next_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_cursor(const std::string& value);
  std::string* _internal_mutable_next_cursor();
  public:

  // @@protoc_insertion_point(class_scope:mcp.ListResourcesResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Resource > resources_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_cursor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ReadResourceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ReadResourceRequest) */ {
 public:
  inline ReadResourceRequest() : ReadResourceRequest(nullptr) {}
  ~ReadResourceRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadResourceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadResourceRequest(const ReadResourceRequest& from);
  ReadResourceRequest(ReadResourceRequest&& from) noexcept
    : ReadResourceRequest() {
    *this = ::std::move(from);
  }

  inline ReadResourceRequest& operator=(const ReadResourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadResourceRequest& operator=(ReadResourceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadResourceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadResourceRequest* internal_default_instance() {
    return reinterpret_cast<const ReadResourceRequest*>(
               &_ReadResourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(ReadResourceRequest& a, ReadResourceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadResourceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadResourceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadResourceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadResourceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadResourceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadResourceRequest& from) {
    ReadResourceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResourceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ReadResourceRequest";
  }
  protected:
  explicit ReadResourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .mcp.ReadResourceParams params = 2;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::mcp::ReadResourceParams& params() const;
  PROTOBUF_NODISCARD ::mcp::ReadResourceParams* release_params();
  ::mcp::ReadResourceParams* mutable_params();
  void set_allocated_params(::mcp::ReadResourceParams* params);
  private:
  const ::mcp::ReadResourceParams& _internal_params() const;
  ::mcp::ReadResourceParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::mcp::ReadResourceParams* params);
  ::mcp::ReadResourceParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:mcp.ReadResourceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::mcp::ReadResourceParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ReadResourceParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ReadResourceParams) */ {
 public:
  inline ReadResourceParams() : ReadResourceParams(nullptr) {}
  ~ReadResourceParams() override;
  explicit PROTOBUF_CONSTEXPR ReadResourceParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadResourceParams(const ReadResourceParams& from);
  ReadResourceParams(ReadResourceParams&& from) noexcept
    : ReadResourceParams() {
    *this = ::std::move(from);
  }

  inline ReadResourceParams& operator=(const ReadResourceParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadResourceParams& operator=(ReadResourceParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadResourceParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadResourceParams* internal_default_instance() {
    return reinterpret_cast<const ReadResourceParams*>(
               &_ReadResourceParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ReadResourceParams& a, ReadResourceParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadResourceParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadResourceParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadResourceParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadResourceParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadResourceParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadResourceParams& from) {
    ReadResourceParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResourceParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ReadResourceParams";
  }
  protected:
  explicit ReadResourceParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:mcp.ReadResourceParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class ReadResourceResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ReadResourceResult) */ {
 public:
  inline ReadResourceResult() : ReadResourceResult(nullptr) {}
  ~ReadResourceResult() override;
  explicit PROTOBUF_CONSTEXPR ReadResourceResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadResourceResult(const ReadResourceResult& from);
  ReadResourceResult(ReadResourceResult&& from) noexcept
    : ReadResourceResult() {
    *this = ::std::move(from);
  }

  inline ReadResourceResult& operator=(const ReadResourceResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadResourceResult& operator=(ReadResourceResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadResourceResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadResourceResult* internal_default_instance() {
    return reinterpret_cast<const ReadResourceResult*>(
               &_ReadResourceResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ReadResourceResult& a, ReadResourceResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadResourceResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadResourceResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadResourceResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadResourceResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadResourceResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadResourceResult& from) {
    ReadResourceResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResourceResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ReadResourceResult";
  }
  protected:
  explicit ReadResourceResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
  };
  // repeated .mcp.ResourceContents contents = 1;
  int contents_size() const;
  private:
  int _internal_contents_size() const;
  public:
  void clear_contents();
  ::mcp::ResourceContents* mutable_contents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ResourceContents >*
      mutable_contents();
  private:
  const ::mcp::ResourceContents& _internal_contents(int index) const;
  ::mcp::ResourceContents* _internal_add_contents();
  public:
  const ::mcp::ResourceContents& contents(int index) const;
  ::mcp::ResourceContents* add_contents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ResourceContents >&
      contents() const;

  // @@protoc_insertion_point(class_scope:mcp.ReadResourceResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ResourceContents > contents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// -------------------------------------------------------------------

class PaginatedParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.PaginatedParams) */ {
 public:
  inline PaginatedParams() : PaginatedParams(nullptr) {}
  ~PaginatedParams() override;
  explicit PROTOBUF_CONSTEXPR PaginatedParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginatedParams(const PaginatedParams& from);
  PaginatedParams(PaginatedParams&& from) noexcept
    : PaginatedParams() {
    *this = ::std::move(from);
  }

  inline PaginatedParams& operator=(const PaginatedParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginatedParams& operator=(PaginatedParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginatedParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginatedParams* internal_default_instance() {
    return reinterpret_cast<const PaginatedParams*>(
               &_PaginatedParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(PaginatedParams& a, PaginatedParams& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginatedParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginatedParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaginatedParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaginatedParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginatedParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaginatedParams& from) {
    PaginatedParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginatedParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.PaginatedParams";
  }
  protected:
  explicit PaginatedParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCursorFieldNumber = 1,
  };
  // string cursor = 1;
  void clear_cursor();
  const std::string& cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cursor();
  PROTOBUF_NODISCARD std::string* release_cursor();
  void set_allocated_cursor(std::string* cursor);
  private:
  const std::string& _internal_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cursor(const std::string& value);
  std::string* _internal_mutable_cursor();
  public:

  // @@protoc_insertion_point(class_scope:mcp.PaginatedParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cursor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JSONRPCMessage

// .mcp.JSONRPCRequest request = 1;
inline bool JSONRPCMessage::_internal_has_request() const {
  return message_case() == kRequest;
}
inline bool JSONRPCMessage::has_request() const {
  return _internal_has_request();
}
inline void JSONRPCMessage::set_has_request() {
  _impl_._oneof_case_[0] = kRequest;
}
inline void JSONRPCMessage::clear_request() {
  if (_internal_has_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.request_;
    }
    clear_has_message();
  }
}
inline ::mcp::JSONRPCRequest* JSONRPCMessage::release_request() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.request)
  if (_internal_has_request()) {
    clear_has_message();
    ::mcp::JSONRPCRequest* temp = _impl_.message_.request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::JSONRPCRequest& JSONRPCMessage::_internal_request() const {
  return _internal_has_request()
      ? *_impl_.message_.request_
      : reinterpret_cast< ::mcp::JSONRPCRequest&>(::mcp::_JSONRPCRequest_default_instance_);
}
inline const ::mcp::JSONRPCRequest& JSONRPCMessage::request() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.request)
  return _internal_request();
}
inline ::mcp::JSONRPCRequest* JSONRPCMessage::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.JSONRPCMessage.request)
  if (_internal_has_request()) {
    clear_has_message();
    ::mcp::JSONRPCRequest* temp = _impl_.message_.request_;
    _impl_.message_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JSONRPCMessage::unsafe_arena_set_allocated_request(::mcp::JSONRPCRequest* request) {
  clear_message();
  if (request) {
    set_has_request();
    _impl_.message_.request_ = request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCMessage.request)
}
inline ::mcp::JSONRPCRequest* JSONRPCMessage::_internal_mutable_request() {
  if (!_internal_has_request()) {
    clear_message();
    set_has_request();
    _impl_.message_.request_ = CreateMaybeMessage< ::mcp::JSONRPCRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.request_;
}
inline ::mcp::JSONRPCRequest* JSONRPCMessage::mutable_request() {
  ::mcp::JSONRPCRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.request)
  return _msg;
}

// .mcp.JSONRPCNotification notification = 2;
inline bool JSONRPCMessage::_internal_has_notification() const {
  return message_case() == kNotification;
}
inline bool JSONRPCMessage::has_notification() const {
  return _internal_has_notification();
}
inline void JSONRPCMessage::set_has_notification() {
  _impl_._oneof_case_[0] = kNotification;
}
inline void JSONRPCMessage::clear_notification() {
  if (_internal_has_notification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.notification_;
    }
    clear_has_message();
  }
}
inline ::mcp::JSONRPCNotification* JSONRPCMessage::release_notification() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.notification)
  if (_internal_has_notification()) {
    clear_has_message();
    ::mcp::JSONRPCNotification* temp = _impl_.message_.notification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::JSONRPCNotification& JSONRPCMessage::_internal_notification() const {
  return _internal_has_notification()
      ? *_impl_.message_.notification_
      : reinterpret_cast< ::mcp::JSONRPCNotification&>(::mcp::_JSONRPCNotification_default_instance_);
}
inline const ::mcp::JSONRPCNotification& JSONRPCMessage::notification() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.notification)
  return _internal_notification();
}
inline ::mcp::JSONRPCNotification* JSONRPCMessage::unsafe_arena_release_notification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.JSONRPCMessage.notification)
  if (_internal_has_notification()) {
    clear_has_message();
    ::mcp::JSONRPCNotification* temp = _impl_.message_.notification_;
    _impl_.message_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JSONRPCMessage::unsafe_arena_set_allocated_notification(::mcp::JSONRPCNotification* notification) {
  clear_message();
  if (notification) {
    set_has_notification();
    _impl_.message_.notification_ = notification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCMessage.notification)
}
inline ::mcp::JSONRPCNotification* JSONRPCMessage::_internal_mutable_notification() {
  if (!_internal_has_notification()) {
    clear_message();
    set_has_notification();
    _impl_.message_.notification_ = CreateMaybeMessage< ::mcp::JSONRPCNotification >(GetArenaForAllocation());
  }
  return _impl_.message_.notification_;
}
inline ::mcp::JSONRPCNotification* JSONRPCMessage::mutable_notification() {
  ::mcp::JSONRPCNotification* _msg = _internal_mutable_notification();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.notification)
  return _msg;
}

// .mcp.JSONRPCBatchRequest batch_request = 3;
inline bool JSONRPCMessage::_internal_has_batch_request() const {
  return message_case() == kBatchRequest;
}
inline bool JSONRPCMessage::has_batch_request() const {
  return _internal_has_batch_request();
}
inline void JSONRPCMessage::set_has_batch_request() {
  _impl_._oneof_case_[0] = kBatchRequest;
}
inline void JSONRPCMessage::clear_batch_request() {
  if (_internal_has_batch_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.batch_request_;
    }
    clear_has_message();
  }
}
inline ::mcp::JSONRPCBatchRequest* JSONRPCMessage::release_batch_request() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.batch_request)
  if (_internal_has_batch_request()) {
    clear_has_message();
    ::mcp::JSONRPCBatchRequest* temp = _impl_.message_.batch_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.batch_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::JSONRPCBatchRequest& JSONRPCMessage::_internal_batch_request() const {
  return _internal_has_batch_request()
      ? *_impl_.message_.batch_request_
      : reinterpret_cast< ::mcp::JSONRPCBatchRequest&>(::mcp::_JSONRPCBatchRequest_default_instance_);
}
inline const ::mcp::JSONRPCBatchRequest& JSONRPCMessage::batch_request() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.batch_request)
  return _internal_batch_request();
}
inline ::mcp::JSONRPCBatchRequest* JSONRPCMessage::unsafe_arena_release_batch_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.JSONRPCMessage.batch_request)
  if (_internal_has_batch_request()) {
    clear_has_message();
    ::mcp::JSONRPCBatchRequest* temp = _impl_.message_.batch_request_;
    _impl_.message_.batch_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JSONRPCMessage::unsafe_arena_set_allocated_batch_request(::mcp::JSONRPCBatchRequest* batch_request) {
  clear_message();
  if (batch_request) {
    set_has_batch_request();
    _impl_.message_.batch_request_ = batch_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCMessage.batch_request)
}
inline ::mcp::JSONRPCBatchRequest* JSONRPCMessage::_internal_mutable_batch_request() {
  if (!_internal_has_batch_request()) {
    clear_message();
    set_has_batch_request();
    _impl_.message_.batch_request_ = CreateMaybeMessage< ::mcp::JSONRPCBatchRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.batch_request_;
}
inline ::mcp::JSONRPCBatchRequest* JSONRPCMessage::mutable_batch_request() {
  ::mcp::JSONRPCBatchRequest* _msg = _internal_mutable_batch_request();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.batch_request)
  return _msg;
}

// .mcp.JSONRPCResponse response = 4;
inline bool JSONRPCMessage::_internal_has_response() const {
  return message_case() == kResponse;
}
inline bool JSONRPCMessage::has_response() const {
  return _internal_has_response();
}
inline void JSONRPCMessage::set_has_response() {
  _impl_._oneof_case_[0] = kResponse;
}
inline void JSONRPCMessage::clear_response() {
  if (_internal_has_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.response_;
    }
    clear_has_message();
  }
}
inline ::mcp::JSONRPCResponse* JSONRPCMessage::release_response() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.response)
  if (_internal_has_response()) {
    clear_has_message();
    ::mcp::JSONRPCResponse* temp = _impl_.message_.response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::JSONRPCResponse& JSONRPCMessage::_internal_response() const {
  return _internal_has_response()
      ? *_impl_.message_.response_
      : reinterpret_cast< ::mcp::JSONRPCResponse&>(::mcp::_JSONRPCResponse_default_instance_);
}
inline const ::mcp::JSONRPCResponse& JSONRPCMessage::response() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.response)
  return _internal_response();
}
inline ::mcp::JSONRPCResponse* JSONRPCMessage::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.JSONRPCMessage.response)
  if (_internal_has_response()) {
    clear_has_message();
    ::mcp::JSONRPCResponse* temp = _impl_.message_.response_;
    _impl_.message_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JSONRPCMessage::unsafe_arena_set_allocated_response(::mcp::JSONRPCResponse* response) {
  clear_message();
  if (response) {
    set_has_response();
    _impl_.message_.response_ = response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCMessage.response)
}
inline ::mcp::JSONRPCResponse* JSONRPCMessage::_internal_mutable_response() {
  if (!_internal_has_response()) {
    clear_message();
    set_has_response();
    _impl_.message_.response_ = CreateMaybeMessage< ::mcp::JSONRPCResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.response_;
}
inline ::mcp::JSONRPCResponse* JSONRPCMessage::mutable_response() {
  ::mcp::JSONRPCResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.response)
  return _msg;
}

// .mcp.JSONRPCError error = 5;
inline bool JSONRPCMessage::_internal_has_error() const {
  return message_case() == kError;
}
inline bool JSONRPCMessage::has_error() const {
  return _internal_has_error();
}
inline void JSONRPCMessage::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void JSONRPCMessage::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.error_;
    }
    clear_has_message();
  }
}
inline ::mcp::JSONRPCError* JSONRPCMessage::release_error() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.error)
  if (_internal_has_error()) {
    clear_has_message();
    ::mcp::JSONRPCError* temp = _impl_.message_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::JSONRPCError& JSONRPCMessage::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.message_.error_
      : reinterpret_cast< ::mcp::JSONRPCError&>(::mcp::_JSONRPCError_default_instance_);
}
inline const ::mcp::JSONRPCError& JSONRPCMessage::error() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.error)
  return _internal_error();
}
inline ::mcp::JSONRPCError* JSONRPCMessage::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.JSONRPCMessage.error)
  if (_internal_has_error()) {
    clear_has_message();
    ::mcp::JSONRPCError* temp = _impl_.message_.error_;
    _impl_.message_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JSONRPCMessage::unsafe_arena_set_allocated_error(::mcp::JSONRPCError* error) {
  clear_message();
  if (error) {
    set_has_error();
    _impl_.message_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCMessage.error)
}
inline ::mcp::JSONRPCError* JSONRPCMessage::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_ = CreateMaybeMessage< ::mcp::JSONRPCError >(GetArenaForAllocation());
  }
  return _impl_.message_.error_;
}
inline ::mcp::JSONRPCError* JSONRPCMessage::mutable_error() {
  ::mcp::JSONRPCError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.error)
  return _msg;
}

// .mcp.JSONRPCBatchResponse batch_response = 6;
inline bool JSONRPCMessage::_internal_has_batch_response() const {
  return message_case() == kBatchResponse;
}
inline bool JSONRPCMessage::has_batch_response() const {
  return _internal_has_batch_response();
}
inline void JSONRPCMessage::set_has_batch_response() {
  _impl_._oneof_case_[0] = kBatchResponse;
}
inline void JSONRPCMessage::clear_batch_response() {
  if (_internal_has_batch_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.batch_response_;
    }
    clear_has_message();
  }
}
inline ::mcp::JSONRPCBatchResponse* JSONRPCMessage::release_batch_response() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.batch_response)
  if (_internal_has_batch_response()) {
    clear_has_message();
    ::mcp::JSONRPCBatchResponse* temp = _impl_.message_.batch_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.batch_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::JSONRPCBatchResponse& JSONRPCMessage::_internal_batch_response() const {
  return _internal_has_batch_response()
      ? *_impl_.message_.batch_response_
      : reinterpret_cast< ::mcp::JSONRPCBatchResponse&>(::mcp::_JSONRPCBatchResponse_default_instance_);
}
inline const ::mcp::JSONRPCBatchResponse& JSONRPCMessage::batch_response() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.batch_response)
  return _internal_batch_response();
}
inline ::mcp::JSONRPCBatchResponse* JSONRPCMessage::unsafe_arena_release_batch_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.JSONRPCMessage.batch_response)
  if (_internal_has_batch_response()) {
    clear_has_message();
    ::mcp::JSONRPCBatchResponse* temp = _impl_.message_.batch_response_;
    _impl_.message_.batch_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JSONRPCMessage::unsafe_arena_set_allocated_batch_response(::mcp::JSONRPCBatchResponse* batch_response) {
  clear_message();
  if (batch_response) {
    set_has_batch_response();
    _impl_.message_.batch_response_ = batch_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCMessage.batch_response)
}
inline ::mcp::JSONRPCBatchResponse* JSONRPCMessage::_internal_mutable_batch_response() {
  if (!_internal_has_batch_response()) {
    clear_message();
    set_has_batch_response();
    _impl_.message_.batch_response_ = CreateMaybeMessage< ::mcp::JSONRPCBatchResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.batch_response_;
}
inline ::mcp::JSONRPCBatchResponse* JSONRPCMessage::mutable_batch_response() {
  ::mcp::JSONRPCBatchResponse* _msg = _internal_mutable_batch_response();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.batch_response)
  return _msg;
}

inline bool JSONRPCMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void JSONRPCMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline JSONRPCMessage::MessageCase JSONRPCMessage::message_case() const {
  return JSONRPCMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// JSONRPCRequest

// string jsonrpc = 1;
inline void JSONRPCRequest::clear_jsonrpc() {
  _impl_.jsonrpc_.ClearToEmpty();
}
inline const std::string& JSONRPCRequest::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.jsonrpc)
  return _internal_jsonrpc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCRequest::set_jsonrpc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jsonrpc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCRequest.jsonrpc)
}
inline std::string* JSONRPCRequest::mutable_jsonrpc() {
  std::string* _s = _internal_mutable_jsonrpc();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.jsonrpc)
  return _s;
}
inline const std::string& JSONRPCRequest::_internal_jsonrpc() const {
  return _impl_.jsonrpc_.Get();
}
inline void JSONRPCRequest::_internal_set_jsonrpc(const std::string& value) {
  
  _impl_.jsonrpc_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCRequest::_internal_mutable_jsonrpc() {
  
  return _impl_.jsonrpc_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCRequest::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.jsonrpc)
  return _impl_.jsonrpc_.Release();
}
inline void JSONRPCRequest::set_allocated_jsonrpc(std::string* jsonrpc) {
  if (jsonrpc != nullptr) {
    
  } else {
    
  }
  _impl_.jsonrpc_.SetAllocated(jsonrpc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jsonrpc_.IsDefault()) {
    _impl_.jsonrpc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.jsonrpc)
}

// string id = 2;
inline void JSONRPCRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& JSONRPCRequest::id() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCRequest.id)
}
inline std::string* JSONRPCRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.id)
  return _s;
}
inline const std::string& JSONRPCRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void JSONRPCRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCRequest::release_id() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.id)
  return _impl_.id_.Release();
}
inline void JSONRPCRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.id)
}

// string method = 3;
inline void JSONRPCRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& JSONRPCRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCRequest.method)
}
inline std::string* JSONRPCRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.method)
  return _s;
}
inline const std::string& JSONRPCRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void JSONRPCRequest::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCRequest::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.method)
  return _impl_.method_.Release();
}
inline void JSONRPCRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.method)
}

// .mcp.RequestParams params = 4;
inline bool JSONRPCRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool JSONRPCRequest::has_params() const {
  return _internal_has_params();
}
inline void JSONRPCRequest::clear_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.params_ != nullptr) {
    delete _impl_.params_;
  }
  _impl_.params_ = nullptr;
}
inline const ::mcp::RequestParams& JSONRPCRequest::_internal_params() const {
  const ::mcp::RequestParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::RequestParams&>(
      ::mcp::_RequestParams_default_instance_);
}
inline const ::mcp::RequestParams& JSONRPCRequest::params() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.params)
  return _internal_params();
}
inline void JSONRPCRequest::unsafe_arena_set_allocated_params(
    ::mcp::RequestParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCRequest.params)
}
inline ::mcp::RequestParams* JSONRPCRequest::release_params() {
  
  ::mcp::RequestParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::RequestParams* JSONRPCRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.params)
  
  ::mcp::RequestParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::mcp::RequestParams* JSONRPCRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::RequestParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::mcp::RequestParams* JSONRPCRequest::mutable_params() {
  ::mcp::RequestParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.params)
  return _msg;
}
inline void JSONRPCRequest::set_allocated_params(::mcp::RequestParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.params)
}

// -------------------------------------------------------------------

// JSONRPCNotification

// string jsonrpc = 1;
inline void JSONRPCNotification::clear_jsonrpc() {
  _impl_.jsonrpc_.ClearToEmpty();
}
inline const std::string& JSONRPCNotification::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCNotification.jsonrpc)
  return _internal_jsonrpc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCNotification::set_jsonrpc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jsonrpc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCNotification.jsonrpc)
}
inline std::string* JSONRPCNotification::mutable_jsonrpc() {
  std::string* _s = _internal_mutable_jsonrpc();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCNotification.jsonrpc)
  return _s;
}
inline const std::string& JSONRPCNotification::_internal_jsonrpc() const {
  return _impl_.jsonrpc_.Get();
}
inline void JSONRPCNotification::_internal_set_jsonrpc(const std::string& value) {
  
  _impl_.jsonrpc_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCNotification::_internal_mutable_jsonrpc() {
  
  return _impl_.jsonrpc_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCNotification::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCNotification.jsonrpc)
  return _impl_.jsonrpc_.Release();
}
inline void JSONRPCNotification::set_allocated_jsonrpc(std::string* jsonrpc) {
  if (jsonrpc != nullptr) {
    
  } else {
    
  }
  _impl_.jsonrpc_.SetAllocated(jsonrpc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jsonrpc_.IsDefault()) {
    _impl_.jsonrpc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCNotification.jsonrpc)
}

// string method = 2;
inline void JSONRPCNotification::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& JSONRPCNotification::method() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCNotification.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCNotification::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCNotification.method)
}
inline std::string* JSONRPCNotification::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCNotification.method)
  return _s;
}
inline const std::string& JSONRPCNotification::_internal_method() const {
  return _impl_.method_.Get();
}
inline void JSONRPCNotification::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCNotification::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCNotification::release_method() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCNotification.method)
  return _impl_.method_.Release();
}
inline void JSONRPCNotification::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCNotification.method)
}

// .mcp.NotificationParams params = 3;
inline bool JSONRPCNotification::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool JSONRPCNotification::has_params() const {
  return _internal_has_params();
}
inline void JSONRPCNotification::clear_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.params_ != nullptr) {
    delete _impl_.params_;
  }
  _impl_.params_ = nullptr;
}
inline const ::mcp::NotificationParams& JSONRPCNotification::_internal_params() const {
  const ::mcp::NotificationParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::NotificationParams&>(
      ::mcp::_NotificationParams_default_instance_);
}
inline const ::mcp::NotificationParams& JSONRPCNotification::params() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCNotification.params)
  return _internal_params();
}
inline void JSONRPCNotification::unsafe_arena_set_allocated_params(
    ::mcp::NotificationParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCNotification.params)
}
inline ::mcp::NotificationParams* JSONRPCNotification::release_params() {
  
  ::mcp::NotificationParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::NotificationParams* JSONRPCNotification::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCNotification.params)
  
  ::mcp::NotificationParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::mcp::NotificationParams* JSONRPCNotification::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::NotificationParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::mcp::NotificationParams* JSONRPCNotification::mutable_params() {
  ::mcp::NotificationParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCNotification.params)
  return _msg;
}
inline void JSONRPCNotification::set_allocated_params(::mcp::NotificationParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCNotification.params)
}

// -------------------------------------------------------------------

// JSONRPCResponse

// string jsonrpc = 1;
inline void JSONRPCResponse::clear_jsonrpc() {
  _impl_.jsonrpc_.ClearToEmpty();
}
inline const std::string& JSONRPCResponse::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCResponse.jsonrpc)
  return _internal_jsonrpc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCResponse::set_jsonrpc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jsonrpc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCResponse.jsonrpc)
}
inline std::string* JSONRPCResponse::mutable_jsonrpc() {
  std::string* _s = _internal_mutable_jsonrpc();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCResponse.jsonrpc)
  return _s;
}
inline const std::string& JSONRPCResponse::_internal_jsonrpc() const {
  return _impl_.jsonrpc_.Get();
}
inline void JSONRPCResponse::_internal_set_jsonrpc(const std::string& value) {
  
  _impl_.jsonrpc_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCResponse::_internal_mutable_jsonrpc() {
  
  return _impl_.jsonrpc_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCResponse::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCResponse.jsonrpc)
  return _impl_.jsonrpc_.Release();
}
inline void JSONRPCResponse::set_allocated_jsonrpc(std::string* jsonrpc) {
  if (jsonrpc != nullptr) {
    
  } else {
    
  }
  _impl_.jsonrpc_.SetAllocated(jsonrpc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jsonrpc_.IsDefault()) {
    _impl_.jsonrpc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCResponse.jsonrpc)
}

// string id = 2;
inline void JSONRPCResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& JSONRPCResponse::id() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCResponse.id)
}
inline std::string* JSONRPCResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCResponse.id)
  return _s;
}
inline const std::string& JSONRPCResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void JSONRPCResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCResponse::release_id() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCResponse.id)
  return _impl_.id_.Release();
}
inline void JSONRPCResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCResponse.id)
}

// .mcp.Result result = 3;
inline bool JSONRPCResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool JSONRPCResponse::has_result() const {
  return _internal_has_result();
}
inline void JSONRPCResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::mcp::Result& JSONRPCResponse::_internal_result() const {
  const ::mcp::Result* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Result&>(
      ::mcp::_Result_default_instance_);
}
inline const ::mcp::Result& JSONRPCResponse::result() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCResponse.result)
  return _internal_result();
}
inline void JSONRPCResponse::unsafe_arena_set_allocated_result(
    ::mcp::Result* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCResponse.result)
}
inline ::mcp::Result* JSONRPCResponse::release_result() {
  
  ::mcp::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Result* JSONRPCResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCResponse.result)
  
  ::mcp::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::mcp::Result* JSONRPCResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Result>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::mcp::Result* JSONRPCResponse::mutable_result() {
  ::mcp::Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCResponse.result)
  return _msg;
}
inline void JSONRPCResponse::set_allocated_result(::mcp::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCResponse.result)
}

// -------------------------------------------------------------------

// JSONRPCError

// string jsonrpc = 1;
inline void JSONRPCError::clear_jsonrpc() {
  _impl_.jsonrpc_.ClearToEmpty();
}
inline const std::string& JSONRPCError::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCError.jsonrpc)
  return _internal_jsonrpc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCError::set_jsonrpc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jsonrpc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCError.jsonrpc)
}
inline std::string* JSONRPCError::mutable_jsonrpc() {
  std::string* _s = _internal_mutable_jsonrpc();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCError.jsonrpc)
  return _s;
}
inline const std::string& JSONRPCError::_internal_jsonrpc() const {
  return _impl_.jsonrpc_.Get();
}
inline void JSONRPCError::_internal_set_jsonrpc(const std::string& value) {
  
  _impl_.jsonrpc_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCError::_internal_mutable_jsonrpc() {
  
  return _impl_.jsonrpc_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCError::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCError.jsonrpc)
  return _impl_.jsonrpc_.Release();
}
inline void JSONRPCError::set_allocated_jsonrpc(std::string* jsonrpc) {
  if (jsonrpc != nullptr) {
    
  } else {
    
  }
  _impl_.jsonrpc_.SetAllocated(jsonrpc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jsonrpc_.IsDefault()) {
    _impl_.jsonrpc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCError.jsonrpc)
}

// string id = 2;
inline void JSONRPCError::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& JSONRPCError::id() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCError.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JSONRPCError::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.JSONRPCError.id)
}
inline std::string* JSONRPCError::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCError.id)
  return _s;
}
inline const std::string& JSONRPCError::_internal_id() const {
  return _impl_.id_.Get();
}
inline void JSONRPCError::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONRPCError::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* JSONRPCError::release_id() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCError.id)
  return _impl_.id_.Release();
}
inline void JSONRPCError::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCError.id)
}

// .mcp.Error error = 3;
inline bool JSONRPCError::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool JSONRPCError::has_error() const {
  return _internal_has_error();
}
inline void JSONRPCError::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::mcp::Error& JSONRPCError::_internal_error() const {
  const ::mcp::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Error&>(
      ::mcp::_Error_default_instance_);
}
inline const ::mcp::Error& JSONRPCError::error() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCError.error)
  return _internal_error();
}
inline void JSONRPCError::unsafe_arena_set_allocated_error(
    ::mcp::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.JSONRPCError.error)
}
inline ::mcp::Error* JSONRPCError::release_error() {
  
  ::mcp::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Error* JSONRPCError::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCError.error)
  
  ::mcp::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::mcp::Error* JSONRPCError::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::mcp::Error* JSONRPCError::mutable_error() {
  ::mcp::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCError.error)
  return _msg;
}
inline void JSONRPCError::set_allocated_error(::mcp::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCError.error)
}

// -------------------------------------------------------------------

// JSONRPCBatchRequest

// repeated .mcp.JSONRPCRequest requests = 1;
inline int JSONRPCBatchRequest::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int JSONRPCBatchRequest::requests_size() const {
  return _internal_requests_size();
}
inline void JSONRPCBatchRequest::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::mcp::JSONRPCRequest* JSONRPCBatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCBatchRequest.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCRequest >*
JSONRPCBatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:mcp.JSONRPCBatchRequest.requests)
  return &_impl_.requests_;
}
inline const ::mcp::JSONRPCRequest& JSONRPCBatchRequest::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::mcp::JSONRPCRequest& JSONRPCBatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCBatchRequest.requests)
  return _internal_requests(index);
}
inline ::mcp::JSONRPCRequest* JSONRPCBatchRequest::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::mcp::JSONRPCRequest* JSONRPCBatchRequest::add_requests() {
  ::mcp::JSONRPCRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:mcp.JSONRPCBatchRequest.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCRequest >&
JSONRPCBatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:mcp.JSONRPCBatchRequest.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// JSONRPCBatchResponse

// repeated .mcp.JSONRPCResponse responses = 1;
inline int JSONRPCBatchResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int JSONRPCBatchResponse::responses_size() const {
  return _internal_responses_size();
}
inline void JSONRPCBatchResponse::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::mcp::JSONRPCResponse* JSONRPCBatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCBatchResponse.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCResponse >*
JSONRPCBatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:mcp.JSONRPCBatchResponse.responses)
  return &_impl_.responses_;
}
inline const ::mcp::JSONRPCResponse& JSONRPCBatchResponse::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::mcp::JSONRPCResponse& JSONRPCBatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCBatchResponse.responses)
  return _internal_responses(index);
}
inline ::mcp::JSONRPCResponse* JSONRPCBatchResponse::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::mcp::JSONRPCResponse* JSONRPCBatchResponse::add_responses() {
  ::mcp::JSONRPCResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:mcp.JSONRPCBatchResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::JSONRPCResponse >&
JSONRPCBatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:mcp.JSONRPCBatchResponse.responses)
  return _impl_.responses_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RequestParams

// .mcp.MetaParams _meta = 1;
inline bool RequestParams::_internal_has__meta() const {
  return this != internal_default_instance() && _impl_._meta_ != nullptr;
}
inline bool RequestParams::has__meta() const {
  return _internal_has__meta();
}
inline void RequestParams::clear__meta() {
  if (GetArenaForAllocation() == nullptr && _impl_._meta_ != nullptr) {
    delete _impl_._meta_;
  }
  _impl_._meta_ = nullptr;
}
inline const ::mcp::MetaParams& RequestParams::_internal__meta() const {
  const ::mcp::MetaParams* p = _impl_._meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::MetaParams&>(
      ::mcp::_MetaParams_default_instance_);
}
inline const ::mcp::MetaParams& RequestParams::_meta() const {
  // @@protoc_insertion_point(field_get:mcp.RequestParams._meta)
  return _internal__meta();
}
inline void RequestParams::unsafe_arena_set_allocated__meta(
    ::mcp::MetaParams* _meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._meta_);
  }
  _impl_._meta_ = _meta;
  if (_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RequestParams._meta)
}
inline ::mcp::MetaParams* RequestParams::release__meta() {
  
  ::mcp::MetaParams* temp = _impl_._meta_;
  _impl_._meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::MetaParams* RequestParams::unsafe_arena_release__meta() {
  // @@protoc_insertion_point(field_release:mcp.RequestParams._meta)
  
  ::mcp::MetaParams* temp = _impl_._meta_;
  _impl_._meta_ = nullptr;
  return temp;
}
inline ::mcp::MetaParams* RequestParams::_internal_mutable__meta() {
  
  if (_impl_._meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::MetaParams>(GetArenaForAllocation());
    _impl_._meta_ = p;
  }
  return _impl_._meta_;
}
inline ::mcp::MetaParams* RequestParams::mutable__meta() {
  ::mcp::MetaParams* _msg = _internal_mutable__meta();
  // @@protoc_insertion_point(field_mutable:mcp.RequestParams._meta)
  return _msg;
}
inline void RequestParams::set_allocated__meta(::mcp::MetaParams* _meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._meta_;
  }
  if (_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_meta);
    if (message_arena != submessage_arena) {
      _meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_._meta_ = _meta;
  // @@protoc_insertion_point(field_set_allocated:mcp.RequestParams._meta)
}

// map<string, bytes> additional_params = 2;
inline int RequestParams::_internal_additional_params_size() const {
  return _impl_.additional_params_.size();
}
inline int RequestParams::additional_params_size() const {
  return _internal_additional_params_size();
}
inline void RequestParams::clear_additional_params() {
  _impl_.additional_params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestParams::_internal_additional_params() const {
  return _impl_.additional_params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestParams::additional_params() const {
  // @@protoc_insertion_point(field_map:mcp.RequestParams.additional_params)
  return _internal_additional_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestParams::_internal_mutable_additional_params() {
  return _impl_.additional_params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestParams::mutable_additional_params() {
  // @@protoc_insertion_point(field_mutable_map:mcp.RequestParams.additional_params)
  return _internal_mutable_additional_params();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NotificationParams

// .mcp.MetaParams _meta = 1;
inline bool NotificationParams::_internal_has__meta() const {
  return this != internal_default_instance() && _impl_._meta_ != nullptr;
}
inline bool NotificationParams::has__meta() const {
  return _internal_has__meta();
}
inline void NotificationParams::clear__meta() {
  if (GetArenaForAllocation() == nullptr && _impl_._meta_ != nullptr) {
    delete _impl_._meta_;
  }
  _impl_._meta_ = nullptr;
}
inline const ::mcp::MetaParams& NotificationParams::_internal__meta() const {
  const ::mcp::MetaParams* p = _impl_._meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::MetaParams&>(
      ::mcp::_MetaParams_default_instance_);
}
inline const ::mcp::MetaParams& NotificationParams::_meta() const {
  // @@protoc_insertion_point(field_get:mcp.NotificationParams._meta)
  return _internal__meta();
}
inline void NotificationParams::unsafe_arena_set_allocated__meta(
    ::mcp::MetaParams* _meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._meta_);
  }
  _impl_._meta_ = _meta;
  if (_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.NotificationParams._meta)
}
inline ::mcp::MetaParams* NotificationParams::release__meta() {
  
  ::mcp::MetaParams* temp = _impl_._meta_;
  _impl_._meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::MetaParams* NotificationParams::unsafe_arena_release__meta() {
  // @@protoc_insertion_point(field_release:mcp.NotificationParams._meta)
  
  ::mcp::MetaParams* temp = _impl_._meta_;
  _impl_._meta_ = nullptr;
  return temp;
}
inline ::mcp::MetaParams* NotificationParams::_internal_mutable__meta() {
  
  if (_impl_._meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::MetaParams>(GetArenaForAllocation());
    _impl_._meta_ = p;
  }
  return _impl_._meta_;
}
inline ::mcp::MetaParams* NotificationParams::mutable__meta() {
  ::mcp::MetaParams* _msg = _internal_mutable__meta();
  // @@protoc_insertion_point(field_mutable:mcp.NotificationParams._meta)
  return _msg;
}
inline void NotificationParams::set_allocated__meta(::mcp::MetaParams* _meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._meta_;
  }
  if (_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_meta);
    if (message_arena != submessage_arena) {
      _meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_._meta_ = _meta;
  // @@protoc_insertion_point(field_set_allocated:mcp.NotificationParams._meta)
}

// map<string, bytes> additional_params = 2;
inline int NotificationParams::_internal_additional_params_size() const {
  return _impl_.additional_params_.size();
}
inline int NotificationParams::additional_params_size() const {
  return _internal_additional_params_size();
}
inline void NotificationParams::clear_additional_params() {
  _impl_.additional_params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NotificationParams::_internal_additional_params() const {
  return _impl_.additional_params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NotificationParams::additional_params() const {
  // @@protoc_insertion_point(field_map:mcp.NotificationParams.additional_params)
  return _internal_additional_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NotificationParams::_internal_mutable_additional_params() {
  return _impl_.additional_params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NotificationParams::mutable_additional_params() {
  // @@protoc_insertion_point(field_mutable_map:mcp.NotificationParams.additional_params)
  return _internal_mutable_additional_params();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaParams

// string progress_token = 1;
inline void MetaParams::clear_progress_token() {
  _impl_.progress_token_.ClearToEmpty();
}
inline const std::string& MetaParams::progress_token() const {
  // @@protoc_insertion_point(field_get:mcp.MetaParams.progress_token)
  return _internal_progress_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetaParams::set_progress_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.progress_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.MetaParams.progress_token)
}
inline std::string* MetaParams::mutable_progress_token() {
  std::string* _s = _internal_mutable_progress_token();
  // @@protoc_insertion_point(field_mutable:mcp.MetaParams.progress_token)
  return _s;
}
inline const std::string& MetaParams::_internal_progress_token() const {
  return _impl_.progress_token_.Get();
}
inline void MetaParams::_internal_set_progress_token(const std::string& value) {
  
  _impl_.progress_token_.Set(value, GetArenaForAllocation());
}
inline std::string* MetaParams::_internal_mutable_progress_token() {
  
  return _impl_.progress_token_.Mutable(GetArenaForAllocation());
}
inline std::string* MetaParams::release_progress_token() {
  // @@protoc_insertion_point(field_release:mcp.MetaParams.progress_token)
  return _impl_.progress_token_.Release();
}
inline void MetaParams::set_allocated_progress_token(std::string* progress_token) {
  if (progress_token != nullptr) {
    
  } else {
    
  }
  _impl_.progress_token_.SetAllocated(progress_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.progress_token_.IsDefault()) {
    _impl_.progress_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.MetaParams.progress_token)
}

// map<string, bytes> additional_meta = 2;
inline int MetaParams::_internal_additional_meta_size() const {
  return _impl_.additional_meta_.size();
}
inline int MetaParams::additional_meta_size() const {
  return _internal_additional_meta_size();
}
inline void MetaParams::clear_additional_meta() {
  _impl_.additional_meta_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaParams::_internal_additional_meta() const {
  return _impl_.additional_meta_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaParams::additional_meta() const {
  // @@protoc_insertion_point(field_map:mcp.MetaParams.additional_meta)
  return _internal_additional_meta();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaParams::_internal_mutable_additional_meta() {
  return _impl_.additional_meta_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaParams::mutable_additional_meta() {
  // @@protoc_insertion_point(field_mutable_map:mcp.MetaParams.additional_meta)
  return _internal_mutable_additional_meta();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Result

// .mcp.MetaResult _meta = 1;
inline bool Result::_internal_has__meta() const {
  return this != internal_default_instance() && _impl_._meta_ != nullptr;
}
inline bool Result::has__meta() const {
  return _internal_has__meta();
}
inline void Result::clear__meta() {
  if (GetArenaForAllocation() == nullptr && _impl_._meta_ != nullptr) {
    delete _impl_._meta_;
  }
  _impl_._meta_ = nullptr;
}
inline const ::mcp::MetaResult& Result::_internal__meta() const {
  const ::mcp::MetaResult* p = _impl_._meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::MetaResult&>(
      ::mcp::_MetaResult_default_instance_);
}
inline const ::mcp::MetaResult& Result::_meta() const {
  // @@protoc_insertion_point(field_get:mcp.Result._meta)
  return _internal__meta();
}
inline void Result::unsafe_arena_set_allocated__meta(
    ::mcp::MetaResult* _meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._meta_);
  }
  _impl_._meta_ = _meta;
  if (_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.Result._meta)
}
inline ::mcp::MetaResult* Result::release__meta() {
  
  ::mcp::MetaResult* temp = _impl_._meta_;
  _impl_._meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::MetaResult* Result::unsafe_arena_release__meta() {
  // @@protoc_insertion_point(field_release:mcp.Result._meta)
  
  ::mcp::MetaResult* temp = _impl_._meta_;
  _impl_._meta_ = nullptr;
  return temp;
}
inline ::mcp::MetaResult* Result::_internal_mutable__meta() {
  
  if (_impl_._meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::MetaResult>(GetArenaForAllocation());
    _impl_._meta_ = p;
  }
  return _impl_._meta_;
}
inline ::mcp::MetaResult* Result::mutable__meta() {
  ::mcp::MetaResult* _msg = _internal_mutable__meta();
  // @@protoc_insertion_point(field_mutable:mcp.Result._meta)
  return _msg;
}
inline void Result::set_allocated__meta(::mcp::MetaResult* _meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._meta_;
  }
  if (_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_meta);
    if (message_arena != submessage_arena) {
      _meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_._meta_ = _meta;
  // @@protoc_insertion_point(field_set_allocated:mcp.Result._meta)
}

// map<string, bytes> additional_result = 2;
inline int Result::_internal_additional_result_size() const {
  return _impl_.additional_result_.size();
}
inline int Result::additional_result_size() const {
  return _internal_additional_result_size();
}
inline void Result::clear_additional_result() {
  _impl_.additional_result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Result::_internal_additional_result() const {
  return _impl_.additional_result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Result::additional_result() const {
  // @@protoc_insertion_point(field_map:mcp.Result.additional_result)
  return _internal_additional_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Result::_internal_mutable_additional_result() {
  return _impl_.additional_result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Result::mutable_additional_result() {
  // @@protoc_insertion_point(field_mutable_map:mcp.Result.additional_result)
  return _internal_mutable_additional_result();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaResult

// map<string, bytes> additional_meta = 1;
inline int MetaResult::_internal_additional_meta_size() const {
  return _impl_.additional_meta_.size();
}
inline int MetaResult::additional_meta_size() const {
  return _internal_additional_meta_size();
}
inline void MetaResult::clear_additional_meta() {
  _impl_.additional_meta_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaResult::_internal_additional_meta() const {
  return _impl_.additional_meta_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaResult::additional_meta() const {
  // @@protoc_insertion_point(field_map:mcp.MetaResult.additional_meta)
  return _internal_additional_meta();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaResult::_internal_mutable_additional_meta() {
  return _impl_.additional_meta_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaResult::mutable_additional_meta() {
  // @@protoc_insertion_point(field_mutable_map:mcp.MetaResult.additional_meta)
  return _internal_mutable_additional_meta();
}

// -------------------------------------------------------------------

// Error

// int32 code = 1;
inline void Error::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t Error::_internal_code() const {
  return _impl_.code_;
}
inline int32_t Error::code() const {
  // @@protoc_insertion_point(field_get:mcp.Error.code)
  return _internal_code();
}
inline void Error::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void Error::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:mcp.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:mcp.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mcp.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:mcp.Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Error.message)
}

// bytes data = 3;
inline void Error::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Error::data() const {
  // @@protoc_insertion_point(field_get:mcp.Error.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Error.data)
}
inline std::string* Error::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mcp.Error.data)
  return _s;
}
inline const std::string& Error::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Error::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_data() {
  // @@protoc_insertion_point(field_release:mcp.Error.data)
  return _impl_.data_.Release();
}
inline void Error::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Error.data)
}

// -------------------------------------------------------------------

// Implementation

// string name = 1;
inline void Implementation::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Implementation::name() const {
  // @@protoc_insertion_point(field_get:mcp.Implementation.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Implementation::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Implementation.name)
}
inline std::string* Implementation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.Implementation.name)
  return _s;
}
inline const std::string& Implementation::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Implementation::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Implementation::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Implementation::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Implementation.name)
  return _impl_.name_.Release();
}
inline void Implementation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Implementation.name)
}

// string version = 2;
inline void Implementation::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Implementation::version() const {
  // @@protoc_insertion_point(field_get:mcp.Implementation.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Implementation::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Implementation.version)
}
inline std::string* Implementation::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:mcp.Implementation.version)
  return _s;
}
inline const std::string& Implementation::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Implementation::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Implementation::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Implementation::release_version() {
  // @@protoc_insertion_point(field_release:mcp.Implementation.version)
  return _impl_.version_.Release();
}
inline void Implementation::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Implementation.version)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ClientCapabilities

// map<string, bytes> experimental = 1;
inline int ClientCapabilities::_internal_experimental_size() const {
  return _impl_.experimental_.size();
}
inline int ClientCapabilities::experimental_size() const {
  return _internal_experimental_size();
}
inline void ClientCapabilities::clear_experimental() {
  _impl_.experimental_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ClientCapabilities::_internal_experimental() const {
  return _impl_.experimental_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ClientCapabilities::experimental() const {
  // @@protoc_insertion_point(field_map:mcp.ClientCapabilities.experimental)
  return _internal_experimental();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ClientCapabilities::_internal_mutable_experimental() {
  return _impl_.experimental_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ClientCapabilities::mutable_experimental() {
  // @@protoc_insertion_point(field_mutable_map:mcp.ClientCapabilities.experimental)
  return _internal_mutable_experimental();
}

// .mcp.RootsCapability roots = 2;
inline bool ClientCapabilities::_internal_has_roots() const {
  return this != internal_default_instance() && _impl_.roots_ != nullptr;
}
inline bool ClientCapabilities::has_roots() const {
  return _internal_has_roots();
}
inline void ClientCapabilities::clear_roots() {
  if (GetArenaForAllocation() == nullptr && _impl_.roots_ != nullptr) {
    delete _impl_.roots_;
  }
  _impl_.roots_ = nullptr;
}
inline const ::mcp::RootsCapability& ClientCapabilities::_internal_roots() const {
  const ::mcp::RootsCapability* p = _impl_.roots_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::RootsCapability&>(
      ::mcp::_RootsCapability_default_instance_);
}
inline const ::mcp::RootsCapability& ClientCapabilities::roots() const {
  // @@protoc_insertion_point(field_get:mcp.ClientCapabilities.roots)
  return _internal_roots();
}
inline void ClientCapabilities::unsafe_arena_set_allocated_roots(
    ::mcp::RootsCapability* roots) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roots_);
  }
  _impl_.roots_ = roots;
  if (roots) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ClientCapabilities.roots)
}
inline ::mcp::RootsCapability* ClientCapabilities::release_roots() {
  
  ::mcp::RootsCapability* temp = _impl_.roots_;
  _impl_.roots_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::RootsCapability* ClientCapabilities::unsafe_arena_release_roots() {
  // @@protoc_insertion_point(field_release:mcp.ClientCapabilities.roots)
  
  ::mcp::RootsCapability* temp = _impl_.roots_;
  _impl_.roots_ = nullptr;
  return temp;
}
inline ::mcp::RootsCapability* ClientCapabilities::_internal_mutable_roots() {
  
  if (_impl_.roots_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::RootsCapability>(GetArenaForAllocation());
    _impl_.roots_ = p;
  }
  return _impl_.roots_;
}
inline ::mcp::RootsCapability* ClientCapabilities::mutable_roots() {
  ::mcp::RootsCapability* _msg = _internal_mutable_roots();
  // @@protoc_insertion_point(field_mutable:mcp.ClientCapabilities.roots)
  return _msg;
}
inline void ClientCapabilities::set_allocated_roots(::mcp::RootsCapability* roots) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.roots_;
  }
  if (roots) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(roots);
    if (message_arena != submessage_arena) {
      roots = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roots, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.roots_ = roots;
  // @@protoc_insertion_point(field_set_allocated:mcp.ClientCapabilities.roots)
}

// .mcp.SamplingCapability sampling = 3;
inline bool ClientCapabilities::_internal_has_sampling() const {
  return this != internal_default_instance() && _impl_.sampling_ != nullptr;
}
inline bool ClientCapabilities::has_sampling() const {
  return _internal_has_sampling();
}
inline void ClientCapabilities::clear_sampling() {
  if (GetArenaForAllocation() == nullptr && _impl_.sampling_ != nullptr) {
    delete _impl_.sampling_;
  }
  _impl_.sampling_ = nullptr;
}
inline const ::mcp::SamplingCapability& ClientCapabilities::_internal_sampling() const {
  const ::mcp::SamplingCapability* p = _impl_.sampling_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::SamplingCapability&>(
      ::mcp::_SamplingCapability_default_instance_);
}
inline const ::mcp::SamplingCapability& ClientCapabilities::sampling() const {
  // @@protoc_insertion_point(field_get:mcp.ClientCapabilities.sampling)
  return _internal_sampling();
}
inline void ClientCapabilities::unsafe_arena_set_allocated_sampling(
    ::mcp::SamplingCapability* sampling) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sampling_);
  }
  _impl_.sampling_ = sampling;
  if (sampling) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ClientCapabilities.sampling)
}
inline ::mcp::SamplingCapability* ClientCapabilities::release_sampling() {
  
  ::mcp::SamplingCapability* temp = _impl_.sampling_;
  _impl_.sampling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::SamplingCapability* ClientCapabilities::unsafe_arena_release_sampling() {
  // @@protoc_insertion_point(field_release:mcp.ClientCapabilities.sampling)
  
  ::mcp::SamplingCapability* temp = _impl_.sampling_;
  _impl_.sampling_ = nullptr;
  return temp;
}
inline ::mcp::SamplingCapability* ClientCapabilities::_internal_mutable_sampling() {
  
  if (_impl_.sampling_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::SamplingCapability>(GetArenaForAllocation());
    _impl_.sampling_ = p;
  }
  return _impl_.sampling_;
}
inline ::mcp::SamplingCapability* ClientCapabilities::mutable_sampling() {
  ::mcp::SamplingCapability* _msg = _internal_mutable_sampling();
  // @@protoc_insertion_point(field_mutable:mcp.ClientCapabilities.sampling)
  return _msg;
}
inline void ClientCapabilities::set_allocated_sampling(::mcp::SamplingCapability* sampling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sampling_;
  }
  if (sampling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sampling);
    if (message_arena != submessage_arena) {
      sampling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sampling, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sampling_ = sampling;
  // @@protoc_insertion_point(field_set_allocated:mcp.ClientCapabilities.sampling)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServerCapabilities

// map<string, bytes> experimental = 1;
inline int ServerCapabilities::_internal_experimental_size() const {
  return _impl_.experimental_.size();
}
inline int ServerCapabilities::experimental_size() const {
  return _internal_experimental_size();
}
inline void ServerCapabilities::clear_experimental() {
  _impl_.experimental_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ServerCapabilities::_internal_experimental() const {
  return _impl_.experimental_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ServerCapabilities::experimental() const {
  // @@protoc_insertion_point(field_map:mcp.ServerCapabilities.experimental)
  return _internal_experimental();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ServerCapabilities::_internal_mutable_experimental() {
  return _impl_.experimental_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ServerCapabilities::mutable_experimental() {
  // @@protoc_insertion_point(field_mutable_map:mcp.ServerCapabilities.experimental)
  return _internal_mutable_experimental();
}

// .mcp.LoggingCapability logging = 2;
inline bool ServerCapabilities::_internal_has_logging() const {
  return this != internal_default_instance() && _impl_.logging_ != nullptr;
}
inline bool ServerCapabilities::has_logging() const {
  return _internal_has_logging();
}
inline void ServerCapabilities::clear_logging() {
  if (GetArenaForAllocation() == nullptr && _impl_.logging_ != nullptr) {
    delete _impl_.logging_;
  }
  _impl_.logging_ = nullptr;
}
inline const ::mcp::LoggingCapability& ServerCapabilities::_internal_logging() const {
  const ::mcp::LoggingCapability* p = _impl_.logging_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::LoggingCapability&>(
      ::mcp::_LoggingCapability_default_instance_);
}
inline const ::mcp::LoggingCapability& ServerCapabilities::logging() const {
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.logging)
  return _internal_logging();
}
inline void ServerCapabilities::unsafe_arena_set_allocated_logging(
    ::mcp::LoggingCapability* logging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logging_);
  }
  _impl_.logging_ = logging;
  if (logging) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ServerCapabilities.logging)
}
inline ::mcp::LoggingCapability* ServerCapabilities::release_logging() {
  
  ::mcp::LoggingCapability* temp = _impl_.logging_;
  _impl_.logging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::LoggingCapability* ServerCapabilities::unsafe_arena_release_logging() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.logging)
  
  ::mcp::LoggingCapability* temp = _impl_.logging_;
  _impl_.logging_ = nullptr;
  return temp;
}
inline ::mcp::LoggingCapability* ServerCapabilities::_internal_mutable_logging() {
  
  if (_impl_.logging_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::LoggingCapability>(GetArenaForAllocation());
    _impl_.logging_ = p;
  }
  return _impl_.logging_;
}
inline ::mcp::LoggingCapability* ServerCapabilities::mutable_logging() {
  ::mcp::LoggingCapability* _msg = _internal_mutable_logging();
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.logging)
  return _msg;
}
inline void ServerCapabilities::set_allocated_logging(::mcp::LoggingCapability* logging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logging_;
  }
  if (logging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logging);
    if (message_arena != submessage_arena) {
      logging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logging, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.logging_ = logging;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.logging)
}

// .mcp.CompletionsCapability completions = 3;
inline bool ServerCapabilities::_internal_has_completions() const {
  return this != internal_default_instance() && _impl_.completions_ != nullptr;
}
inline bool ServerCapabilities::has_completions() const {
  return _internal_has_completions();
}
inline void ServerCapabilities::clear_completions() {
  if (GetArenaForAllocation() == nullptr && _impl_.completions_ != nullptr) {
    delete _impl_.completions_;
  }
  _impl_.completions_ = nullptr;
}
inline const ::mcp::CompletionsCapability& ServerCapabilities::_internal_completions() const {
  const ::mcp::CompletionsCapability* p = _impl_.completions_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::CompletionsCapability&>(
      ::mcp::_CompletionsCapability_default_instance_);
}
inline const ::mcp::CompletionsCapability& ServerCapabilities::completions() const {
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.completions)
  return _internal_completions();
}
inline void ServerCapabilities::unsafe_arena_set_allocated_completions(
    ::mcp::CompletionsCapability* completions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completions_);
  }
  _impl_.completions_ = completions;
  if (completions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ServerCapabilities.completions)
}
inline ::mcp::CompletionsCapability* ServerCapabilities::release_completions() {
  
  ::mcp::CompletionsCapability* temp = _impl_.completions_;
  _impl_.completions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::CompletionsCapability* ServerCapabilities::unsafe_arena_release_completions() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.completions)
  
  ::mcp::CompletionsCapability* temp = _impl_.completions_;
  _impl_.completions_ = nullptr;
  return temp;
}
inline ::mcp::CompletionsCapability* ServerCapabilities::_internal_mutable_completions() {
  
  if (_impl_.completions_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::CompletionsCapability>(GetArenaForAllocation());
    _impl_.completions_ = p;
  }
  return _impl_.completions_;
}
inline ::mcp::CompletionsCapability* ServerCapabilities::mutable_completions() {
  ::mcp::CompletionsCapability* _msg = _internal_mutable_completions();
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.completions)
  return _msg;
}
inline void ServerCapabilities::set_allocated_completions(::mcp::CompletionsCapability* completions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.completions_;
  }
  if (completions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(completions);
    if (message_arena != submessage_arena) {
      completions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, completions, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.completions_ = completions;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.completions)
}

// .mcp.PromptsCapability prompts = 4;
inline bool ServerCapabilities::_internal_has_prompts() const {
  return this != internal_default_instance() && _impl_.prompts_ != nullptr;
}
inline bool ServerCapabilities::has_prompts() const {
  return _internal_has_prompts();
}
inline void ServerCapabilities::clear_prompts() {
  if (GetArenaForAllocation() == nullptr && _impl_.prompts_ != nullptr) {
    delete _impl_.prompts_;
  }
  _impl_.prompts_ = nullptr;
}
inline const ::mcp::PromptsCapability& ServerCapabilities::_internal_prompts() const {
  const ::mcp::PromptsCapability* p = _impl_.prompts_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::PromptsCapability&>(
      ::mcp::_PromptsCapability_default_instance_);
}
inline const ::mcp::PromptsCapability& ServerCapabilities::prompts() const {
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.prompts)
  return _internal_prompts();
}
inline void ServerCapabilities::unsafe_arena_set_allocated_prompts(
    ::mcp::PromptsCapability* prompts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompts_);
  }
  _impl_.prompts_ = prompts;
  if (prompts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ServerCapabilities.prompts)
}
inline ::mcp::PromptsCapability* ServerCapabilities::release_prompts() {
  
  ::mcp::PromptsCapability* temp = _impl_.prompts_;
  _impl_.prompts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::PromptsCapability* ServerCapabilities::unsafe_arena_release_prompts() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.prompts)
  
  ::mcp::PromptsCapability* temp = _impl_.prompts_;
  _impl_.prompts_ = nullptr;
  return temp;
}
inline ::mcp::PromptsCapability* ServerCapabilities::_internal_mutable_prompts() {
  
  if (_impl_.prompts_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::PromptsCapability>(GetArenaForAllocation());
    _impl_.prompts_ = p;
  }
  return _impl_.prompts_;
}
inline ::mcp::PromptsCapability* ServerCapabilities::mutable_prompts() {
  ::mcp::PromptsCapability* _msg = _internal_mutable_prompts();
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.prompts)
  return _msg;
}
inline void ServerCapabilities::set_allocated_prompts(::mcp::PromptsCapability* prompts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prompts_;
  }
  if (prompts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prompts);
    if (message_arena != submessage_arena) {
      prompts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prompts_ = prompts;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.prompts)
}

// .mcp.ResourcesCapability resources = 5;
inline bool ServerCapabilities::_internal_has_resources() const {
  return this != internal_default_instance() && _impl_.resources_ != nullptr;
}
inline bool ServerCapabilities::has_resources() const {
  return _internal_has_resources();
}
inline void ServerCapabilities::clear_resources() {
  if (GetArenaForAllocation() == nullptr && _impl_.resources_ != nullptr) {
    delete _impl_.resources_;
  }
  _impl_.resources_ = nullptr;
}
inline const ::mcp::ResourcesCapability& ServerCapabilities::_internal_resources() const {
  const ::mcp::ResourcesCapability* p = _impl_.resources_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ResourcesCapability&>(
      ::mcp::_ResourcesCapability_default_instance_);
}
inline const ::mcp::ResourcesCapability& ServerCapabilities::resources() const {
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.resources)
  return _internal_resources();
}
inline void ServerCapabilities::unsafe_arena_set_allocated_resources(
    ::mcp::ResourcesCapability* resources) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resources_);
  }
  _impl_.resources_ = resources;
  if (resources) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ServerCapabilities.resources)
}
inline ::mcp::ResourcesCapability* ServerCapabilities::release_resources() {
  
  ::mcp::ResourcesCapability* temp = _impl_.resources_;
  _impl_.resources_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ResourcesCapability* ServerCapabilities::unsafe_arena_release_resources() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.resources)
  
  ::mcp::ResourcesCapability* temp = _impl_.resources_;
  _impl_.resources_ = nullptr;
  return temp;
}
inline ::mcp::ResourcesCapability* ServerCapabilities::_internal_mutable_resources() {
  
  if (_impl_.resources_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ResourcesCapability>(GetArenaForAllocation());
    _impl_.resources_ = p;
  }
  return _impl_.resources_;
}
inline ::mcp::ResourcesCapability* ServerCapabilities::mutable_resources() {
  ::mcp::ResourcesCapability* _msg = _internal_mutable_resources();
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.resources)
  return _msg;
}
inline void ServerCapabilities::set_allocated_resources(::mcp::ResourcesCapability* resources) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resources_;
  }
  if (resources) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resources);
    if (message_arena != submessage_arena) {
      resources = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.resources)
}

// .mcp.ToolsCapability tools = 6;
inline bool ServerCapabilities::_internal_has_tools() const {
  return this != internal_default_instance() && _impl_.tools_ != nullptr;
}
inline bool ServerCapabilities::has_tools() const {
  return _internal_has_tools();
}
inline void ServerCapabilities::clear_tools() {
  if (GetArenaForAllocation() == nullptr && _impl_.tools_ != nullptr) {
    delete _impl_.tools_;
  }
  _impl_.tools_ = nullptr;
}
inline const ::mcp::ToolsCapability& ServerCapabilities::_internal_tools() const {
  const ::mcp::ToolsCapability* p = _impl_.tools_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ToolsCapability&>(
      ::mcp::_ToolsCapability_default_instance_);
}
inline const ::mcp::ToolsCapability& ServerCapabilities::tools() const {
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.tools)
  return _internal_tools();
}
inline void ServerCapabilities::unsafe_arena_set_allocated_tools(
    ::mcp::ToolsCapability* tools) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tools_);
  }
  _impl_.tools_ = tools;
  if (tools) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ServerCapabilities.tools)
}
inline ::mcp::ToolsCapability* ServerCapabilities::release_tools() {
  
  ::mcp::ToolsCapability* temp = _impl_.tools_;
  _impl_.tools_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ToolsCapability* ServerCapabilities::unsafe_arena_release_tools() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.tools)
  
  ::mcp::ToolsCapability* temp = _impl_.tools_;
  _impl_.tools_ = nullptr;
  return temp;
}
inline ::mcp::ToolsCapability* ServerCapabilities::_internal_mutable_tools() {
  
  if (_impl_.tools_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ToolsCapability>(GetArenaForAllocation());
    _impl_.tools_ = p;
  }
  return _impl_.tools_;
}
inline ::mcp::ToolsCapability* ServerCapabilities::mutable_tools() {
  ::mcp::ToolsCapability* _msg = _internal_mutable_tools();
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.tools)
  return _msg;
}
inline void ServerCapabilities::set_allocated_tools(::mcp::ToolsCapability* tools) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tools_;
  }
  if (tools) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tools);
    if (message_arena != submessage_arena) {
      tools = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tools, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tools_ = tools;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.tools)
}

// -------------------------------------------------------------------

// RootsCapability

// bool list_changed = 1;
inline void RootsCapability::clear_list_changed() {
  _impl_.list_changed_ = false;
}
inline bool RootsCapability::_internal_list_changed() const {
  return _impl_.list_changed_;
}
inline bool RootsCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.RootsCapability.list_changed)
  return _internal_list_changed();
}
inline void RootsCapability::_internal_set_list_changed(bool value) {
  
  _impl_.list_changed_ = value;
}
inline void RootsCapability::set_list_changed(bool value) {
  _internal_set_list_changed(value);
  // @@protoc_insertion_point(field_set:mcp.RootsCapability.list_changed)
}

// -------------------------------------------------------------------

// SamplingCapability

// -------------------------------------------------------------------

// LoggingCapability

// -------------------------------------------------------------------

// CompletionsCapability

// -------------------------------------------------------------------

// PromptsCapability

// bool list_changed = 1;
inline void PromptsCapability::clear_list_changed() {
  _impl_.list_changed_ = false;
}
inline bool PromptsCapability::_internal_list_changed() const {
  return _impl_.list_changed_;
}
inline bool PromptsCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.PromptsCapability.list_changed)
  return _internal_list_changed();
}
inline void PromptsCapability::_internal_set_list_changed(bool value) {
  
  _impl_.list_changed_ = value;
}
inline void PromptsCapability::set_list_changed(bool value) {
  _internal_set_list_changed(value);
  // @@protoc_insertion_point(field_set:mcp.PromptsCapability.list_changed)
}

// -------------------------------------------------------------------

// ResourcesCapability

// bool subscribe = 1;
inline void ResourcesCapability::clear_subscribe() {
  _impl_.subscribe_ = false;
}
inline bool ResourcesCapability::_internal_subscribe() const {
  return _impl_.subscribe_;
}
inline bool ResourcesCapability::subscribe() const {
  // @@protoc_insertion_point(field_get:mcp.ResourcesCapability.subscribe)
  return _internal_subscribe();
}
inline void ResourcesCapability::_internal_set_subscribe(bool value) {
  
  _impl_.subscribe_ = value;
}
inline void ResourcesCapability::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  // @@protoc_insertion_point(field_set:mcp.ResourcesCapability.subscribe)
}

// bool list_changed = 2;
inline void ResourcesCapability::clear_list_changed() {
  _impl_.list_changed_ = false;
}
inline bool ResourcesCapability::_internal_list_changed() const {
  return _impl_.list_changed_;
}
inline bool ResourcesCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.ResourcesCapability.list_changed)
  return _internal_list_changed();
}
inline void ResourcesCapability::_internal_set_list_changed(bool value) {
  
  _impl_.list_changed_ = value;
}
inline void ResourcesCapability::set_list_changed(bool value) {
  _internal_set_list_changed(value);
  // @@protoc_insertion_point(field_set:mcp.ResourcesCapability.list_changed)
}

// -------------------------------------------------------------------

// ToolsCapability

// bool list_changed = 1;
inline void ToolsCapability::clear_list_changed() {
  _impl_.list_changed_ = false;
}
inline bool ToolsCapability::_internal_list_changed() const {
  return _impl_.list_changed_;
}
inline bool ToolsCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.ToolsCapability.list_changed)
  return _internal_list_changed();
}
inline void ToolsCapability::_internal_set_list_changed(bool value) {
  
  _impl_.list_changed_ = value;
}
inline void ToolsCapability::set_list_changed(bool value) {
  _internal_set_list_changed(value);
  // @@protoc_insertion_point(field_set:mcp.ToolsCapability.list_changed)
}

// -------------------------------------------------------------------

// Resource

// string uri = 1;
inline void Resource::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Resource::uri() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Resource.uri)
}
inline std::string* Resource::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mcp.Resource.uri)
  return _s;
}
inline const std::string& Resource::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Resource::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.Resource.uri)
  return _impl_.uri_.Release();
}
inline void Resource::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.uri)
}

// string name = 2;
inline void Resource::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Resource.name)
}
inline std::string* Resource::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.Resource.name)
  return _s;
}
inline const std::string& Resource::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Resource::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Resource.name)
  return _impl_.name_.Release();
}
inline void Resource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.name)
}

// string description = 3;
inline void Resource::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Resource::description() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Resource.description)
}
inline std::string* Resource::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mcp.Resource.description)
  return _s;
}
inline const std::string& Resource::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Resource::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_description() {
  // @@protoc_insertion_point(field_release:mcp.Resource.description)
  return _impl_.description_.Release();
}
inline void Resource::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.description)
}

// string mime_type = 4;
inline void Resource::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& Resource::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Resource.mime_type)
}
inline std::string* Resource::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:mcp.Resource.mime_type)
  return _s;
}
inline const std::string& Resource::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void Resource::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.Resource.mime_type)
  return _impl_.mime_type_.Release();
}
inline void Resource::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.mime_type)
}

// .mcp.Annotations annotations = 5;
inline bool Resource::_internal_has_annotations() const {
  return this != internal_default_instance() && _impl_.annotations_ != nullptr;
}
inline bool Resource::has_annotations() const {
  return _internal_has_annotations();
}
inline void Resource::clear_annotations() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotations_ != nullptr) {
    delete _impl_.annotations_;
  }
  _impl_.annotations_ = nullptr;
}
inline const ::mcp::Annotations& Resource::_internal_annotations() const {
  const ::mcp::Annotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Annotations&>(
      ::mcp::_Annotations_default_instance_);
}
inline const ::mcp::Annotations& Resource::annotations() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.annotations)
  return _internal_annotations();
}
inline void Resource::unsafe_arena_set_allocated_annotations(
    ::mcp::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.Resource.annotations)
}
inline ::mcp::Annotations* Resource::release_annotations() {
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Annotations* Resource::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.Resource.annotations)
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::mcp::Annotations* Resource::_internal_mutable_annotations() {
  
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::mcp::Annotations* Resource::mutable_annotations() {
  ::mcp::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:mcp.Resource.annotations)
  return _msg;
}
inline void Resource::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotations_;
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotations);
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.annotations)
}

// int64 size = 6;
inline void Resource::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t Resource::_internal_size() const {
  return _impl_.size_;
}
inline int64_t Resource::size() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.size)
  return _internal_size();
}
inline void Resource::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void Resource::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:mcp.Resource.size)
}

// -------------------------------------------------------------------

// ResourceTemplate

// string uri_template = 1;
inline void ResourceTemplate::clear_uri_template() {
  _impl_.uri_template_.ClearToEmpty();
}
inline const std::string& ResourceTemplate::uri_template() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.uri_template)
  return _internal_uri_template();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceTemplate::set_uri_template(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_template_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.uri_template)
}
inline std::string* ResourceTemplate::mutable_uri_template() {
  std::string* _s = _internal_mutable_uri_template();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.uri_template)
  return _s;
}
inline const std::string& ResourceTemplate::_internal_uri_template() const {
  return _impl_.uri_template_.Get();
}
inline void ResourceTemplate::_internal_set_uri_template(const std::string& value) {
  
  _impl_.uri_template_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceTemplate::_internal_mutable_uri_template() {
  
  return _impl_.uri_template_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceTemplate::release_uri_template() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.uri_template)
  return _impl_.uri_template_.Release();
}
inline void ResourceTemplate::set_allocated_uri_template(std::string* uri_template) {
  if (uri_template != nullptr) {
    
  } else {
    
  }
  _impl_.uri_template_.SetAllocated(uri_template, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_template_.IsDefault()) {
    _impl_.uri_template_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.uri_template)
}

// string name = 2;
inline void ResourceTemplate::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ResourceTemplate::name() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceTemplate::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.name)
}
inline std::string* ResourceTemplate::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.name)
  return _s;
}
inline const std::string& ResourceTemplate::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ResourceTemplate::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceTemplate::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceTemplate::release_name() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.name)
  return _impl_.name_.Release();
}
inline void ResourceTemplate::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.name)
}

// string description = 3;
inline void ResourceTemplate::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ResourceTemplate::description() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceTemplate::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.description)
}
inline std::string* ResourceTemplate::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.description)
  return _s;
}
inline const std::string& ResourceTemplate::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ResourceTemplate::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceTemplate::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceTemplate::release_description() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.description)
  return _impl_.description_.Release();
}
inline void ResourceTemplate::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.description)
}

// string mime_type = 4;
inline void ResourceTemplate::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& ResourceTemplate::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceTemplate::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.mime_type)
}
inline std::string* ResourceTemplate::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.mime_type)
  return _s;
}
inline const std::string& ResourceTemplate::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void ResourceTemplate::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceTemplate::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceTemplate::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.mime_type)
  return _impl_.mime_type_.Release();
}
inline void ResourceTemplate::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.mime_type)
}

// .mcp.Annotations annotations = 5;
inline bool ResourceTemplate::_internal_has_annotations() const {
  return this != internal_default_instance() && _impl_.annotations_ != nullptr;
}
inline bool ResourceTemplate::has_annotations() const {
  return _internal_has_annotations();
}
inline void ResourceTemplate::clear_annotations() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotations_ != nullptr) {
    delete _impl_.annotations_;
  }
  _impl_.annotations_ = nullptr;
}
inline const ::mcp::Annotations& ResourceTemplate::_internal_annotations() const {
  const ::mcp::Annotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Annotations&>(
      ::mcp::_Annotations_default_instance_);
}
inline const ::mcp::Annotations& ResourceTemplate::annotations() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.annotations)
  return _internal_annotations();
}
inline void ResourceTemplate::unsafe_arena_set_allocated_annotations(
    ::mcp::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ResourceTemplate.annotations)
}
inline ::mcp::Annotations* ResourceTemplate::release_annotations() {
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Annotations* ResourceTemplate::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.annotations)
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::mcp::Annotations* ResourceTemplate::_internal_mutable_annotations() {
  
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::mcp::Annotations* ResourceTemplate::mutable_annotations() {
  ::mcp::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.annotations)
  return _msg;
}
inline void ResourceTemplate::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotations_;
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotations);
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.annotations)
}

// -------------------------------------------------------------------

// ResourceContents

// string uri = 1;
inline void ResourceContents::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& ResourceContents::uri() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceContents::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceContents.uri)
}
inline std::string* ResourceContents::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.uri)
  return _s;
}
inline const std::string& ResourceContents::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void ResourceContents::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceContents::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceContents::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.uri)
  return _impl_.uri_.Release();
}
inline void ResourceContents::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceContents.uri)
}

// string mime_type = 2;
inline void ResourceContents::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& ResourceContents::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceContents::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceContents.mime_type)
}
inline std::string* ResourceContents::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.mime_type)
  return _s;
}
inline const std::string& ResourceContents::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void ResourceContents::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceContents::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceContents::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.mime_type)
  return _impl_.mime_type_.Release();
}
inline void ResourceContents::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceContents.mime_type)
}

// .mcp.TextResourceContents text = 3;
inline bool ResourceContents::_internal_has_text() const {
  return content_case() == kText;
}
inline bool ResourceContents::has_text() const {
  return _internal_has_text();
}
inline void ResourceContents::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void ResourceContents::clear_text() {
  if (_internal_has_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_.text_;
    }
    clear_has_content();
  }
}
inline ::mcp::TextResourceContents* ResourceContents::release_text() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.text)
  if (_internal_has_text()) {
    clear_has_content();
    ::mcp::TextResourceContents* temp = _impl_.content_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::TextResourceContents& ResourceContents::_internal_text() const {
  return _internal_has_text()
      ? *_impl_.content_.text_
      : reinterpret_cast< ::mcp::TextResourceContents&>(::mcp::_TextResourceContents_default_instance_);
}
inline const ::mcp::TextResourceContents& ResourceContents::text() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.text)
  return _internal_text();
}
inline ::mcp::TextResourceContents* ResourceContents::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.ResourceContents.text)
  if (_internal_has_text()) {
    clear_has_content();
    ::mcp::TextResourceContents* temp = _impl_.content_.text_;
    _impl_.content_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResourceContents::unsafe_arena_set_allocated_text(::mcp::TextResourceContents* text) {
  clear_content();
  if (text) {
    set_has_text();
    _impl_.content_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ResourceContents.text)
}
inline ::mcp::TextResourceContents* ResourceContents::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_content();
    set_has_text();
    _impl_.content_.text_ = CreateMaybeMessage< ::mcp::TextResourceContents >(GetArenaForAllocation());
  }
  return _impl_.content_.text_;
}
inline ::mcp::TextResourceContents* ResourceContents::mutable_text() {
  ::mcp::TextResourceContents* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.text)
  return _msg;
}

// .mcp.BlobResourceContents blob = 4;
inline bool ResourceContents::_internal_has_blob() const {
  return content_case() == kBlob;
}
inline bool ResourceContents::has_blob() const {
  return _internal_has_blob();
}
inline void ResourceContents::set_has_blob() {
  _impl_._oneof_case_[0] = kBlob;
}
inline void ResourceContents::clear_blob() {
  if (_internal_has_blob()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_.blob_;
    }
    clear_has_content();
  }
}
inline ::mcp::BlobResourceContents* ResourceContents::release_blob() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.blob)
  if (_internal_has_blob()) {
    clear_has_content();
    ::mcp::BlobResourceContents* temp = _impl_.content_.blob_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcp::BlobResourceContents& ResourceContents::_internal_blob() const {
  return _internal_has_blob()
      ? *_impl_.content_.blob_
      : reinterpret_cast< ::mcp::BlobResourceContents&>(::mcp::_BlobResourceContents_default_instance_);
}
inline const ::mcp::BlobResourceContents& ResourceContents::blob() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.blob)
  return _internal_blob();
}
inline ::mcp::BlobResourceContents* ResourceContents::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcp.ResourceContents.blob)
  if (_internal_has_blob()) {
    clear_has_content();
    ::mcp::BlobResourceContents* temp = _impl_.content_.blob_;
    _impl_.content_.blob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResourceContents::unsafe_arena_set_allocated_blob(::mcp::BlobResourceContents* blob) {
  clear_content();
  if (blob) {
    set_has_blob();
    _impl_.content_.blob_ = blob;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ResourceContents.blob)
}
inline ::mcp::BlobResourceContents* ResourceContents::_internal_mutable_blob() {
  if (!_internal_has_blob()) {
    clear_content();
    set_has_blob();
    _impl_.content_.blob_ = CreateMaybeMessage< ::mcp::BlobResourceContents >(GetArenaForAllocation());
  }
  return _impl_.content_.blob_;
}
inline ::mcp::BlobResourceContents* ResourceContents::mutable_blob() {
  ::mcp::BlobResourceContents* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.blob)
  return _msg;
}

inline bool ResourceContents::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void ResourceContents::clear_has_content() {
  _impl_._oneof_case_[0] = CONTENT_NOT_SET;
}
inline ResourceContents::ContentCase ResourceContents::content_case() const {
  return ResourceContents::ContentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextResourceContents

// string text = 1;
inline void TextResourceContents::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextResourceContents::text() const {
  // @@protoc_insertion_point(field_get:mcp.TextResourceContents.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextResourceContents::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.TextResourceContents.text)
}
inline std::string* TextResourceContents::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mcp.TextResourceContents.text)
  return _s;
}
inline const std::string& TextResourceContents::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextResourceContents::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextResourceContents::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextResourceContents::release_text() {
  // @@protoc_insertion_point(field_release:mcp.TextResourceContents.text)
  return _impl_.text_.Release();
}
inline void TextResourceContents::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.TextResourceContents.text)
}

// -------------------------------------------------------------------

// BlobResourceContents

// bytes blob = 1;
inline void BlobResourceContents::clear_blob() {
  _impl_.blob_.ClearToEmpty();
}
inline const std::string& BlobResourceContents::blob() const {
  // @@protoc_insertion_point(field_get:mcp.BlobResourceContents.blob)
  return _internal_blob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlobResourceContents::set_blob(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blob_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.BlobResourceContents.blob)
}
inline std::string* BlobResourceContents::mutable_blob() {
  std::string* _s = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:mcp.BlobResourceContents.blob)
  return _s;
}
inline const std::string& BlobResourceContents::_internal_blob() const {
  return _impl_.blob_.Get();
}
inline void BlobResourceContents::_internal_set_blob(const std::string& value) {
  
  _impl_.blob_.Set(value, GetArenaForAllocation());
}
inline std::string* BlobResourceContents::_internal_mutable_blob() {
  
  return _impl_.blob_.Mutable(GetArenaForAllocation());
}
inline std::string* BlobResourceContents::release_blob() {
  // @@protoc_insertion_point(field_release:mcp.BlobResourceContents.blob)
  return _impl_.blob_.Release();
}
inline void BlobResourceContents::set_allocated_blob(std::string* blob) {
  if (blob != nullptr) {
    
  } else {
    
  }
  _impl_.blob_.SetAllocated(blob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blob_.IsDefault()) {
    _impl_.blob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.BlobResourceContents.blob)
}

// -------------------------------------------------------------------

// Tool

// string name = 1;
inline void Tool::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Tool::name() const {
  // @@protoc_insertion_point(field_get:mcp.Tool.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tool::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Tool.name)
}
inline std::string* Tool::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.Tool.name)
  return _s;
}
inline const std::string& Tool::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Tool::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Tool::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Tool::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Tool.name)
  return _impl_.name_.Release();
}
inline void Tool::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.name)
}

// string description = 2;
inline void Tool::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Tool::description() const {
  // @@protoc_insertion_point(field_get:mcp.Tool.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tool::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Tool.description)
}
inline std::string* Tool::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mcp.Tool.description)
  return _s;
}
inline const std::string& Tool::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Tool::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Tool::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Tool::release_description() {
  // @@protoc_insertion_point(field_release:mcp.Tool.description)
  return _impl_.description_.Release();
}
inline void Tool::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.description)
}

// .mcp.InputSchema input_schema = 3;
inline bool Tool::_internal_has_input_schema() const {
  return this != internal_default_instance() && _impl_.input_schema_ != nullptr;
}
inline bool Tool::has_input_schema() const {
  return _internal_has_input_schema();
}
inline void Tool::clear_input_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_schema_ != nullptr) {
    delete _impl_.input_schema_;
  }
  _impl_.input_schema_ = nullptr;
}
inline const ::mcp::InputSchema& Tool::_internal_input_schema() const {
  const ::mcp::InputSchema* p = _impl_.input_schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::InputSchema&>(
      ::mcp::_InputSchema_default_instance_);
}
inline const ::mcp::InputSchema& Tool::input_schema() const {
  // @@protoc_insertion_point(field_get:mcp.Tool.input_schema)
  return _internal_input_schema();
}
inline void Tool::unsafe_arena_set_allocated_input_schema(
    ::mcp::InputSchema* input_schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_schema_);
  }
  _impl_.input_schema_ = input_schema;
  if (input_schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.Tool.input_schema)
}
inline ::mcp::InputSchema* Tool::release_input_schema() {
  
  ::mcp::InputSchema* temp = _impl_.input_schema_;
  _impl_.input_schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::InputSchema* Tool::unsafe_arena_release_input_schema() {
  // @@protoc_insertion_point(field_release:mcp.Tool.input_schema)
  
  ::mcp::InputSchema* temp = _impl_.input_schema_;
  _impl_.input_schema_ = nullptr;
  return temp;
}
inline ::mcp::InputSchema* Tool::_internal_mutable_input_schema() {
  
  if (_impl_.input_schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::InputSchema>(GetArenaForAllocation());
    _impl_.input_schema_ = p;
  }
  return _impl_.input_schema_;
}
inline ::mcp::InputSchema* Tool::mutable_input_schema() {
  ::mcp::InputSchema* _msg = _internal_mutable_input_schema();
  // @@protoc_insertion_point(field_mutable:mcp.Tool.input_schema)
  return _msg;
}
inline void Tool::set_allocated_input_schema(::mcp::InputSchema* input_schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_schema_;
  }
  if (input_schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_schema);
    if (message_arena != submessage_arena) {
      input_schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_schema_ = input_schema;
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.input_schema)
}

// .mcp.ToolAnnotations annotations = 4;
inline bool Tool::_internal_has_annotations() const {
  return this != internal_default_instance() && _impl_.annotations_ != nullptr;
}
inline bool Tool::has_annotations() const {
  return _internal_has_annotations();
}
inline void Tool::clear_annotations() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotations_ != nullptr) {
    delete _impl_.annotations_;
  }
  _impl_.annotations_ = nullptr;
}
inline const ::mcp::ToolAnnotations& Tool::_internal_annotations() const {
  const ::mcp::ToolAnnotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ToolAnnotations&>(
      ::mcp::_ToolAnnotations_default_instance_);
}
inline const ::mcp::ToolAnnotations& Tool::annotations() const {
  // @@protoc_insertion_point(field_get:mcp.Tool.annotations)
  return _internal_annotations();
}
inline void Tool::unsafe_arena_set_allocated_annotations(
    ::mcp::ToolAnnotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.Tool.annotations)
}
inline ::mcp::ToolAnnotations* Tool::release_annotations() {
  
  ::mcp::ToolAnnotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ToolAnnotations* Tool::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.Tool.annotations)
  
  ::mcp::ToolAnnotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::mcp::ToolAnnotations* Tool::_internal_mutable_annotations() {
  
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ToolAnnotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::mcp::ToolAnnotations* Tool::mutable_annotations() {
  ::mcp::ToolAnnotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:mcp.Tool.annotations)
  return _msg;
}
inline void Tool::set_allocated_annotations(::mcp::ToolAnnotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotations_;
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotations);
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.annotations)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InputSchema

// string type = 1;
inline void InputSchema::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& InputSchema::type() const {
  // @@protoc_insertion_point(field_get:mcp.InputSchema.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputSchema::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.InputSchema.type)
}
inline std::string* InputSchema::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mcp.InputSchema.type)
  return _s;
}
inline const std::string& InputSchema::_internal_type() const {
  return _impl_.type_.Get();
}
inline void InputSchema::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* InputSchema::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* InputSchema::release_type() {
  // @@protoc_insertion_point(field_release:mcp.InputSchema.type)
  return _impl_.type_.Release();
}
inline void InputSchema::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.InputSchema.type)
}

// map<string, bytes> properties = 2;
inline int InputSchema::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int InputSchema::properties_size() const {
  return _internal_properties_size();
}
inline void InputSchema::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputSchema::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputSchema::properties() const {
  // @@protoc_insertion_point(field_map:mcp.InputSchema.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputSchema::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputSchema::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:mcp.InputSchema.properties)
  return _internal_mutable_properties();
}

// repeated string required = 3;
inline int InputSchema::_internal_required_size() const {
  return _impl_.required_.size();
}
inline int InputSchema::required_size() const {
  return _internal_required_size();
}
inline void InputSchema::clear_required() {
  _impl_.required_.Clear();
}
inline std::string* InputSchema::add_required() {
  std::string* _s = _internal_add_required();
  // @@protoc_insertion_point(field_add_mutable:mcp.InputSchema.required)
  return _s;
}
inline const std::string& InputSchema::_internal_required(int index) const {
  return _impl_.required_.Get(index);
}
inline const std::string& InputSchema::required(int index) const {
  // @@protoc_insertion_point(field_get:mcp.InputSchema.required)
  return _internal_required(index);
}
inline std::string* InputSchema::mutable_required(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.InputSchema.required)
  return _impl_.required_.Mutable(index);
}
inline void InputSchema::set_required(int index, const std::string& value) {
  _impl_.required_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcp.InputSchema.required)
}
inline void InputSchema::set_required(int index, std::string&& value) {
  _impl_.required_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcp.InputSchema.required)
}
inline void InputSchema::set_required(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcp.InputSchema.required)
}
inline void InputSchema::set_required(int index, const char* value, size_t size) {
  _impl_.required_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcp.InputSchema.required)
}
inline std::string* InputSchema::_internal_add_required() {
  return _impl_.required_.Add();
}
inline void InputSchema::add_required(const std::string& value) {
  _impl_.required_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcp.InputSchema.required)
}
inline void InputSchema::add_required(std::string&& value) {
  _impl_.required_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcp.InputSchema.required)
}
inline void InputSchema::add_required(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcp.InputSchema.required)
}
inline void InputSchema::add_required(const char* value, size_t size) {
  _impl_.required_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcp.InputSchema.required)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InputSchema::required() const {
  // @@protoc_insertion_point(field_list:mcp.InputSchema.required)
  return _impl_.required_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InputSchema::mutable_required() {
  // @@protoc_insertion_point(field_mutable_list:mcp.InputSchema.required)
  return &_impl_.required_;
}

// -------------------------------------------------------------------

// ToolAnnotations

// string title = 1;
inline void ToolAnnotations::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ToolAnnotations::title() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolAnnotations::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.title)
}
inline std::string* ToolAnnotations::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:mcp.ToolAnnotations.title)
  return _s;
}
inline const std::string& ToolAnnotations::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ToolAnnotations::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolAnnotations::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolAnnotations::release_title() {
  // @@protoc_insertion_point(field_release:mcp.ToolAnnotations.title)
  return _impl_.title_.Release();
}
inline void ToolAnnotations::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ToolAnnotations.title)
}

// bool read_only_hint = 2;
inline void ToolAnnotations::clear_read_only_hint() {
  _impl_.read_only_hint_ = false;
}
inline bool ToolAnnotations::_internal_read_only_hint() const {
  return _impl_.read_only_hint_;
}
inline bool ToolAnnotations::read_only_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.read_only_hint)
  return _internal_read_only_hint();
}
inline void ToolAnnotations::_internal_set_read_only_hint(bool value) {
  
  _impl_.read_only_hint_ = value;
}
inline void ToolAnnotations::set_read_only_hint(bool value) {
  _internal_set_read_only_hint(value);
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.read_only_hint)
}

// bool destructive_hint = 3;
inline void ToolAnnotations::clear_destructive_hint() {
  _impl_.destructive_hint_ = false;
}
inline bool ToolAnnotations::_internal_destructive_hint() const {
  return _impl_.destructive_hint_;
}
inline bool ToolAnnotations::destructive_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.destructive_hint)
  return _internal_destructive_hint();
}
inline void ToolAnnotations::_internal_set_destructive_hint(bool value) {
  
  _impl_.destructive_hint_ = value;
}
inline void ToolAnnotations::set_destructive_hint(bool value) {
  _internal_set_destructive_hint(value);
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.destructive_hint)
}

// bool idempotent_hint = 4;
inline void ToolAnnotations::clear_idempotent_hint() {
  _impl_.idempotent_hint_ = false;
}
inline bool ToolAnnotations::_internal_idempotent_hint() const {
  return _impl_.idempotent_hint_;
}
inline bool ToolAnnotations::idempotent_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.idempotent_hint)
  return _internal_idempotent_hint();
}
inline void ToolAnnotations::_internal_set_idempotent_hint(bool value) {
  
  _impl_.idempotent_hint_ = value;
}
inline void ToolAnnotations::set_idempotent_hint(bool value) {
  _internal_set_idempotent_hint(value);
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.idempotent_hint)
}

// bool open_world_hint = 5;
inline void ToolAnnotations::clear_open_world_hint() {
  _impl_.open_world_hint_ = false;
}
inline bool ToolAnnotations::_internal_open_world_hint() const {
  return _impl_.open_world_hint_;
}
inline bool ToolAnnotations::open_world_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.open_world_hint)
  return _internal_open_world_hint();
}
inline void ToolAnnotations::_internal_set_open_world_hint(bool value) {
  
  _impl_.open_world_hint_ = value;
}
inline void ToolAnnotations::set_open_world_hint(bool value) {
  _internal_set_open_world_hint(value);
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.open_world_hint)
}

// -------------------------------------------------------------------

// Annotations

// repeated .mcp.Role audience = 1;
inline int Annotations::_internal_audience_size() const {
  return _impl_.audience_.size();
}
inline int Annotations::audience_size() const {
  return _internal_audience_size();
}
inline void Annotations::clear_audience() {
  _impl_.audience_.Clear();
}
inline ::mcp::Role Annotations::_internal_audience(int index) const {
  return static_cast< ::mcp::Role >(_impl_.audience_.Get(index));
}
inline ::mcp::Role Annotations::audience(int index) const {
  // @@protoc_insertion_point(field_get:mcp.Annotations.audience)
  return _internal_audience(index);
}
inline void Annotations::set_audience(int index, ::mcp::Role value) {
  _impl_.audience_.Set(index, value);
  // @@protoc_insertion_point(field_set:mcp.Annotations.audience)
}
inline void Annotations::_internal_add_audience(::mcp::Role value) {
  _impl_.audience_.Add(value);
}
inline void Annotations::add_audience(::mcp::Role value) {
  _internal_add_audience(value);
  // @@protoc_insertion_point(field_add:mcp.Annotations.audience)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Annotations::audience() const {
  // @@protoc_insertion_point(field_list:mcp.Annotations.audience)
  return _impl_.audience_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Annotations::_internal_mutable_audience() {
  return &_impl_.audience_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Annotations::mutable_audience() {
  // @@protoc_insertion_point(field_mutable_list:mcp.Annotations.audience)
  return _internal_mutable_audience();
}

// float priority = 2;
inline void Annotations::clear_priority() {
  _impl_.priority_ = 0;
}
inline float Annotations::_internal_priority() const {
  return _impl_.priority_;
}
inline float Annotations::priority() const {
  // @@protoc_insertion_point(field_get:mcp.Annotations.priority)
  return _internal_priority();
}
inline void Annotations::_internal_set_priority(float value) {
  
  _impl_.priority_ = value;
}
inline void Annotations::set_priority(float value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:mcp.Annotations.priority)
}

// -------------------------------------------------------------------

// TextContent

// string type = 1;
inline void TextContent::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TextContent::type() const {
  // @@protoc_insertion_point(field_get:mcp.TextContent.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextContent::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.TextContent.type)
}
inline std::string* TextContent::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mcp.TextContent.type)
  return _s;
}
inline const std::string& TextContent::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TextContent::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TextContent::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TextContent::release_type() {
  // @@protoc_insertion_point(field_release:mcp.TextContent.type)
  return _impl_.type_.Release();
}
inline void TextContent::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.TextContent.type)
}

// string text = 2;
inline void TextContent::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextContent::text() const {
  // @@protoc_insertion_point(field_get:mcp.TextContent.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextContent::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.TextContent.text)
}
inline std::string* TextContent::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mcp.TextContent.text)
  return _s;
}
inline const std::string& TextContent::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextContent::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextContent::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextContent::release_text() {
  // @@protoc_insertion_point(field_release:mcp.TextContent.text)
  return _impl_.text_.Release();
}
inline void TextContent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.TextContent.text)
}

// .mcp.Annotations annotations = 3;
inline bool TextContent::_internal_has_annotations() const {
  return this != internal_default_instance() && _impl_.annotations_ != nullptr;
}
inline bool TextContent::has_annotations() const {
  return _internal_has_annotations();
}
inline void TextContent::clear_annotations() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotations_ != nullptr) {
    delete _impl_.annotations_;
  }
  _impl_.annotations_ = nullptr;
}
inline const ::mcp::Annotations& TextContent::_internal_annotations() const {
  const ::mcp::Annotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Annotations&>(
      ::mcp::_Annotations_default_instance_);
}
inline const ::mcp::Annotations& TextContent::annotations() const {
  // @@protoc_insertion_point(field_get:mcp.TextContent.annotations)
  return _internal_annotations();
}
inline void TextContent::unsafe_arena_set_allocated_annotations(
    ::mcp::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.TextContent.annotations)
}
inline ::mcp::Annotations* TextContent::release_annotations() {
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Annotations* TextContent::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.TextContent.annotations)
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::mcp::Annotations* TextContent::_internal_mutable_annotations() {
  
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::mcp::Annotations* TextContent::mutable_annotations() {
  ::mcp::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:mcp.TextContent.annotations)
  return _msg;
}
inline void TextContent::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotations_;
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotations);
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.TextContent.annotations)
}

// -------------------------------------------------------------------

// ImageContent

// string type = 1;
inline void ImageContent::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ImageContent::type() const {
  // @@protoc_insertion_point(field_get:mcp.ImageContent.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageContent::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ImageContent.type)
}
inline std::string* ImageContent::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.type)
  return _s;
}
inline const std::string& ImageContent::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ImageContent::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageContent::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageContent::release_type() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.type)
  return _impl_.type_.Release();
}
inline void ImageContent::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.type)
}

// bytes data = 2;
inline void ImageContent::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ImageContent::data() const {
  // @@protoc_insertion_point(field_get:mcp.ImageContent.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageContent::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ImageContent.data)
}
inline std::string* ImageContent::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.data)
  return _s;
}
inline const std::string& ImageContent::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ImageContent::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageContent::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageContent::release_data() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.data)
  return _impl_.data_.Release();
}
inline void ImageContent::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.data)
}

// string mime_type = 3;
inline void ImageContent::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& ImageContent::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.ImageContent.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageContent::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ImageContent.mime_type)
}
inline std::string* ImageContent::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.mime_type)
  return _s;
}
inline const std::string& ImageContent::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void ImageContent::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageContent::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageContent::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.mime_type)
  return _impl_.mime_type_.Release();
}
inline void ImageContent::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.mime_type)
}

// .mcp.Annotations annotations = 4;
inline bool ImageContent::_internal_has_annotations() const {
  return this != internal_default_instance() && _impl_.annotations_ != nullptr;
}
inline bool ImageContent::has_annotations() const {
  return _internal_has_annotations();
}
inline void ImageContent::clear_annotations() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotations_ != nullptr) {
    delete _impl_.annotations_;
  }
  _impl_.annotations_ = nullptr;
}
inline const ::mcp::Annotations& ImageContent::_internal_annotations() const {
  const ::mcp::Annotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Annotations&>(
      ::mcp::_Annotations_default_instance_);
}
inline const ::mcp::Annotations& ImageContent::annotations() const {
  // @@protoc_insertion_point(field_get:mcp.ImageContent.annotations)
  return _internal_annotations();
}
inline void ImageContent::unsafe_arena_set_allocated_annotations(
    ::mcp::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ImageContent.annotations)
}
inline ::mcp::Annotations* ImageContent::release_annotations() {
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Annotations* ImageContent::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.annotations)
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::mcp::Annotations* ImageContent::_internal_mutable_annotations() {
  
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::mcp::Annotations* ImageContent::mutable_annotations() {
  ::mcp::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.annotations)
  return _msg;
}
inline void ImageContent::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotations_;
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotations);
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.annotations)
}

// -------------------------------------------------------------------

// AudioContent

// string type = 1;
inline void AudioContent::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& AudioContent::type() const {
  // @@protoc_insertion_point(field_get:mcp.AudioContent.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioContent::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.AudioContent.type)
}
inline std::string* AudioContent::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.type)
  return _s;
}
inline const std::string& AudioContent::_internal_type() const {
  return _impl_.type_.Get();
}
inline void AudioContent::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioContent::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioContent::release_type() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.type)
  return _impl_.type_.Release();
}
inline void AudioContent::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.type)
}

// bytes data = 2;
inline void AudioContent::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& AudioContent::data() const {
  // @@protoc_insertion_point(field_get:mcp.AudioContent.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioContent::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.AudioContent.data)
}
inline std::string* AudioContent::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.data)
  return _s;
}
inline const std::string& AudioContent::_internal_data() const {
  return _impl_.data_.Get();
}
inline void AudioContent::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioContent::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioContent::release_data() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.data)
  return _impl_.data_.Release();
}
inline void AudioContent::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.data)
}

// string mime_type = 3;
inline void AudioContent::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& AudioContent::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.AudioContent.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioContent::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.AudioContent.mime_type)
}
inline std::string* AudioContent::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.mime_type)
  return _s;
}
inline const std::string& AudioContent::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void AudioContent::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioContent::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioContent::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.mime_type)
  return _impl_.mime_type_.Release();
}
inline void AudioContent::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.mime_type)
}

// .mcp.Annotations annotations = 4;
inline bool AudioContent::_internal_has_annotations() const {
  return this != internal_default_instance() && _impl_.annotations_ != nullptr;
}
inline bool AudioContent::has_annotations() const {
  return _internal_has_annotations();
}
inline void AudioContent::clear_annotations() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotations_ != nullptr) {
    delete _impl_.annotations_;
  }
  _impl_.annotations_ = nullptr;
}
inline const ::mcp::Annotations& AudioContent::_internal_annotations() const {
  const ::mcp::Annotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Annotations&>(
      ::mcp::_Annotations_default_instance_);
}
inline const ::mcp::Annotations& AudioContent::annotations() const {
  // @@protoc_insertion_point(field_get:mcp.AudioContent.annotations)
  return _internal_annotations();
}
inline void AudioContent::unsafe_arena_set_allocated_annotations(
    ::mcp::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.AudioContent.annotations)
}
inline ::mcp::Annotations* AudioContent::release_annotations() {
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Annotations* AudioContent::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.annotations)
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::mcp::Annotations* AudioContent::_internal_mutable_annotations() {
  
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::mcp::Annotations* AudioContent::mutable_annotations() {
  ::mcp::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.annotations)
  return _msg;
}
inline void AudioContent::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotations_;
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotations);
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.annotations)
}

// -------------------------------------------------------------------

// ModelPreferences

// repeated .mcp.ModelHint hints = 1;
inline int ModelPreferences::_internal_hints_size() const {
  return _impl_.hints_.size();
}
inline int ModelPreferences::hints_size() const {
  return _internal_hints_size();
}
inline void ModelPreferences::clear_hints() {
  _impl_.hints_.Clear();
}
inline ::mcp::ModelHint* ModelPreferences::mutable_hints(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ModelPreferences.hints)
  return _impl_.hints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ModelHint >*
ModelPreferences::mutable_hints() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ModelPreferences.hints)
  return &_impl_.hints_;
}
inline const ::mcp::ModelHint& ModelPreferences::_internal_hints(int index) const {
  return _impl_.hints_.Get(index);
}
inline const ::mcp::ModelHint& ModelPreferences::hints(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.hints)
  return _internal_hints(index);
}
inline ::mcp::ModelHint* ModelPreferences::_internal_add_hints() {
  return _impl_.hints_.Add();
}
inline ::mcp::ModelHint* ModelPreferences::add_hints() {
  ::mcp::ModelHint* _add = _internal_add_hints();
  // @@protoc_insertion_point(field_add:mcp.ModelPreferences.hints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ModelHint >&
ModelPreferences::hints() const {
  // @@protoc_insertion_point(field_list:mcp.ModelPreferences.hints)
  return _impl_.hints_;
}

// float cost_priority = 2;
inline void ModelPreferences::clear_cost_priority() {
  _impl_.cost_priority_ = 0;
}
inline float ModelPreferences::_internal_cost_priority() const {
  return _impl_.cost_priority_;
}
inline float ModelPreferences::cost_priority() const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.cost_priority)
  return _internal_cost_priority();
}
inline void ModelPreferences::_internal_set_cost_priority(float value) {
  
  _impl_.cost_priority_ = value;
}
inline void ModelPreferences::set_cost_priority(float value) {
  _internal_set_cost_priority(value);
  // @@protoc_insertion_point(field_set:mcp.ModelPreferences.cost_priority)
}

// float speed_priority = 3;
inline void ModelPreferences::clear_speed_priority() {
  _impl_.speed_priority_ = 0;
}
inline float ModelPreferences::_internal_speed_priority() const {
  return _impl_.speed_priority_;
}
inline float ModelPreferences::speed_priority() const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.speed_priority)
  return _internal_speed_priority();
}
inline void ModelPreferences::_internal_set_speed_priority(float value) {
  
  _impl_.speed_priority_ = value;
}
inline void ModelPreferences::set_speed_priority(float value) {
  _internal_set_speed_priority(value);
  // @@protoc_insertion_point(field_set:mcp.ModelPreferences.speed_priority)
}

// float intelligence_priority = 4;
inline void ModelPreferences::clear_intelligence_priority() {
  _impl_.intelligence_priority_ = 0;
}
inline float ModelPreferences::_internal_intelligence_priority() const {
  return _impl_.intelligence_priority_;
}
inline float ModelPreferences::intelligence_priority() const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.intelligence_priority)
  return _internal_intelligence_priority();
}
inline void ModelPreferences::_internal_set_intelligence_priority(float value) {
  
  _impl_.intelligence_priority_ = value;
}
inline void ModelPreferences::set_intelligence_priority(float value) {
  _internal_set_intelligence_priority(value);
  // @@protoc_insertion_point(field_set:mcp.ModelPreferences.intelligence_priority)
}

// -------------------------------------------------------------------

// ModelHint

// string name = 1;
inline void ModelHint::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelHint::name() const {
  // @@protoc_insertion_point(field_get:mcp.ModelHint.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelHint::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ModelHint.name)
}
inline std::string* ModelHint::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.ModelHint.name)
  return _s;
}
inline const std::string& ModelHint::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelHint::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelHint::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelHint::release_name() {
  // @@protoc_insertion_point(field_release:mcp.ModelHint.name)
  return _impl_.name_.Release();
}
inline void ModelHint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ModelHint.name)
}

// -------------------------------------------------------------------

// ResourceReference

// string type = 1;
inline void ResourceReference::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ResourceReference::type() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceReference.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceReference::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceReference.type)
}
inline std::string* ResourceReference::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceReference.type)
  return _s;
}
inline const std::string& ResourceReference::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ResourceReference::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceReference::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceReference::release_type() {
  // @@protoc_insertion_point(field_release:mcp.ResourceReference.type)
  return _impl_.type_.Release();
}
inline void ResourceReference::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceReference.type)
}

// string uri = 2;
inline void ResourceReference::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& ResourceReference::uri() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceReference.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceReference::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ResourceReference.uri)
}
inline std::string* ResourceReference::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mcp.ResourceReference.uri)
  return _s;
}
inline const std::string& ResourceReference::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void ResourceReference::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceReference::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceReference::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.ResourceReference.uri)
  return _impl_.uri_.Release();
}
inline void ResourceReference::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceReference.uri)
}

// -------------------------------------------------------------------

// PromptReference

// string type = 1;
inline void PromptReference::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& PromptReference::type() const {
  // @@protoc_insertion_point(field_get:mcp.PromptReference.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptReference::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.PromptReference.type)
}
inline std::string* PromptReference::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mcp.PromptReference.type)
  return _s;
}
inline const std::string& PromptReference::_internal_type() const {
  return _impl_.type_.Get();
}
inline void PromptReference::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptReference::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptReference::release_type() {
  // @@protoc_insertion_point(field_release:mcp.PromptReference.type)
  return _impl_.type_.Release();
}
inline void PromptReference::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.PromptReference.type)
}

// string name = 2;
inline void PromptReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PromptReference::name() const {
  // @@protoc_insertion_point(field_get:mcp.PromptReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.PromptReference.name)
}
inline std::string* PromptReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.PromptReference.name)
  return _s;
}
inline const std::string& PromptReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PromptReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptReference::release_name() {
  // @@protoc_insertion_point(field_release:mcp.PromptReference.name)
  return _impl_.name_.Release();
}
inline void PromptReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.PromptReference.name)
}

// -------------------------------------------------------------------

// Root

// string uri = 1;
inline void Root::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Root::uri() const {
  // @@protoc_insertion_point(field_get:mcp.Root.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Root::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Root.uri)
}
inline std::string* Root::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mcp.Root.uri)
  return _s;
}
inline const std::string& Root::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Root::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Root::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Root::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.Root.uri)
  return _impl_.uri_.Release();
}
inline void Root::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Root.uri)
}

// string name = 2;
inline void Root::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Root::name() const {
  // @@protoc_insertion_point(field_get:mcp.Root.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Root::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Root.name)
}
inline std::string* Root::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.Root.name)
  return _s;
}
inline const std::string& Root::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Root::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Root::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Root::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Root.name)
  return _impl_.name_.Release();
}
inline void Root::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Root.name)
}

// -------------------------------------------------------------------

// InitializeRequest

// string method = 1;
inline void InitializeRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& InitializeRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializeRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.InitializeRequest.method)
}
inline std::string* InitializeRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeRequest.method)
  return _s;
}
inline const std::string& InitializeRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void InitializeRequest::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* InitializeRequest::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* InitializeRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.InitializeRequest.method)
  return _impl_.method_.Release();
}
inline void InitializeRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeRequest.method)
}

// .mcp.InitializeParams params = 2;
inline bool InitializeRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool InitializeRequest::has_params() const {
  return _internal_has_params();
}
inline void InitializeRequest::clear_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.params_ != nullptr) {
    delete _impl_.params_;
  }
  _impl_.params_ = nullptr;
}
inline const ::mcp::InitializeParams& InitializeRequest::_internal_params() const {
  const ::mcp::InitializeParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::InitializeParams&>(
      ::mcp::_InitializeParams_default_instance_);
}
inline const ::mcp::InitializeParams& InitializeRequest::params() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeRequest.params)
  return _internal_params();
}
inline void InitializeRequest::unsafe_arena_set_allocated_params(
    ::mcp::InitializeParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.InitializeRequest.params)
}
inline ::mcp::InitializeParams* InitializeRequest::release_params() {
  
  ::mcp::InitializeParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::InitializeParams* InitializeRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:mcp.InitializeRequest.params)
  
  ::mcp::InitializeParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::mcp::InitializeParams* InitializeRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::InitializeParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::mcp::InitializeParams* InitializeRequest::mutable_params() {
  ::mcp::InitializeParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeRequest.params)
  return _msg;
}
inline void InitializeRequest::set_allocated_params(::mcp::InitializeParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeRequest.params)
}

// -------------------------------------------------------------------

// InitializeParams

// string protocol_version = 1;
inline void InitializeParams::clear_protocol_version() {
  _impl_.protocol_version_.ClearToEmpty();
}
inline const std::string& InitializeParams::protocol_version() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeParams.protocol_version)
  return _internal_protocol_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializeParams::set_protocol_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protocol_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.InitializeParams.protocol_version)
}
inline std::string* InitializeParams::mutable_protocol_version() {
  std::string* _s = _internal_mutable_protocol_version();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeParams.protocol_version)
  return _s;
}
inline const std::string& InitializeParams::_internal_protocol_version() const {
  return _impl_.protocol_version_.Get();
}
inline void InitializeParams::_internal_set_protocol_version(const std::string& value) {
  
  _impl_.protocol_version_.Set(value, GetArenaForAllocation());
}
inline std::string* InitializeParams::_internal_mutable_protocol_version() {
  
  return _impl_.protocol_version_.Mutable(GetArenaForAllocation());
}
inline std::string* InitializeParams::release_protocol_version() {
  // @@protoc_insertion_point(field_release:mcp.InitializeParams.protocol_version)
  return _impl_.protocol_version_.Release();
}
inline void InitializeParams::set_allocated_protocol_version(std::string* protocol_version) {
  if (protocol_version != nullptr) {
    
  } else {
    
  }
  _impl_.protocol_version_.SetAllocated(protocol_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protocol_version_.IsDefault()) {
    _impl_.protocol_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeParams.protocol_version)
}

// .mcp.ClientCapabilities capabilities = 2;
inline bool InitializeParams::_internal_has_capabilities() const {
  return this != internal_default_instance() && _impl_.capabilities_ != nullptr;
}
inline bool InitializeParams::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void InitializeParams::clear_capabilities() {
  if (GetArenaForAllocation() == nullptr && _impl_.capabilities_ != nullptr) {
    delete _impl_.capabilities_;
  }
  _impl_.capabilities_ = nullptr;
}
inline const ::mcp::ClientCapabilities& InitializeParams::_internal_capabilities() const {
  const ::mcp::ClientCapabilities* p = _impl_.capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ClientCapabilities&>(
      ::mcp::_ClientCapabilities_default_instance_);
}
inline const ::mcp::ClientCapabilities& InitializeParams::capabilities() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeParams.capabilities)
  return _internal_capabilities();
}
inline void InitializeParams::unsafe_arena_set_allocated_capabilities(
    ::mcp::ClientCapabilities* capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  _impl_.capabilities_ = capabilities;
  if (capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.InitializeParams.capabilities)
}
inline ::mcp::ClientCapabilities* InitializeParams::release_capabilities() {
  
  ::mcp::ClientCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ClientCapabilities* InitializeParams::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.InitializeParams.capabilities)
  
  ::mcp::ClientCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
  return temp;
}
inline ::mcp::ClientCapabilities* InitializeParams::_internal_mutable_capabilities() {
  
  if (_impl_.capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ClientCapabilities>(GetArenaForAllocation());
    _impl_.capabilities_ = p;
  }
  return _impl_.capabilities_;
}
inline ::mcp::ClientCapabilities* InitializeParams::mutable_capabilities() {
  ::mcp::ClientCapabilities* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeParams.capabilities)
  return _msg;
}
inline void InitializeParams::set_allocated_capabilities(::mcp::ClientCapabilities* capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capabilities_;
  }
  if (capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capabilities);
    if (message_arena != submessage_arena) {
      capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeParams.capabilities)
}

// .mcp.Implementation client_info = 3;
inline bool InitializeParams::_internal_has_client_info() const {
  return this != internal_default_instance() && _impl_.client_info_ != nullptr;
}
inline bool InitializeParams::has_client_info() const {
  return _internal_has_client_info();
}
inline void InitializeParams::clear_client_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.client_info_ != nullptr) {
    delete _impl_.client_info_;
  }
  _impl_.client_info_ = nullptr;
}
inline const ::mcp::Implementation& InitializeParams::_internal_client_info() const {
  const ::mcp::Implementation* p = _impl_.client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Implementation&>(
      ::mcp::_Implementation_default_instance_);
}
inline const ::mcp::Implementation& InitializeParams::client_info() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeParams.client_info)
  return _internal_client_info();
}
inline void InitializeParams::unsafe_arena_set_allocated_client_info(
    ::mcp::Implementation* client_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_info_);
  }
  _impl_.client_info_ = client_info;
  if (client_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.InitializeParams.client_info)
}
inline ::mcp::Implementation* InitializeParams::release_client_info() {
  
  ::mcp::Implementation* temp = _impl_.client_info_;
  _impl_.client_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Implementation* InitializeParams::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_release:mcp.InitializeParams.client_info)
  
  ::mcp::Implementation* temp = _impl_.client_info_;
  _impl_.client_info_ = nullptr;
  return temp;
}
inline ::mcp::Implementation* InitializeParams::_internal_mutable_client_info() {
  
  if (_impl_.client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaForAllocation());
    _impl_.client_info_ = p;
  }
  return _impl_.client_info_;
}
inline ::mcp::Implementation* InitializeParams::mutable_client_info() {
  ::mcp::Implementation* _msg = _internal_mutable_client_info();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeParams.client_info)
  return _msg;
}
inline void InitializeParams::set_allocated_client_info(::mcp::Implementation* client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_info_;
  }
  if (client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_info);
    if (message_arena != submessage_arena) {
      client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeParams.client_info)
}

// -------------------------------------------------------------------

// InitializeResult

// string protocol_version = 1;
inline void InitializeResult::clear_protocol_version() {
  _impl_.protocol_version_.ClearToEmpty();
}
inline const std::string& InitializeResult::protocol_version() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.protocol_version)
  return _internal_protocol_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializeResult::set_protocol_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protocol_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.InitializeResult.protocol_version)
}
inline std::string* InitializeResult::mutable_protocol_version() {
  std::string* _s = _internal_mutable_protocol_version();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.protocol_version)
  return _s;
}
inline const std::string& InitializeResult::_internal_protocol_version() const {
  return _impl_.protocol_version_.Get();
}
inline void InitializeResult::_internal_set_protocol_version(const std::string& value) {
  
  _impl_.protocol_version_.Set(value, GetArenaForAllocation());
}
inline std::string* InitializeResult::_internal_mutable_protocol_version() {
  
  return _impl_.protocol_version_.Mutable(GetArenaForAllocation());
}
inline std::string* InitializeResult::release_protocol_version() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.protocol_version)
  return _impl_.protocol_version_.Release();
}
inline void InitializeResult::set_allocated_protocol_version(std::string* protocol_version) {
  if (protocol_version != nullptr) {
    
  } else {
    
  }
  _impl_.protocol_version_.SetAllocated(protocol_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protocol_version_.IsDefault()) {
    _impl_.protocol_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.protocol_version)
}

// .mcp.ServerCapabilities capabilities = 2;
inline bool InitializeResult::_internal_has_capabilities() const {
  return this != internal_default_instance() && _impl_.capabilities_ != nullptr;
}
inline bool InitializeResult::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void InitializeResult::clear_capabilities() {
  if (GetArenaForAllocation() == nullptr && _impl_.capabilities_ != nullptr) {
    delete _impl_.capabilities_;
  }
  _impl_.capabilities_ = nullptr;
}
inline const ::mcp::ServerCapabilities& InitializeResult::_internal_capabilities() const {
  const ::mcp::ServerCapabilities* p = _impl_.capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ServerCapabilities&>(
      ::mcp::_ServerCapabilities_default_instance_);
}
inline const ::mcp::ServerCapabilities& InitializeResult::capabilities() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.capabilities)
  return _internal_capabilities();
}
inline void InitializeResult::unsafe_arena_set_allocated_capabilities(
    ::mcp::ServerCapabilities* capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  _impl_.capabilities_ = capabilities;
  if (capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.InitializeResult.capabilities)
}
inline ::mcp::ServerCapabilities* InitializeResult::release_capabilities() {
  
  ::mcp::ServerCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ServerCapabilities* InitializeResult::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.capabilities)
  
  ::mcp::ServerCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
  return temp;
}
inline ::mcp::ServerCapabilities* InitializeResult::_internal_mutable_capabilities() {
  
  if (_impl_.capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ServerCapabilities>(GetArenaForAllocation());
    _impl_.capabilities_ = p;
  }
  return _impl_.capabilities_;
}
inline ::mcp::ServerCapabilities* InitializeResult::mutable_capabilities() {
  ::mcp::ServerCapabilities* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.capabilities)
  return _msg;
}
inline void InitializeResult::set_allocated_capabilities(::mcp::ServerCapabilities* capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capabilities_;
  }
  if (capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capabilities);
    if (message_arena != submessage_arena) {
      capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.capabilities)
}

// .mcp.Implementation server_info = 3;
inline bool InitializeResult::_internal_has_server_info() const {
  return this != internal_default_instance() && _impl_.server_info_ != nullptr;
}
inline bool InitializeResult::has_server_info() const {
  return _internal_has_server_info();
}
inline void InitializeResult::clear_server_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_info_ != nullptr) {
    delete _impl_.server_info_;
  }
  _impl_.server_info_ = nullptr;
}
inline const ::mcp::Implementation& InitializeResult::_internal_server_info() const {
  const ::mcp::Implementation* p = _impl_.server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Implementation&>(
      ::mcp::_Implementation_default_instance_);
}
inline const ::mcp::Implementation& InitializeResult::server_info() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.server_info)
  return _internal_server_info();
}
inline void InitializeResult::unsafe_arena_set_allocated_server_info(
    ::mcp::Implementation* server_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_info_);
  }
  _impl_.server_info_ = server_info;
  if (server_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.InitializeResult.server_info)
}
inline ::mcp::Implementation* InitializeResult::release_server_info() {
  
  ::mcp::Implementation* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Implementation* InitializeResult::unsafe_arena_release_server_info() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.server_info)
  
  ::mcp::Implementation* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  return temp;
}
inline ::mcp::Implementation* InitializeResult::_internal_mutable_server_info() {
  
  if (_impl_.server_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaForAllocation());
    _impl_.server_info_ = p;
  }
  return _impl_.server_info_;
}
inline ::mcp::Implementation* InitializeResult::mutable_server_info() {
  ::mcp::Implementation* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.server_info)
  return _msg;
}
inline void InitializeResult::set_allocated_server_info(::mcp::Implementation* server_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_info_;
  }
  if (server_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server_info);
    if (message_arena != submessage_arena) {
      server_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_info_ = server_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.server_info)
}

// string instructions = 4;
inline void InitializeResult::clear_instructions() {
  _impl_.instructions_.ClearToEmpty();
}
inline const std::string& InitializeResult::instructions() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.instructions)
  return _internal_instructions();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializeResult::set_instructions(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instructions_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.InitializeResult.instructions)
}
inline std::string* InitializeResult::mutable_instructions() {
  std::string* _s = _internal_mutable_instructions();
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.instructions)
  return _s;
}
inline const std::string& InitializeResult::_internal_instructions() const {
  return _impl_.instructions_.Get();
}
inline void InitializeResult::_internal_set_instructions(const std::string& value) {
  
  _impl_.instructions_.Set(value, GetArenaForAllocation());
}
inline std::string* InitializeResult::_internal_mutable_instructions() {
  
  return _impl_.instructions_.Mutable(GetArenaForAllocation());
}
inline std::string* InitializeResult::release_instructions() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.instructions)
  return _impl_.instructions_.Release();
}
inline void InitializeResult::set_allocated_instructions(std::string* instructions) {
  if (instructions != nullptr) {
    
  } else {
    
  }
  _impl_.instructions_.SetAllocated(instructions, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instructions_.IsDefault()) {
    _impl_.instructions_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.instructions)
}

// -------------------------------------------------------------------

// ListResourcesRequest

// string method = 1;
inline void ListResourcesRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& ListResourcesRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.ListResourcesRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListResourcesRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ListResourcesRequest.method)
}
inline std::string* ListResourcesRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesRequest.method)
  return _s;
}
inline const std::string& ListResourcesRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void ListResourcesRequest::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* ListResourcesRequest::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* ListResourcesRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.ListResourcesRequest.method)
  return _impl_.method_.Release();
}
inline void ListResourcesRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ListResourcesRequest.method)
}

// .mcp.PaginatedParams params = 2;
inline bool ListResourcesRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ListResourcesRequest::has_params() const {
  return _internal_has_params();
}
inline void ListResourcesRequest::clear_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.params_ != nullptr) {
    delete _impl_.params_;
  }
  _impl_.params_ = nullptr;
}
inline const ::mcp::PaginatedParams& ListResourcesRequest::_internal_params() const {
  const ::mcp::PaginatedParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::PaginatedParams&>(
      ::mcp::_PaginatedParams_default_instance_);
}
inline const ::mcp::PaginatedParams& ListResourcesRequest::params() const {
  // @@protoc_insertion_point(field_get:mcp.ListResourcesRequest.params)
  return _internal_params();
}
inline void ListResourcesRequest::unsafe_arena_set_allocated_params(
    ::mcp::PaginatedParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ListResourcesRequest.params)
}
inline ::mcp::PaginatedParams* ListResourcesRequest::release_params() {
  
  ::mcp::PaginatedParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::PaginatedParams* ListResourcesRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:mcp.ListResourcesRequest.params)
  
  ::mcp::PaginatedParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::mcp::PaginatedParams* ListResourcesRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::PaginatedParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::mcp::PaginatedParams* ListResourcesRequest::mutable_params() {
  ::mcp::PaginatedParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesRequest.params)
  return _msg;
}
inline void ListResourcesRequest::set_allocated_params(::mcp::PaginatedParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ListResourcesRequest.params)
}

// -------------------------------------------------------------------

// ListResourcesResult

// repeated .mcp.Resource resources = 1;
inline int ListResourcesResult::_internal_resources_size() const {
  return _impl_.resources_.size();
}
inline int ListResourcesResult::resources_size() const {
  return _internal_resources_size();
}
inline void ListResourcesResult::clear_resources() {
  _impl_.resources_.Clear();
}
inline ::mcp::Resource* ListResourcesResult::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesResult.resources)
  return _impl_.resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Resource >*
ListResourcesResult::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ListResourcesResult.resources)
  return &_impl_.resources_;
}
inline const ::mcp::Resource& ListResourcesResult::_internal_resources(int index) const {
  return _impl_.resources_.Get(index);
}
inline const ::mcp::Resource& ListResourcesResult::resources(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ListResourcesResult.resources)
  return _internal_resources(index);
}
inline ::mcp::Resource* ListResourcesResult::_internal_add_resources() {
  return _impl_.resources_.Add();
}
inline ::mcp::Resource* ListResourcesResult::add_resources() {
  ::mcp::Resource* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:mcp.ListResourcesResult.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Resource >&
ListResourcesResult::resources() const {
  // @@protoc_insertion_point(field_list:mcp.ListResourcesResult.resources)
  return _impl_.resources_;
}

// string next_cursor = 2;
inline void ListResourcesResult::clear_next_cursor() {
  _impl_.next_cursor_.ClearToEmpty();
}
inline const std::string& ListResourcesResult::next_cursor() const {
  // @@protoc_insertion_point(field_get:mcp.ListResourcesResult.next_cursor)
  return _internal_next_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListResourcesResult::set_next_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ListResourcesResult.next_cursor)
}
inline std::string* ListResourcesResult::mutable_next_cursor() {
  std::string* _s = _internal_mutable_next_cursor();
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesResult.next_cursor)
  return _s;
}
inline const std::string& ListResourcesResult::_internal_next_cursor() const {
  return _impl_.next_cursor_.Get();
}
inline void ListResourcesResult::_internal_set_next_cursor(const std::string& value) {
  
  _impl_.next_cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* ListResourcesResult::_internal_mutable_next_cursor() {
  
  return _impl_.next_cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* ListResourcesResult::release_next_cursor() {
  // @@protoc_insertion_point(field_release:mcp.ListResourcesResult.next_cursor)
  return _impl_.next_cursor_.Release();
}
inline void ListResourcesResult::set_allocated_next_cursor(std::string* next_cursor) {
  if (next_cursor != nullptr) {
    
  } else {
    
  }
  _impl_.next_cursor_.SetAllocated(next_cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_cursor_.IsDefault()) {
    _impl_.next_cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ListResourcesResult.next_cursor)
}

// -------------------------------------------------------------------

// ReadResourceRequest

// string method = 1;
inline void ReadResourceRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& ReadResourceRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.ReadResourceRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadResourceRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ReadResourceRequest.method)
}
inline std::string* ReadResourceRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceRequest.method)
  return _s;
}
inline const std::string& ReadResourceRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void ReadResourceRequest::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadResourceRequest::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadResourceRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.ReadResourceRequest.method)
  return _impl_.method_.Release();
}
inline void ReadResourceRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ReadResourceRequest.method)
}

// .mcp.ReadResourceParams params = 2;
inline bool ReadResourceRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ReadResourceRequest::has_params() const {
  return _internal_has_params();
}
inline void ReadResourceRequest::clear_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.params_ != nullptr) {
    delete _impl_.params_;
  }
  _impl_.params_ = nullptr;
}
inline const ::mcp::ReadResourceParams& ReadResourceRequest::_internal_params() const {
  const ::mcp::ReadResourceParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ReadResourceParams&>(
      ::mcp::_ReadResourceParams_default_instance_);
}
inline const ::mcp::ReadResourceParams& ReadResourceRequest::params() const {
  // @@protoc_insertion_point(field_get:mcp.ReadResourceRequest.params)
  return _internal_params();
}
inline void ReadResourceRequest::unsafe_arena_set_allocated_params(
    ::mcp::ReadResourceParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ReadResourceRequest.params)
}
inline ::mcp::ReadResourceParams* ReadResourceRequest::release_params() {
  
  ::mcp::ReadResourceParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ReadResourceParams* ReadResourceRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:mcp.ReadResourceRequest.params)
  
  ::mcp::ReadResourceParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::mcp::ReadResourceParams* ReadResourceRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ReadResourceParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::mcp::ReadResourceParams* ReadResourceRequest::mutable_params() {
  ::mcp::ReadResourceParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceRequest.params)
  return _msg;
}
inline void ReadResourceRequest::set_allocated_params(::mcp::ReadResourceParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ReadResourceRequest.params)
}

// -------------------------------------------------------------------

// ReadResourceParams

// string uri = 1;
inline void ReadResourceParams::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& ReadResourceParams::uri() const {
  // @@protoc_insertion_point(field_get:mcp.ReadResourceParams.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadResourceParams::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ReadResourceParams.uri)
}
inline std::string* ReadResourceParams::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceParams.uri)
  return _s;
}
inline const std::string& ReadResourceParams::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void ReadResourceParams::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadResourceParams::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadResourceParams::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.ReadResourceParams.uri)
  return _impl_.uri_.Release();
}
inline void ReadResourceParams::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ReadResourceParams.uri)
}

// -------------------------------------------------------------------

// ReadResourceResult

// repeated .mcp.ResourceContents contents = 1;
inline int ReadResourceResult::_internal_contents_size() const {
  return _impl_.contents_.size();
}
inline int ReadResourceResult::contents_size() const {
  return _internal_contents_size();
}
inline void ReadResourceResult::clear_contents() {
  _impl_.contents_.Clear();
}
inline ::mcp::ResourceContents* ReadResourceResult::mutable_contents(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceResult.contents)
  return _impl_.contents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ResourceContents >*
ReadResourceResult::mutable_contents() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ReadResourceResult.contents)
  return &_impl_.contents_;
}
inline const ::mcp::ResourceContents& ReadResourceResult::_internal_contents(int index) const {
  return _impl_.contents_.Get(index);
}
inline const ::mcp::ResourceContents& ReadResourceResult::contents(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ReadResourceResult.contents)
  return _internal_contents(index);
}
inline ::mcp::ResourceContents* ReadResourceResult::_internal_add_contents() {
  return _impl_.contents_.Add();
}
inline ::mcp::ResourceContents* ReadResourceResult::add_contents() {
  ::mcp::ResourceContents* _add = _internal_add_contents();
  // @@protoc_insertion_point(field_add:mcp.ReadResourceResult.contents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::ResourceContents >&
ReadResourceResult::contents() const {
  // @@protoc_insertion_point(field_list:mcp.ReadResourceResult.contents)
  return _impl_.contents_;
}

// -------------------------------------------------------------------

// PaginatedParams

// string cursor = 1;
inline void PaginatedParams::clear_cursor() {
  _impl_.cursor_.ClearToEmpty();
}
inline const std::string& PaginatedParams::cursor() const {
  // @@protoc_insertion_point(field_get:mcp.PaginatedParams.cursor)
  return _internal_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginatedParams::set_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.PaginatedParams.cursor)
}
inline std::string* PaginatedParams::mutable_cursor() {
  std::string* _s = _internal_mutable_cursor();
  // @@protoc_insertion_point(field_mutable:mcp.PaginatedParams.cursor)
  return _s;
}
inline const std::string& PaginatedParams::_internal_cursor() const {
  return _impl_.cursor_.Get();
}
inline void PaginatedParams::_internal_set_cursor(const std::string& value) {
  
  _impl_.cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* PaginatedParams::_internal_mutable_cursor() {
  
  return _impl_.cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* PaginatedParams::release_cursor() {
  // @@protoc_insertion_point(field_release:mcp.PaginatedParams.cursor)
  return _impl_.cursor_.Release();
}
inline void PaginatedParams::set_allocated_cursor(std::string* cursor) {
  if (cursor != nullptr) {
    
  } else {
    
  }
  _impl_.cursor_.SetAllocated(cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cursor_.IsDefault()) {
    _impl_.cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.PaginatedParams.cursor)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcp

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mcp::Role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcp::Role>() {
  return ::mcp::Role_descriptor();
}
template <> struct is_proto_enum< ::mcp::LoggingLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcp::LoggingLevel>() {
  return ::mcp::LoggingLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mcp_2eproto
