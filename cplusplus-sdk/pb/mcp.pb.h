// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcp.proto

#ifndef PROTOBUF_INCLUDED_mcp_2eproto
#define PROTOBUF_INCLUDED_mcp_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mcp_2eproto 

namespace protobuf_mcp_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[57];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mcp_2eproto
namespace mcp {
class Annotations;
class AnnotationsDefaultTypeInternal;
extern AnnotationsDefaultTypeInternal _Annotations_default_instance_;
class AudioContent;
class AudioContentDefaultTypeInternal;
extern AudioContentDefaultTypeInternal _AudioContent_default_instance_;
class BlobResourceContents;
class BlobResourceContentsDefaultTypeInternal;
extern BlobResourceContentsDefaultTypeInternal _BlobResourceContents_default_instance_;
class ClientCapabilities;
class ClientCapabilitiesDefaultTypeInternal;
extern ClientCapabilitiesDefaultTypeInternal _ClientCapabilities_default_instance_;
class ClientCapabilities_ExperimentalEntry_DoNotUse;
class ClientCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal;
extern ClientCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal _ClientCapabilities_ExperimentalEntry_DoNotUse_default_instance_;
class CompletionsCapability;
class CompletionsCapabilityDefaultTypeInternal;
extern CompletionsCapabilityDefaultTypeInternal _CompletionsCapability_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class ImageContent;
class ImageContentDefaultTypeInternal;
extern ImageContentDefaultTypeInternal _ImageContent_default_instance_;
class Implementation;
class ImplementationDefaultTypeInternal;
extern ImplementationDefaultTypeInternal _Implementation_default_instance_;
class InitializeParams;
class InitializeParamsDefaultTypeInternal;
extern InitializeParamsDefaultTypeInternal _InitializeParams_default_instance_;
class InitializeRequest;
class InitializeRequestDefaultTypeInternal;
extern InitializeRequestDefaultTypeInternal _InitializeRequest_default_instance_;
class InitializeResult;
class InitializeResultDefaultTypeInternal;
extern InitializeResultDefaultTypeInternal _InitializeResult_default_instance_;
class InputSchema;
class InputSchemaDefaultTypeInternal;
extern InputSchemaDefaultTypeInternal _InputSchema_default_instance_;
class InputSchema_PropertiesEntry_DoNotUse;
class InputSchema_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern InputSchema_PropertiesEntry_DoNotUseDefaultTypeInternal _InputSchema_PropertiesEntry_DoNotUse_default_instance_;
class JSONRPCBatchRequest;
class JSONRPCBatchRequestDefaultTypeInternal;
extern JSONRPCBatchRequestDefaultTypeInternal _JSONRPCBatchRequest_default_instance_;
class JSONRPCBatchResponse;
class JSONRPCBatchResponseDefaultTypeInternal;
extern JSONRPCBatchResponseDefaultTypeInternal _JSONRPCBatchResponse_default_instance_;
class JSONRPCError;
class JSONRPCErrorDefaultTypeInternal;
extern JSONRPCErrorDefaultTypeInternal _JSONRPCError_default_instance_;
class JSONRPCMessage;
class JSONRPCMessageDefaultTypeInternal;
extern JSONRPCMessageDefaultTypeInternal _JSONRPCMessage_default_instance_;
class JSONRPCNotification;
class JSONRPCNotificationDefaultTypeInternal;
extern JSONRPCNotificationDefaultTypeInternal _JSONRPCNotification_default_instance_;
class JSONRPCRequest;
class JSONRPCRequestDefaultTypeInternal;
extern JSONRPCRequestDefaultTypeInternal _JSONRPCRequest_default_instance_;
class JSONRPCResponse;
class JSONRPCResponseDefaultTypeInternal;
extern JSONRPCResponseDefaultTypeInternal _JSONRPCResponse_default_instance_;
class ListResourcesRequest;
class ListResourcesRequestDefaultTypeInternal;
extern ListResourcesRequestDefaultTypeInternal _ListResourcesRequest_default_instance_;
class ListResourcesResult;
class ListResourcesResultDefaultTypeInternal;
extern ListResourcesResultDefaultTypeInternal _ListResourcesResult_default_instance_;
class LoggingCapability;
class LoggingCapabilityDefaultTypeInternal;
extern LoggingCapabilityDefaultTypeInternal _LoggingCapability_default_instance_;
class MetaParams;
class MetaParamsDefaultTypeInternal;
extern MetaParamsDefaultTypeInternal _MetaParams_default_instance_;
class MetaParams_AdditionalMetaEntry_DoNotUse;
class MetaParams_AdditionalMetaEntry_DoNotUseDefaultTypeInternal;
extern MetaParams_AdditionalMetaEntry_DoNotUseDefaultTypeInternal _MetaParams_AdditionalMetaEntry_DoNotUse_default_instance_;
class MetaResult;
class MetaResultDefaultTypeInternal;
extern MetaResultDefaultTypeInternal _MetaResult_default_instance_;
class MetaResult_AdditionalMetaEntry_DoNotUse;
class MetaResult_AdditionalMetaEntry_DoNotUseDefaultTypeInternal;
extern MetaResult_AdditionalMetaEntry_DoNotUseDefaultTypeInternal _MetaResult_AdditionalMetaEntry_DoNotUse_default_instance_;
class ModelHint;
class ModelHintDefaultTypeInternal;
extern ModelHintDefaultTypeInternal _ModelHint_default_instance_;
class ModelPreferences;
class ModelPreferencesDefaultTypeInternal;
extern ModelPreferencesDefaultTypeInternal _ModelPreferences_default_instance_;
class NotificationParams;
class NotificationParamsDefaultTypeInternal;
extern NotificationParamsDefaultTypeInternal _NotificationParams_default_instance_;
class NotificationParams_AdditionalParamsEntry_DoNotUse;
class NotificationParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal;
extern NotificationParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal _NotificationParams_AdditionalParamsEntry_DoNotUse_default_instance_;
class PaginatedParams;
class PaginatedParamsDefaultTypeInternal;
extern PaginatedParamsDefaultTypeInternal _PaginatedParams_default_instance_;
class PromptReference;
class PromptReferenceDefaultTypeInternal;
extern PromptReferenceDefaultTypeInternal _PromptReference_default_instance_;
class PromptsCapability;
class PromptsCapabilityDefaultTypeInternal;
extern PromptsCapabilityDefaultTypeInternal _PromptsCapability_default_instance_;
class ReadResourceParams;
class ReadResourceParamsDefaultTypeInternal;
extern ReadResourceParamsDefaultTypeInternal _ReadResourceParams_default_instance_;
class ReadResourceRequest;
class ReadResourceRequestDefaultTypeInternal;
extern ReadResourceRequestDefaultTypeInternal _ReadResourceRequest_default_instance_;
class ReadResourceResult;
class ReadResourceResultDefaultTypeInternal;
extern ReadResourceResultDefaultTypeInternal _ReadResourceResult_default_instance_;
class RequestParams;
class RequestParamsDefaultTypeInternal;
extern RequestParamsDefaultTypeInternal _RequestParams_default_instance_;
class RequestParams_AdditionalParamsEntry_DoNotUse;
class RequestParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal;
extern RequestParams_AdditionalParamsEntry_DoNotUseDefaultTypeInternal _RequestParams_AdditionalParamsEntry_DoNotUse_default_instance_;
class Resource;
class ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class ResourceContents;
class ResourceContentsDefaultTypeInternal;
extern ResourceContentsDefaultTypeInternal _ResourceContents_default_instance_;
class ResourceReference;
class ResourceReferenceDefaultTypeInternal;
extern ResourceReferenceDefaultTypeInternal _ResourceReference_default_instance_;
class ResourceTemplate;
class ResourceTemplateDefaultTypeInternal;
extern ResourceTemplateDefaultTypeInternal _ResourceTemplate_default_instance_;
class ResourcesCapability;
class ResourcesCapabilityDefaultTypeInternal;
extern ResourcesCapabilityDefaultTypeInternal _ResourcesCapability_default_instance_;
class Result;
class ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Result_AdditionalResultEntry_DoNotUse;
class Result_AdditionalResultEntry_DoNotUseDefaultTypeInternal;
extern Result_AdditionalResultEntry_DoNotUseDefaultTypeInternal _Result_AdditionalResultEntry_DoNotUse_default_instance_;
class Root;
class RootDefaultTypeInternal;
extern RootDefaultTypeInternal _Root_default_instance_;
class RootsCapability;
class RootsCapabilityDefaultTypeInternal;
extern RootsCapabilityDefaultTypeInternal _RootsCapability_default_instance_;
class SamplingCapability;
class SamplingCapabilityDefaultTypeInternal;
extern SamplingCapabilityDefaultTypeInternal _SamplingCapability_default_instance_;
class ServerCapabilities;
class ServerCapabilitiesDefaultTypeInternal;
extern ServerCapabilitiesDefaultTypeInternal _ServerCapabilities_default_instance_;
class ServerCapabilities_ExperimentalEntry_DoNotUse;
class ServerCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal;
extern ServerCapabilities_ExperimentalEntry_DoNotUseDefaultTypeInternal _ServerCapabilities_ExperimentalEntry_DoNotUse_default_instance_;
class TextContent;
class TextContentDefaultTypeInternal;
extern TextContentDefaultTypeInternal _TextContent_default_instance_;
class TextResourceContents;
class TextResourceContentsDefaultTypeInternal;
extern TextResourceContentsDefaultTypeInternal _TextResourceContents_default_instance_;
class Tool;
class ToolDefaultTypeInternal;
extern ToolDefaultTypeInternal _Tool_default_instance_;
class ToolAnnotations;
class ToolAnnotationsDefaultTypeInternal;
extern ToolAnnotationsDefaultTypeInternal _ToolAnnotations_default_instance_;
class ToolsCapability;
class ToolsCapabilityDefaultTypeInternal;
extern ToolsCapabilityDefaultTypeInternal _ToolsCapability_default_instance_;
}  // namespace mcp
namespace google {
namespace protobuf {
template<> ::mcp::Annotations* Arena::CreateMaybeMessage<::mcp::Annotations>(Arena*);
template<> ::mcp::AudioContent* Arena::CreateMaybeMessage<::mcp::AudioContent>(Arena*);
template<> ::mcp::BlobResourceContents* Arena::CreateMaybeMessage<::mcp::BlobResourceContents>(Arena*);
template<> ::mcp::ClientCapabilities* Arena::CreateMaybeMessage<::mcp::ClientCapabilities>(Arena*);
template<> ::mcp::ClientCapabilities_ExperimentalEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::ClientCapabilities_ExperimentalEntry_DoNotUse>(Arena*);
template<> ::mcp::CompletionsCapability* Arena::CreateMaybeMessage<::mcp::CompletionsCapability>(Arena*);
template<> ::mcp::Error* Arena::CreateMaybeMessage<::mcp::Error>(Arena*);
template<> ::mcp::ImageContent* Arena::CreateMaybeMessage<::mcp::ImageContent>(Arena*);
template<> ::mcp::Implementation* Arena::CreateMaybeMessage<::mcp::Implementation>(Arena*);
template<> ::mcp::InitializeParams* Arena::CreateMaybeMessage<::mcp::InitializeParams>(Arena*);
template<> ::mcp::InitializeRequest* Arena::CreateMaybeMessage<::mcp::InitializeRequest>(Arena*);
template<> ::mcp::InitializeResult* Arena::CreateMaybeMessage<::mcp::InitializeResult>(Arena*);
template<> ::mcp::InputSchema* Arena::CreateMaybeMessage<::mcp::InputSchema>(Arena*);
template<> ::mcp::InputSchema_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::InputSchema_PropertiesEntry_DoNotUse>(Arena*);
template<> ::mcp::JSONRPCBatchRequest* Arena::CreateMaybeMessage<::mcp::JSONRPCBatchRequest>(Arena*);
template<> ::mcp::JSONRPCBatchResponse* Arena::CreateMaybeMessage<::mcp::JSONRPCBatchResponse>(Arena*);
template<> ::mcp::JSONRPCError* Arena::CreateMaybeMessage<::mcp::JSONRPCError>(Arena*);
template<> ::mcp::JSONRPCMessage* Arena::CreateMaybeMessage<::mcp::JSONRPCMessage>(Arena*);
template<> ::mcp::JSONRPCNotification* Arena::CreateMaybeMessage<::mcp::JSONRPCNotification>(Arena*);
template<> ::mcp::JSONRPCRequest* Arena::CreateMaybeMessage<::mcp::JSONRPCRequest>(Arena*);
template<> ::mcp::JSONRPCResponse* Arena::CreateMaybeMessage<::mcp::JSONRPCResponse>(Arena*);
template<> ::mcp::ListResourcesRequest* Arena::CreateMaybeMessage<::mcp::ListResourcesRequest>(Arena*);
template<> ::mcp::ListResourcesResult* Arena::CreateMaybeMessage<::mcp::ListResourcesResult>(Arena*);
template<> ::mcp::LoggingCapability* Arena::CreateMaybeMessage<::mcp::LoggingCapability>(Arena*);
template<> ::mcp::MetaParams* Arena::CreateMaybeMessage<::mcp::MetaParams>(Arena*);
template<> ::mcp::MetaParams_AdditionalMetaEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::MetaParams_AdditionalMetaEntry_DoNotUse>(Arena*);
template<> ::mcp::MetaResult* Arena::CreateMaybeMessage<::mcp::MetaResult>(Arena*);
template<> ::mcp::MetaResult_AdditionalMetaEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::MetaResult_AdditionalMetaEntry_DoNotUse>(Arena*);
template<> ::mcp::ModelHint* Arena::CreateMaybeMessage<::mcp::ModelHint>(Arena*);
template<> ::mcp::ModelPreferences* Arena::CreateMaybeMessage<::mcp::ModelPreferences>(Arena*);
template<> ::mcp::NotificationParams* Arena::CreateMaybeMessage<::mcp::NotificationParams>(Arena*);
template<> ::mcp::NotificationParams_AdditionalParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::NotificationParams_AdditionalParamsEntry_DoNotUse>(Arena*);
template<> ::mcp::PaginatedParams* Arena::CreateMaybeMessage<::mcp::PaginatedParams>(Arena*);
template<> ::mcp::PromptReference* Arena::CreateMaybeMessage<::mcp::PromptReference>(Arena*);
template<> ::mcp::PromptsCapability* Arena::CreateMaybeMessage<::mcp::PromptsCapability>(Arena*);
template<> ::mcp::ReadResourceParams* Arena::CreateMaybeMessage<::mcp::ReadResourceParams>(Arena*);
template<> ::mcp::ReadResourceRequest* Arena::CreateMaybeMessage<::mcp::ReadResourceRequest>(Arena*);
template<> ::mcp::ReadResourceResult* Arena::CreateMaybeMessage<::mcp::ReadResourceResult>(Arena*);
template<> ::mcp::RequestParams* Arena::CreateMaybeMessage<::mcp::RequestParams>(Arena*);
template<> ::mcp::RequestParams_AdditionalParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::RequestParams_AdditionalParamsEntry_DoNotUse>(Arena*);
template<> ::mcp::Resource* Arena::CreateMaybeMessage<::mcp::Resource>(Arena*);
template<> ::mcp::ResourceContents* Arena::CreateMaybeMessage<::mcp::ResourceContents>(Arena*);
template<> ::mcp::ResourceReference* Arena::CreateMaybeMessage<::mcp::ResourceReference>(Arena*);
template<> ::mcp::ResourceTemplate* Arena::CreateMaybeMessage<::mcp::ResourceTemplate>(Arena*);
template<> ::mcp::ResourcesCapability* Arena::CreateMaybeMessage<::mcp::ResourcesCapability>(Arena*);
template<> ::mcp::Result* Arena::CreateMaybeMessage<::mcp::Result>(Arena*);
template<> ::mcp::Result_AdditionalResultEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::Result_AdditionalResultEntry_DoNotUse>(Arena*);
template<> ::mcp::Root* Arena::CreateMaybeMessage<::mcp::Root>(Arena*);
template<> ::mcp::RootsCapability* Arena::CreateMaybeMessage<::mcp::RootsCapability>(Arena*);
template<> ::mcp::SamplingCapability* Arena::CreateMaybeMessage<::mcp::SamplingCapability>(Arena*);
template<> ::mcp::ServerCapabilities* Arena::CreateMaybeMessage<::mcp::ServerCapabilities>(Arena*);
template<> ::mcp::ServerCapabilities_ExperimentalEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::ServerCapabilities_ExperimentalEntry_DoNotUse>(Arena*);
template<> ::mcp::TextContent* Arena::CreateMaybeMessage<::mcp::TextContent>(Arena*);
template<> ::mcp::TextResourceContents* Arena::CreateMaybeMessage<::mcp::TextResourceContents>(Arena*);
template<> ::mcp::Tool* Arena::CreateMaybeMessage<::mcp::Tool>(Arena*);
template<> ::mcp::ToolAnnotations* Arena::CreateMaybeMessage<::mcp::ToolAnnotations>(Arena*);
template<> ::mcp::ToolsCapability* Arena::CreateMaybeMessage<::mcp::ToolsCapability>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mcp {

enum Role {
  ROLE_UNSPECIFIED = 0,
  ROLE_USER = 1,
  ROLE_ASSISTANT = 2,
  Role_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Role_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Role_IsValid(int value);
const Role Role_MIN = ROLE_UNSPECIFIED;
const Role Role_MAX = ROLE_ASSISTANT;
const int Role_ARRAYSIZE = Role_MAX + 1;

const ::google::protobuf::EnumDescriptor* Role_descriptor();
inline const ::std::string& Role_Name(Role value) {
  return ::google::protobuf::internal::NameOfEnum(
    Role_descriptor(), value);
}
inline bool Role_Parse(
    const ::std::string& name, Role* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Role>(
    Role_descriptor(), name, value);
}
enum LoggingLevel {
  LOGGING_LEVEL_UNSPECIFIED = 0,
  LOGGING_LEVEL_DEBUG = 1,
  LOGGING_LEVEL_INFO = 2,
  LOGGING_LEVEL_NOTICE = 3,
  LOGGING_LEVEL_WARNING = 4,
  LOGGING_LEVEL_ERROR = 5,
  LOGGING_LEVEL_CRITICAL = 6,
  LOGGING_LEVEL_ALERT = 7,
  LOGGING_LEVEL_EMERGENCY = 8,
  LoggingLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoggingLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoggingLevel_IsValid(int value);
const LoggingLevel LoggingLevel_MIN = LOGGING_LEVEL_UNSPECIFIED;
const LoggingLevel LoggingLevel_MAX = LOGGING_LEVEL_EMERGENCY;
const int LoggingLevel_ARRAYSIZE = LoggingLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoggingLevel_descriptor();
inline const ::std::string& LoggingLevel_Name(LoggingLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoggingLevel_descriptor(), value);
}
inline bool LoggingLevel_Parse(
    const ::std::string& name, LoggingLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoggingLevel>(
    LoggingLevel_descriptor(), name, value);
}
// ===================================================================

class JSONRPCMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCMessage) */ {
 public:
  JSONRPCMessage();
  virtual ~JSONRPCMessage();

  JSONRPCMessage(const JSONRPCMessage& from);

  inline JSONRPCMessage& operator=(const JSONRPCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSONRPCMessage(JSONRPCMessage&& from) noexcept
    : JSONRPCMessage() {
    *this = ::std::move(from);
  }

  inline JSONRPCMessage& operator=(JSONRPCMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONRPCMessage& default_instance();

  enum MessageCase {
    kRequest = 1,
    kNotification = 2,
    kBatchRequest = 3,
    kResponse = 4,
    kError = 5,
    kBatchResponse = 6,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSONRPCMessage* internal_default_instance() {
    return reinterpret_cast<const JSONRPCMessage*>(
               &_JSONRPCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(JSONRPCMessage* other);
  friend void swap(JSONRPCMessage& a, JSONRPCMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSONRPCMessage* New() const final {
    return CreateMaybeMessage<JSONRPCMessage>(NULL);
  }

  JSONRPCMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JSONRPCMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JSONRPCMessage& from);
  void MergeFrom(const JSONRPCMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mcp.JSONRPCRequest request = 1;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 1;
  private:
  const ::mcp::JSONRPCRequest& _internal_request() const;
  public:
  const ::mcp::JSONRPCRequest& request() const;
  ::mcp::JSONRPCRequest* release_request();
  ::mcp::JSONRPCRequest* mutable_request();
  void set_allocated_request(::mcp::JSONRPCRequest* request);

  // .mcp.JSONRPCNotification notification = 2;
  bool has_notification() const;
  void clear_notification();
  static const int kNotificationFieldNumber = 2;
  private:
  const ::mcp::JSONRPCNotification& _internal_notification() const;
  public:
  const ::mcp::JSONRPCNotification& notification() const;
  ::mcp::JSONRPCNotification* release_notification();
  ::mcp::JSONRPCNotification* mutable_notification();
  void set_allocated_notification(::mcp::JSONRPCNotification* notification);

  // .mcp.JSONRPCBatchRequest batch_request = 3;
  bool has_batch_request() const;
  void clear_batch_request();
  static const int kBatchRequestFieldNumber = 3;
  private:
  const ::mcp::JSONRPCBatchRequest& _internal_batch_request() const;
  public:
  const ::mcp::JSONRPCBatchRequest& batch_request() const;
  ::mcp::JSONRPCBatchRequest* release_batch_request();
  ::mcp::JSONRPCBatchRequest* mutable_batch_request();
  void set_allocated_batch_request(::mcp::JSONRPCBatchRequest* batch_request);

  // .mcp.JSONRPCResponse response = 4;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 4;
  private:
  const ::mcp::JSONRPCResponse& _internal_response() const;
  public:
  const ::mcp::JSONRPCResponse& response() const;
  ::mcp::JSONRPCResponse* release_response();
  ::mcp::JSONRPCResponse* mutable_response();
  void set_allocated_response(::mcp::JSONRPCResponse* response);

  // .mcp.JSONRPCError error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  private:
  const ::mcp::JSONRPCError& _internal_error() const;
  public:
  const ::mcp::JSONRPCError& error() const;
  ::mcp::JSONRPCError* release_error();
  ::mcp::JSONRPCError* mutable_error();
  void set_allocated_error(::mcp::JSONRPCError* error);

  // .mcp.JSONRPCBatchResponse batch_response = 6;
  bool has_batch_response() const;
  void clear_batch_response();
  static const int kBatchResponseFieldNumber = 6;
  private:
  const ::mcp::JSONRPCBatchResponse& _internal_batch_response() const;
  public:
  const ::mcp::JSONRPCBatchResponse& batch_response() const;
  ::mcp::JSONRPCBatchResponse* release_batch_response();
  ::mcp::JSONRPCBatchResponse* mutable_batch_response();
  void set_allocated_batch_response(::mcp::JSONRPCBatchResponse* batch_response);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:mcp.JSONRPCMessage)
 private:
  void set_has_request();
  void set_has_notification();
  void set_has_batch_request();
  void set_has_response();
  void set_has_error();
  void set_has_batch_response();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::mcp::JSONRPCRequest* request_;
    ::mcp::JSONRPCNotification* notification_;
    ::mcp::JSONRPCBatchRequest* batch_request_;
    ::mcp::JSONRPCResponse* response_;
    ::mcp::JSONRPCError* error_;
    ::mcp::JSONRPCBatchResponse* batch_response_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JSONRPCRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCRequest) */ {
 public:
  JSONRPCRequest();
  virtual ~JSONRPCRequest();

  JSONRPCRequest(const JSONRPCRequest& from);

  inline JSONRPCRequest& operator=(const JSONRPCRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSONRPCRequest(JSONRPCRequest&& from) noexcept
    : JSONRPCRequest() {
    *this = ::std::move(from);
  }

  inline JSONRPCRequest& operator=(JSONRPCRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONRPCRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSONRPCRequest* internal_default_instance() {
    return reinterpret_cast<const JSONRPCRequest*>(
               &_JSONRPCRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(JSONRPCRequest* other);
  friend void swap(JSONRPCRequest& a, JSONRPCRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSONRPCRequest* New() const final {
    return CreateMaybeMessage<JSONRPCRequest>(NULL);
  }

  JSONRPCRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JSONRPCRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JSONRPCRequest& from);
  void MergeFrom(const JSONRPCRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string jsonrpc = 1;
  void clear_jsonrpc();
  static const int kJsonrpcFieldNumber = 1;
  const ::std::string& jsonrpc() const;
  void set_jsonrpc(const ::std::string& value);
  #if LANG_CXX11
  void set_jsonrpc(::std::string&& value);
  #endif
  void set_jsonrpc(const char* value);
  void set_jsonrpc(const char* value, size_t size);
  ::std::string* mutable_jsonrpc();
  ::std::string* release_jsonrpc();
  void set_allocated_jsonrpc(::std::string* jsonrpc);

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string method = 3;
  void clear_method();
  static const int kMethodFieldNumber = 3;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // .mcp.RequestParams params = 4;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 4;
  private:
  const ::mcp::RequestParams& _internal_params() const;
  public:
  const ::mcp::RequestParams& params() const;
  ::mcp::RequestParams* release_params();
  ::mcp::RequestParams* mutable_params();
  void set_allocated_params(::mcp::RequestParams* params);

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr jsonrpc_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::mcp::RequestParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JSONRPCNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCNotification) */ {
 public:
  JSONRPCNotification();
  virtual ~JSONRPCNotification();

  JSONRPCNotification(const JSONRPCNotification& from);

  inline JSONRPCNotification& operator=(const JSONRPCNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSONRPCNotification(JSONRPCNotification&& from) noexcept
    : JSONRPCNotification() {
    *this = ::std::move(from);
  }

  inline JSONRPCNotification& operator=(JSONRPCNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONRPCNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSONRPCNotification* internal_default_instance() {
    return reinterpret_cast<const JSONRPCNotification*>(
               &_JSONRPCNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(JSONRPCNotification* other);
  friend void swap(JSONRPCNotification& a, JSONRPCNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSONRPCNotification* New() const final {
    return CreateMaybeMessage<JSONRPCNotification>(NULL);
  }

  JSONRPCNotification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JSONRPCNotification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JSONRPCNotification& from);
  void MergeFrom(const JSONRPCNotification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string jsonrpc = 1;
  void clear_jsonrpc();
  static const int kJsonrpcFieldNumber = 1;
  const ::std::string& jsonrpc() const;
  void set_jsonrpc(const ::std::string& value);
  #if LANG_CXX11
  void set_jsonrpc(::std::string&& value);
  #endif
  void set_jsonrpc(const char* value);
  void set_jsonrpc(const char* value, size_t size);
  ::std::string* mutable_jsonrpc();
  ::std::string* release_jsonrpc();
  void set_allocated_jsonrpc(::std::string* jsonrpc);

  // string method = 2;
  void clear_method();
  static const int kMethodFieldNumber = 2;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // .mcp.NotificationParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  private:
  const ::mcp::NotificationParams& _internal_params() const;
  public:
  const ::mcp::NotificationParams& params() const;
  ::mcp::NotificationParams* release_params();
  ::mcp::NotificationParams* mutable_params();
  void set_allocated_params(::mcp::NotificationParams* params);

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr jsonrpc_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::mcp::NotificationParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JSONRPCResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCResponse) */ {
 public:
  JSONRPCResponse();
  virtual ~JSONRPCResponse();

  JSONRPCResponse(const JSONRPCResponse& from);

  inline JSONRPCResponse& operator=(const JSONRPCResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSONRPCResponse(JSONRPCResponse&& from) noexcept
    : JSONRPCResponse() {
    *this = ::std::move(from);
  }

  inline JSONRPCResponse& operator=(JSONRPCResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONRPCResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSONRPCResponse* internal_default_instance() {
    return reinterpret_cast<const JSONRPCResponse*>(
               &_JSONRPCResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(JSONRPCResponse* other);
  friend void swap(JSONRPCResponse& a, JSONRPCResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSONRPCResponse* New() const final {
    return CreateMaybeMessage<JSONRPCResponse>(NULL);
  }

  JSONRPCResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JSONRPCResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JSONRPCResponse& from);
  void MergeFrom(const JSONRPCResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string jsonrpc = 1;
  void clear_jsonrpc();
  static const int kJsonrpcFieldNumber = 1;
  const ::std::string& jsonrpc() const;
  void set_jsonrpc(const ::std::string& value);
  #if LANG_CXX11
  void set_jsonrpc(::std::string&& value);
  #endif
  void set_jsonrpc(const char* value);
  void set_jsonrpc(const char* value, size_t size);
  ::std::string* mutable_jsonrpc();
  ::std::string* release_jsonrpc();
  void set_allocated_jsonrpc(::std::string* jsonrpc);

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .mcp.Result result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  private:
  const ::mcp::Result& _internal_result() const;
  public:
  const ::mcp::Result& result() const;
  ::mcp::Result* release_result();
  ::mcp::Result* mutable_result();
  void set_allocated_result(::mcp::Result* result);

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr jsonrpc_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::mcp::Result* result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JSONRPCError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCError) */ {
 public:
  JSONRPCError();
  virtual ~JSONRPCError();

  JSONRPCError(const JSONRPCError& from);

  inline JSONRPCError& operator=(const JSONRPCError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSONRPCError(JSONRPCError&& from) noexcept
    : JSONRPCError() {
    *this = ::std::move(from);
  }

  inline JSONRPCError& operator=(JSONRPCError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONRPCError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSONRPCError* internal_default_instance() {
    return reinterpret_cast<const JSONRPCError*>(
               &_JSONRPCError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(JSONRPCError* other);
  friend void swap(JSONRPCError& a, JSONRPCError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSONRPCError* New() const final {
    return CreateMaybeMessage<JSONRPCError>(NULL);
  }

  JSONRPCError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JSONRPCError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JSONRPCError& from);
  void MergeFrom(const JSONRPCError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string jsonrpc = 1;
  void clear_jsonrpc();
  static const int kJsonrpcFieldNumber = 1;
  const ::std::string& jsonrpc() const;
  void set_jsonrpc(const ::std::string& value);
  #if LANG_CXX11
  void set_jsonrpc(::std::string&& value);
  #endif
  void set_jsonrpc(const char* value);
  void set_jsonrpc(const char* value, size_t size);
  ::std::string* mutable_jsonrpc();
  ::std::string* release_jsonrpc();
  void set_allocated_jsonrpc(::std::string* jsonrpc);

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .mcp.Error error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::mcp::Error& _internal_error() const;
  public:
  const ::mcp::Error& error() const;
  ::mcp::Error* release_error();
  ::mcp::Error* mutable_error();
  void set_allocated_error(::mcp::Error* error);

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr jsonrpc_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::mcp::Error* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JSONRPCBatchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCBatchRequest) */ {
 public:
  JSONRPCBatchRequest();
  virtual ~JSONRPCBatchRequest();

  JSONRPCBatchRequest(const JSONRPCBatchRequest& from);

  inline JSONRPCBatchRequest& operator=(const JSONRPCBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSONRPCBatchRequest(JSONRPCBatchRequest&& from) noexcept
    : JSONRPCBatchRequest() {
    *this = ::std::move(from);
  }

  inline JSONRPCBatchRequest& operator=(JSONRPCBatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONRPCBatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSONRPCBatchRequest* internal_default_instance() {
    return reinterpret_cast<const JSONRPCBatchRequest*>(
               &_JSONRPCBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(JSONRPCBatchRequest* other);
  friend void swap(JSONRPCBatchRequest& a, JSONRPCBatchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSONRPCBatchRequest* New() const final {
    return CreateMaybeMessage<JSONRPCBatchRequest>(NULL);
  }

  JSONRPCBatchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JSONRPCBatchRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JSONRPCBatchRequest& from);
  void MergeFrom(const JSONRPCBatchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCBatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.JSONRPCRequest requests = 1;
  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 1;
  ::mcp::JSONRPCRequest* mutable_requests(int index);
  ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCRequest >*
      mutable_requests();
  const ::mcp::JSONRPCRequest& requests(int index) const;
  ::mcp::JSONRPCRequest* add_requests();
  const ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCBatchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCRequest > requests_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JSONRPCBatchResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.JSONRPCBatchResponse) */ {
 public:
  JSONRPCBatchResponse();
  virtual ~JSONRPCBatchResponse();

  JSONRPCBatchResponse(const JSONRPCBatchResponse& from);

  inline JSONRPCBatchResponse& operator=(const JSONRPCBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSONRPCBatchResponse(JSONRPCBatchResponse&& from) noexcept
    : JSONRPCBatchResponse() {
    *this = ::std::move(from);
  }

  inline JSONRPCBatchResponse& operator=(JSONRPCBatchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONRPCBatchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSONRPCBatchResponse* internal_default_instance() {
    return reinterpret_cast<const JSONRPCBatchResponse*>(
               &_JSONRPCBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(JSONRPCBatchResponse* other);
  friend void swap(JSONRPCBatchResponse& a, JSONRPCBatchResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSONRPCBatchResponse* New() const final {
    return CreateMaybeMessage<JSONRPCBatchResponse>(NULL);
  }

  JSONRPCBatchResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JSONRPCBatchResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JSONRPCBatchResponse& from);
  void MergeFrom(const JSONRPCBatchResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONRPCBatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.JSONRPCResponse responses = 1;
  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 1;
  ::mcp::JSONRPCResponse* mutable_responses(int index);
  ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCResponse >*
      mutable_responses();
  const ::mcp::JSONRPCResponse& responses(int index) const;
  ::mcp::JSONRPCResponse* add_responses();
  const ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:mcp.JSONRPCBatchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCResponse > responses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestParams_AdditionalParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<RequestParams_AdditionalParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<RequestParams_AdditionalParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  RequestParams_AdditionalParamsEntry_DoNotUse();
  RequestParams_AdditionalParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RequestParams_AdditionalParamsEntry_DoNotUse& other);
  static const RequestParams_AdditionalParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RequestParams_AdditionalParamsEntry_DoNotUse*>(&_RequestParams_AdditionalParamsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class RequestParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RequestParams) */ {
 public:
  RequestParams();
  virtual ~RequestParams();

  RequestParams(const RequestParams& from);

  inline RequestParams& operator=(const RequestParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestParams(RequestParams&& from) noexcept
    : RequestParams() {
    *this = ::std::move(from);
  }

  inline RequestParams& operator=(RequestParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestParams* internal_default_instance() {
    return reinterpret_cast<const RequestParams*>(
               &_RequestParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RequestParams* other);
  friend void swap(RequestParams& a, RequestParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestParams* New() const final {
    return CreateMaybeMessage<RequestParams>(NULL);
  }

  RequestParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestParams& from);
  void MergeFrom(const RequestParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> additional_params = 2;
  int additional_params_size() const;
  void clear_additional_params();
  static const int kAdditionalParamsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      additional_params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_additional_params();

  // .mcp.MetaParams _meta = 1;
  bool has__meta() const;
  void clear__meta();
  static const int kMetaFieldNumber = 1;
  private:
  const ::mcp::MetaParams& _internal__meta() const;
  public:
  const ::mcp::MetaParams& _meta() const;
  ::mcp::MetaParams* release__meta();
  ::mcp::MetaParams* mutable__meta();
  void set_allocated__meta(::mcp::MetaParams* _meta);

  // @@protoc_insertion_point(class_scope:mcp.RequestParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      RequestParams_AdditionalParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > additional_params_;
  ::mcp::MetaParams* _meta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NotificationParams_AdditionalParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<NotificationParams_AdditionalParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<NotificationParams_AdditionalParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  NotificationParams_AdditionalParamsEntry_DoNotUse();
  NotificationParams_AdditionalParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const NotificationParams_AdditionalParamsEntry_DoNotUse& other);
  static const NotificationParams_AdditionalParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NotificationParams_AdditionalParamsEntry_DoNotUse*>(&_NotificationParams_AdditionalParamsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class NotificationParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.NotificationParams) */ {
 public:
  NotificationParams();
  virtual ~NotificationParams();

  NotificationParams(const NotificationParams& from);

  inline NotificationParams& operator=(const NotificationParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotificationParams(NotificationParams&& from) noexcept
    : NotificationParams() {
    *this = ::std::move(from);
  }

  inline NotificationParams& operator=(NotificationParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotificationParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotificationParams* internal_default_instance() {
    return reinterpret_cast<const NotificationParams*>(
               &_NotificationParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(NotificationParams* other);
  friend void swap(NotificationParams& a, NotificationParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotificationParams* New() const final {
    return CreateMaybeMessage<NotificationParams>(NULL);
  }

  NotificationParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NotificationParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NotificationParams& from);
  void MergeFrom(const NotificationParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> additional_params = 2;
  int additional_params_size() const;
  void clear_additional_params();
  static const int kAdditionalParamsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      additional_params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_additional_params();

  // .mcp.MetaParams _meta = 1;
  bool has__meta() const;
  void clear__meta();
  static const int kMetaFieldNumber = 1;
  private:
  const ::mcp::MetaParams& _internal__meta() const;
  public:
  const ::mcp::MetaParams& _meta() const;
  ::mcp::MetaParams* release__meta();
  ::mcp::MetaParams* mutable__meta();
  void set_allocated__meta(::mcp::MetaParams* _meta);

  // @@protoc_insertion_point(class_scope:mcp.NotificationParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      NotificationParams_AdditionalParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > additional_params_;
  ::mcp::MetaParams* _meta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaParams_AdditionalMetaEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MetaParams_AdditionalMetaEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MetaParams_AdditionalMetaEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  MetaParams_AdditionalMetaEntry_DoNotUse();
  MetaParams_AdditionalMetaEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MetaParams_AdditionalMetaEntry_DoNotUse& other);
  static const MetaParams_AdditionalMetaEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetaParams_AdditionalMetaEntry_DoNotUse*>(&_MetaParams_AdditionalMetaEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MetaParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.MetaParams) */ {
 public:
  MetaParams();
  virtual ~MetaParams();

  MetaParams(const MetaParams& from);

  inline MetaParams& operator=(const MetaParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaParams(MetaParams&& from) noexcept
    : MetaParams() {
    *this = ::std::move(from);
  }

  inline MetaParams& operator=(MetaParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaParams* internal_default_instance() {
    return reinterpret_cast<const MetaParams*>(
               &_MetaParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(MetaParams* other);
  friend void swap(MetaParams& a, MetaParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaParams* New() const final {
    return CreateMaybeMessage<MetaParams>(NULL);
  }

  MetaParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MetaParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MetaParams& from);
  void MergeFrom(const MetaParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> additional_meta = 2;
  int additional_meta_size() const;
  void clear_additional_meta();
  static const int kAdditionalMetaFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      additional_meta() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_additional_meta();

  // string progress_token = 1;
  void clear_progress_token();
  static const int kProgressTokenFieldNumber = 1;
  const ::std::string& progress_token() const;
  void set_progress_token(const ::std::string& value);
  #if LANG_CXX11
  void set_progress_token(::std::string&& value);
  #endif
  void set_progress_token(const char* value);
  void set_progress_token(const char* value, size_t size);
  ::std::string* mutable_progress_token();
  ::std::string* release_progress_token();
  void set_allocated_progress_token(::std::string* progress_token);

  // @@protoc_insertion_point(class_scope:mcp.MetaParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      MetaParams_AdditionalMetaEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > additional_meta_;
  ::google::protobuf::internal::ArenaStringPtr progress_token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Result_AdditionalResultEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Result_AdditionalResultEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Result_AdditionalResultEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  Result_AdditionalResultEntry_DoNotUse();
  Result_AdditionalResultEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Result_AdditionalResultEntry_DoNotUse& other);
  static const Result_AdditionalResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Result_AdditionalResultEntry_DoNotUse*>(&_Result_AdditionalResultEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Result) */ {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Result* other);
  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return CreateMaybeMessage<Result>(NULL);
  }

  Result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> additional_result = 2;
  int additional_result_size() const;
  void clear_additional_result();
  static const int kAdditionalResultFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      additional_result() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_additional_result();

  // .mcp.MetaResult _meta = 1;
  bool has__meta() const;
  void clear__meta();
  static const int kMetaFieldNumber = 1;
  private:
  const ::mcp::MetaResult& _internal__meta() const;
  public:
  const ::mcp::MetaResult& _meta() const;
  ::mcp::MetaResult* release__meta();
  ::mcp::MetaResult* mutable__meta();
  void set_allocated__meta(::mcp::MetaResult* _meta);

  // @@protoc_insertion_point(class_scope:mcp.Result)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Result_AdditionalResultEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > additional_result_;
  ::mcp::MetaResult* _meta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaResult_AdditionalMetaEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MetaResult_AdditionalMetaEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MetaResult_AdditionalMetaEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  MetaResult_AdditionalMetaEntry_DoNotUse();
  MetaResult_AdditionalMetaEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MetaResult_AdditionalMetaEntry_DoNotUse& other);
  static const MetaResult_AdditionalMetaEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetaResult_AdditionalMetaEntry_DoNotUse*>(&_MetaResult_AdditionalMetaEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MetaResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.MetaResult) */ {
 public:
  MetaResult();
  virtual ~MetaResult();

  MetaResult(const MetaResult& from);

  inline MetaResult& operator=(const MetaResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaResult(MetaResult&& from) noexcept
    : MetaResult() {
    *this = ::std::move(from);
  }

  inline MetaResult& operator=(MetaResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaResult* internal_default_instance() {
    return reinterpret_cast<const MetaResult*>(
               &_MetaResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(MetaResult* other);
  friend void swap(MetaResult& a, MetaResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaResult* New() const final {
    return CreateMaybeMessage<MetaResult>(NULL);
  }

  MetaResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MetaResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MetaResult& from);
  void MergeFrom(const MetaResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> additional_meta = 1;
  int additional_meta_size() const;
  void clear_additional_meta();
  static const int kAdditionalMetaFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      additional_meta() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_additional_meta();

  // @@protoc_insertion_point(class_scope:mcp.MetaResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      MetaResult_AdditionalMetaEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > additional_meta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(NULL);
  }

  Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcp.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Implementation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Implementation) */ {
 public:
  Implementation();
  virtual ~Implementation();

  Implementation(const Implementation& from);

  inline Implementation& operator=(const Implementation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Implementation(Implementation&& from) noexcept
    : Implementation() {
    *this = ::std::move(from);
  }

  inline Implementation& operator=(Implementation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Implementation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Implementation* internal_default_instance() {
    return reinterpret_cast<const Implementation*>(
               &_Implementation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Implementation* other);
  friend void swap(Implementation& a, Implementation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Implementation* New() const final {
    return CreateMaybeMessage<Implementation>(NULL);
  }

  Implementation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Implementation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Implementation& from);
  void MergeFrom(const Implementation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Implementation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mcp.Implementation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientCapabilities_ExperimentalEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ClientCapabilities_ExperimentalEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ClientCapabilities_ExperimentalEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  ClientCapabilities_ExperimentalEntry_DoNotUse();
  ClientCapabilities_ExperimentalEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ClientCapabilities_ExperimentalEntry_DoNotUse& other);
  static const ClientCapabilities_ExperimentalEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ClientCapabilities_ExperimentalEntry_DoNotUse*>(&_ClientCapabilities_ExperimentalEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ClientCapabilities : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ClientCapabilities) */ {
 public:
  ClientCapabilities();
  virtual ~ClientCapabilities();

  ClientCapabilities(const ClientCapabilities& from);

  inline ClientCapabilities& operator=(const ClientCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientCapabilities(ClientCapabilities&& from) noexcept
    : ClientCapabilities() {
    *this = ::std::move(from);
  }

  inline ClientCapabilities& operator=(ClientCapabilities&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCapabilities& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientCapabilities* internal_default_instance() {
    return reinterpret_cast<const ClientCapabilities*>(
               &_ClientCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ClientCapabilities* other);
  friend void swap(ClientCapabilities& a, ClientCapabilities& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientCapabilities* New() const final {
    return CreateMaybeMessage<ClientCapabilities>(NULL);
  }

  ClientCapabilities* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientCapabilities>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientCapabilities& from);
  void MergeFrom(const ClientCapabilities& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientCapabilities* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> experimental = 1;
  int experimental_size() const;
  void clear_experimental();
  static const int kExperimentalFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      experimental() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_experimental();

  // .mcp.RootsCapability roots = 2;
  bool has_roots() const;
  void clear_roots();
  static const int kRootsFieldNumber = 2;
  private:
  const ::mcp::RootsCapability& _internal_roots() const;
  public:
  const ::mcp::RootsCapability& roots() const;
  ::mcp::RootsCapability* release_roots();
  ::mcp::RootsCapability* mutable_roots();
  void set_allocated_roots(::mcp::RootsCapability* roots);

  // .mcp.SamplingCapability sampling = 3;
  bool has_sampling() const;
  void clear_sampling();
  static const int kSamplingFieldNumber = 3;
  private:
  const ::mcp::SamplingCapability& _internal_sampling() const;
  public:
  const ::mcp::SamplingCapability& sampling() const;
  ::mcp::SamplingCapability* release_sampling();
  ::mcp::SamplingCapability* mutable_sampling();
  void set_allocated_sampling(::mcp::SamplingCapability* sampling);

  // @@protoc_insertion_point(class_scope:mcp.ClientCapabilities)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ClientCapabilities_ExperimentalEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > experimental_;
  ::mcp::RootsCapability* roots_;
  ::mcp::SamplingCapability* sampling_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerCapabilities_ExperimentalEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ServerCapabilities_ExperimentalEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ServerCapabilities_ExperimentalEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  ServerCapabilities_ExperimentalEntry_DoNotUse();
  ServerCapabilities_ExperimentalEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ServerCapabilities_ExperimentalEntry_DoNotUse& other);
  static const ServerCapabilities_ExperimentalEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServerCapabilities_ExperimentalEntry_DoNotUse*>(&_ServerCapabilities_ExperimentalEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ServerCapabilities : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ServerCapabilities) */ {
 public:
  ServerCapabilities();
  virtual ~ServerCapabilities();

  ServerCapabilities(const ServerCapabilities& from);

  inline ServerCapabilities& operator=(const ServerCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerCapabilities(ServerCapabilities&& from) noexcept
    : ServerCapabilities() {
    *this = ::std::move(from);
  }

  inline ServerCapabilities& operator=(ServerCapabilities&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerCapabilities& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerCapabilities* internal_default_instance() {
    return reinterpret_cast<const ServerCapabilities*>(
               &_ServerCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ServerCapabilities* other);
  friend void swap(ServerCapabilities& a, ServerCapabilities& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerCapabilities* New() const final {
    return CreateMaybeMessage<ServerCapabilities>(NULL);
  }

  ServerCapabilities* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerCapabilities>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerCapabilities& from);
  void MergeFrom(const ServerCapabilities& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerCapabilities* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> experimental = 1;
  int experimental_size() const;
  void clear_experimental();
  static const int kExperimentalFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      experimental() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_experimental();

  // .mcp.LoggingCapability logging = 2;
  bool has_logging() const;
  void clear_logging();
  static const int kLoggingFieldNumber = 2;
  private:
  const ::mcp::LoggingCapability& _internal_logging() const;
  public:
  const ::mcp::LoggingCapability& logging() const;
  ::mcp::LoggingCapability* release_logging();
  ::mcp::LoggingCapability* mutable_logging();
  void set_allocated_logging(::mcp::LoggingCapability* logging);

  // .mcp.CompletionsCapability completions = 3;
  bool has_completions() const;
  void clear_completions();
  static const int kCompletionsFieldNumber = 3;
  private:
  const ::mcp::CompletionsCapability& _internal_completions() const;
  public:
  const ::mcp::CompletionsCapability& completions() const;
  ::mcp::CompletionsCapability* release_completions();
  ::mcp::CompletionsCapability* mutable_completions();
  void set_allocated_completions(::mcp::CompletionsCapability* completions);

  // .mcp.PromptsCapability prompts = 4;
  bool has_prompts() const;
  void clear_prompts();
  static const int kPromptsFieldNumber = 4;
  private:
  const ::mcp::PromptsCapability& _internal_prompts() const;
  public:
  const ::mcp::PromptsCapability& prompts() const;
  ::mcp::PromptsCapability* release_prompts();
  ::mcp::PromptsCapability* mutable_prompts();
  void set_allocated_prompts(::mcp::PromptsCapability* prompts);

  // .mcp.ResourcesCapability resources = 5;
  bool has_resources() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 5;
  private:
  const ::mcp::ResourcesCapability& _internal_resources() const;
  public:
  const ::mcp::ResourcesCapability& resources() const;
  ::mcp::ResourcesCapability* release_resources();
  ::mcp::ResourcesCapability* mutable_resources();
  void set_allocated_resources(::mcp::ResourcesCapability* resources);

  // .mcp.ToolsCapability tools = 6;
  bool has_tools() const;
  void clear_tools();
  static const int kToolsFieldNumber = 6;
  private:
  const ::mcp::ToolsCapability& _internal_tools() const;
  public:
  const ::mcp::ToolsCapability& tools() const;
  ::mcp::ToolsCapability* release_tools();
  ::mcp::ToolsCapability* mutable_tools();
  void set_allocated_tools(::mcp::ToolsCapability* tools);

  // @@protoc_insertion_point(class_scope:mcp.ServerCapabilities)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ServerCapabilities_ExperimentalEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > experimental_;
  ::mcp::LoggingCapability* logging_;
  ::mcp::CompletionsCapability* completions_;
  ::mcp::PromptsCapability* prompts_;
  ::mcp::ResourcesCapability* resources_;
  ::mcp::ToolsCapability* tools_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RootsCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RootsCapability) */ {
 public:
  RootsCapability();
  virtual ~RootsCapability();

  RootsCapability(const RootsCapability& from);

  inline RootsCapability& operator=(const RootsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RootsCapability(RootsCapability&& from) noexcept
    : RootsCapability() {
    *this = ::std::move(from);
  }

  inline RootsCapability& operator=(RootsCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RootsCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RootsCapability* internal_default_instance() {
    return reinterpret_cast<const RootsCapability*>(
               &_RootsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(RootsCapability* other);
  friend void swap(RootsCapability& a, RootsCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RootsCapability* New() const final {
    return CreateMaybeMessage<RootsCapability>(NULL);
  }

  RootsCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RootsCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RootsCapability& from);
  void MergeFrom(const RootsCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootsCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool list_changed = 1;
  void clear_list_changed();
  static const int kListChangedFieldNumber = 1;
  bool list_changed() const;
  void set_list_changed(bool value);

  // @@protoc_insertion_point(class_scope:mcp.RootsCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool list_changed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SamplingCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.SamplingCapability) */ {
 public:
  SamplingCapability();
  virtual ~SamplingCapability();

  SamplingCapability(const SamplingCapability& from);

  inline SamplingCapability& operator=(const SamplingCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SamplingCapability(SamplingCapability&& from) noexcept
    : SamplingCapability() {
    *this = ::std::move(from);
  }

  inline SamplingCapability& operator=(SamplingCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SamplingCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SamplingCapability* internal_default_instance() {
    return reinterpret_cast<const SamplingCapability*>(
               &_SamplingCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(SamplingCapability* other);
  friend void swap(SamplingCapability& a, SamplingCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SamplingCapability* New() const final {
    return CreateMaybeMessage<SamplingCapability>(NULL);
  }

  SamplingCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SamplingCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SamplingCapability& from);
  void MergeFrom(const SamplingCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SamplingCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.SamplingCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoggingCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.LoggingCapability) */ {
 public:
  LoggingCapability();
  virtual ~LoggingCapability();

  LoggingCapability(const LoggingCapability& from);

  inline LoggingCapability& operator=(const LoggingCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoggingCapability(LoggingCapability&& from) noexcept
    : LoggingCapability() {
    *this = ::std::move(from);
  }

  inline LoggingCapability& operator=(LoggingCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggingCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoggingCapability* internal_default_instance() {
    return reinterpret_cast<const LoggingCapability*>(
               &_LoggingCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(LoggingCapability* other);
  friend void swap(LoggingCapability& a, LoggingCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoggingCapability* New() const final {
    return CreateMaybeMessage<LoggingCapability>(NULL);
  }

  LoggingCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoggingCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoggingCapability& from);
  void MergeFrom(const LoggingCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggingCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.LoggingCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompletionsCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.CompletionsCapability) */ {
 public:
  CompletionsCapability();
  virtual ~CompletionsCapability();

  CompletionsCapability(const CompletionsCapability& from);

  inline CompletionsCapability& operator=(const CompletionsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompletionsCapability(CompletionsCapability&& from) noexcept
    : CompletionsCapability() {
    *this = ::std::move(from);
  }

  inline CompletionsCapability& operator=(CompletionsCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompletionsCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompletionsCapability* internal_default_instance() {
    return reinterpret_cast<const CompletionsCapability*>(
               &_CompletionsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(CompletionsCapability* other);
  friend void swap(CompletionsCapability& a, CompletionsCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompletionsCapability* New() const final {
    return CreateMaybeMessage<CompletionsCapability>(NULL);
  }

  CompletionsCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CompletionsCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CompletionsCapability& from);
  void MergeFrom(const CompletionsCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionsCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.CompletionsCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PromptsCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.PromptsCapability) */ {
 public:
  PromptsCapability();
  virtual ~PromptsCapability();

  PromptsCapability(const PromptsCapability& from);

  inline PromptsCapability& operator=(const PromptsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PromptsCapability(PromptsCapability&& from) noexcept
    : PromptsCapability() {
    *this = ::std::move(from);
  }

  inline PromptsCapability& operator=(PromptsCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PromptsCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PromptsCapability* internal_default_instance() {
    return reinterpret_cast<const PromptsCapability*>(
               &_PromptsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(PromptsCapability* other);
  friend void swap(PromptsCapability& a, PromptsCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PromptsCapability* New() const final {
    return CreateMaybeMessage<PromptsCapability>(NULL);
  }

  PromptsCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PromptsCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PromptsCapability& from);
  void MergeFrom(const PromptsCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromptsCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool list_changed = 1;
  void clear_list_changed();
  static const int kListChangedFieldNumber = 1;
  bool list_changed() const;
  void set_list_changed(bool value);

  // @@protoc_insertion_point(class_scope:mcp.PromptsCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool list_changed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourcesCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ResourcesCapability) */ {
 public:
  ResourcesCapability();
  virtual ~ResourcesCapability();

  ResourcesCapability(const ResourcesCapability& from);

  inline ResourcesCapability& operator=(const ResourcesCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourcesCapability(ResourcesCapability&& from) noexcept
    : ResourcesCapability() {
    *this = ::std::move(from);
  }

  inline ResourcesCapability& operator=(ResourcesCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourcesCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourcesCapability* internal_default_instance() {
    return reinterpret_cast<const ResourcesCapability*>(
               &_ResourcesCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ResourcesCapability* other);
  friend void swap(ResourcesCapability& a, ResourcesCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourcesCapability* New() const final {
    return CreateMaybeMessage<ResourcesCapability>(NULL);
  }

  ResourcesCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourcesCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResourcesCapability& from);
  void MergeFrom(const ResourcesCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourcesCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool subscribe = 1;
  void clear_subscribe();
  static const int kSubscribeFieldNumber = 1;
  bool subscribe() const;
  void set_subscribe(bool value);

  // bool list_changed = 2;
  void clear_list_changed();
  static const int kListChangedFieldNumber = 2;
  bool list_changed() const;
  void set_list_changed(bool value);

  // @@protoc_insertion_point(class_scope:mcp.ResourcesCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool subscribe_;
  bool list_changed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ToolsCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ToolsCapability) */ {
 public:
  ToolsCapability();
  virtual ~ToolsCapability();

  ToolsCapability(const ToolsCapability& from);

  inline ToolsCapability& operator=(const ToolsCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ToolsCapability(ToolsCapability&& from) noexcept
    : ToolsCapability() {
    *this = ::std::move(from);
  }

  inline ToolsCapability& operator=(ToolsCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ToolsCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ToolsCapability* internal_default_instance() {
    return reinterpret_cast<const ToolsCapability*>(
               &_ToolsCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ToolsCapability* other);
  friend void swap(ToolsCapability& a, ToolsCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ToolsCapability* New() const final {
    return CreateMaybeMessage<ToolsCapability>(NULL);
  }

  ToolsCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ToolsCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ToolsCapability& from);
  void MergeFrom(const ToolsCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolsCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool list_changed = 1;
  void clear_list_changed();
  static const int kListChangedFieldNumber = 1;
  bool list_changed() const;
  void set_list_changed(bool value);

  // @@protoc_insertion_point(class_scope:mcp.ToolsCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool list_changed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Resource) */ {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(Resource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Resource* other);
  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource* New() const final {
    return CreateMaybeMessage<Resource>(NULL);
  }

  Resource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string mime_type = 4;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 4;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mime_type(::std::string&& value);
  #endif
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // .mcp.Annotations annotations = 5;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 5;
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  public:
  const ::mcp::Annotations& annotations() const;
  ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);

  // int64 size = 6;
  void clear_size();
  static const int kSizeFieldNumber = 6;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mcp.Resource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::mcp::Annotations* annotations_;
  ::google::protobuf::int64 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourceTemplate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ResourceTemplate) */ {
 public:
  ResourceTemplate();
  virtual ~ResourceTemplate();

  ResourceTemplate(const ResourceTemplate& from);

  inline ResourceTemplate& operator=(const ResourceTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceTemplate(ResourceTemplate&& from) noexcept
    : ResourceTemplate() {
    *this = ::std::move(from);
  }

  inline ResourceTemplate& operator=(ResourceTemplate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceTemplate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceTemplate* internal_default_instance() {
    return reinterpret_cast<const ResourceTemplate*>(
               &_ResourceTemplate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(ResourceTemplate* other);
  friend void swap(ResourceTemplate& a, ResourceTemplate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceTemplate* New() const final {
    return CreateMaybeMessage<ResourceTemplate>(NULL);
  }

  ResourceTemplate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourceTemplate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResourceTemplate& from);
  void MergeFrom(const ResourceTemplate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceTemplate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri_template = 1;
  void clear_uri_template();
  static const int kUriTemplateFieldNumber = 1;
  const ::std::string& uri_template() const;
  void set_uri_template(const ::std::string& value);
  #if LANG_CXX11
  void set_uri_template(::std::string&& value);
  #endif
  void set_uri_template(const char* value);
  void set_uri_template(const char* value, size_t size);
  ::std::string* mutable_uri_template();
  ::std::string* release_uri_template();
  void set_allocated_uri_template(::std::string* uri_template);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string mime_type = 4;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 4;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mime_type(::std::string&& value);
  #endif
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // .mcp.Annotations annotations = 5;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 5;
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  public:
  const ::mcp::Annotations& annotations() const;
  ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);

  // @@protoc_insertion_point(class_scope:mcp.ResourceTemplate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_template_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::mcp::Annotations* annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourceContents : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ResourceContents) */ {
 public:
  ResourceContents();
  virtual ~ResourceContents();

  ResourceContents(const ResourceContents& from);

  inline ResourceContents& operator=(const ResourceContents& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceContents(ResourceContents&& from) noexcept
    : ResourceContents() {
    *this = ::std::move(from);
  }

  inline ResourceContents& operator=(ResourceContents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceContents& default_instance();

  enum ContentCase {
    kText = 3,
    kBlob = 4,
    CONTENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceContents* internal_default_instance() {
    return reinterpret_cast<const ResourceContents*>(
               &_ResourceContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ResourceContents* other);
  friend void swap(ResourceContents& a, ResourceContents& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceContents* New() const final {
    return CreateMaybeMessage<ResourceContents>(NULL);
  }

  ResourceContents* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourceContents>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResourceContents& from);
  void MergeFrom(const ResourceContents& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceContents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // string mime_type = 2;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 2;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mime_type(::std::string&& value);
  #endif
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // .mcp.TextResourceContents text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  private:
  const ::mcp::TextResourceContents& _internal_text() const;
  public:
  const ::mcp::TextResourceContents& text() const;
  ::mcp::TextResourceContents* release_text();
  ::mcp::TextResourceContents* mutable_text();
  void set_allocated_text(::mcp::TextResourceContents* text);

  // .mcp.BlobResourceContents blob = 4;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 4;
  private:
  const ::mcp::BlobResourceContents& _internal_blob() const;
  public:
  const ::mcp::BlobResourceContents& blob() const;
  ::mcp::BlobResourceContents* release_blob();
  ::mcp::BlobResourceContents* mutable_blob();
  void set_allocated_blob(::mcp::BlobResourceContents* blob);

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:mcp.ResourceContents)
 private:
  void set_has_text();
  void set_has_blob();

  inline bool has_content() const;
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  union ContentUnion {
    ContentUnion() {}
    ::mcp::TextResourceContents* text_;
    ::mcp::BlobResourceContents* blob_;
  } content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextResourceContents : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.TextResourceContents) */ {
 public:
  TextResourceContents();
  virtual ~TextResourceContents();

  TextResourceContents(const TextResourceContents& from);

  inline TextResourceContents& operator=(const TextResourceContents& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextResourceContents(TextResourceContents&& from) noexcept
    : TextResourceContents() {
    *this = ::std::move(from);
  }

  inline TextResourceContents& operator=(TextResourceContents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TextResourceContents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextResourceContents* internal_default_instance() {
    return reinterpret_cast<const TextResourceContents*>(
               &_TextResourceContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(TextResourceContents* other);
  friend void swap(TextResourceContents& a, TextResourceContents& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextResourceContents* New() const final {
    return CreateMaybeMessage<TextResourceContents>(NULL);
  }

  TextResourceContents* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextResourceContents>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextResourceContents& from);
  void MergeFrom(const TextResourceContents& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextResourceContents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:mcp.TextResourceContents)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlobResourceContents : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.BlobResourceContents) */ {
 public:
  BlobResourceContents();
  virtual ~BlobResourceContents();

  BlobResourceContents(const BlobResourceContents& from);

  inline BlobResourceContents& operator=(const BlobResourceContents& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlobResourceContents(BlobResourceContents&& from) noexcept
    : BlobResourceContents() {
    *this = ::std::move(from);
  }

  inline BlobResourceContents& operator=(BlobResourceContents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobResourceContents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobResourceContents* internal_default_instance() {
    return reinterpret_cast<const BlobResourceContents*>(
               &_BlobResourceContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(BlobResourceContents* other);
  friend void swap(BlobResourceContents& a, BlobResourceContents& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlobResourceContents* New() const final {
    return CreateMaybeMessage<BlobResourceContents>(NULL);
  }

  BlobResourceContents* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlobResourceContents>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlobResourceContents& from);
  void MergeFrom(const BlobResourceContents& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobResourceContents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes blob = 1;
  void clear_blob();
  static const int kBlobFieldNumber = 1;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // @@protoc_insertion_point(class_scope:mcp.BlobResourceContents)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tool : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Tool) */ {
 public:
  Tool();
  virtual ~Tool();

  Tool(const Tool& from);

  inline Tool& operator=(const Tool& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tool(Tool&& from) noexcept
    : Tool() {
    *this = ::std::move(from);
  }

  inline Tool& operator=(Tool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tool& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tool* internal_default_instance() {
    return reinterpret_cast<const Tool*>(
               &_Tool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(Tool* other);
  friend void swap(Tool& a, Tool& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tool* New() const final {
    return CreateMaybeMessage<Tool>(NULL);
  }

  Tool* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tool>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tool& from);
  void MergeFrom(const Tool& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .mcp.InputSchema input_schema = 3;
  bool has_input_schema() const;
  void clear_input_schema();
  static const int kInputSchemaFieldNumber = 3;
  private:
  const ::mcp::InputSchema& _internal_input_schema() const;
  public:
  const ::mcp::InputSchema& input_schema() const;
  ::mcp::InputSchema* release_input_schema();
  ::mcp::InputSchema* mutable_input_schema();
  void set_allocated_input_schema(::mcp::InputSchema* input_schema);

  // .mcp.ToolAnnotations annotations = 4;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 4;
  private:
  const ::mcp::ToolAnnotations& _internal_annotations() const;
  public:
  const ::mcp::ToolAnnotations& annotations() const;
  ::mcp::ToolAnnotations* release_annotations();
  ::mcp::ToolAnnotations* mutable_annotations();
  void set_allocated_annotations(::mcp::ToolAnnotations* annotations);

  // @@protoc_insertion_point(class_scope:mcp.Tool)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::mcp::InputSchema* input_schema_;
  ::mcp::ToolAnnotations* annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InputSchema_PropertiesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<InputSchema_PropertiesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<InputSchema_PropertiesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  InputSchema_PropertiesEntry_DoNotUse();
  InputSchema_PropertiesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const InputSchema_PropertiesEntry_DoNotUse& other);
  static const InputSchema_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InputSchema_PropertiesEntry_DoNotUse*>(&_InputSchema_PropertiesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class InputSchema : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.InputSchema) */ {
 public:
  InputSchema();
  virtual ~InputSchema();

  InputSchema(const InputSchema& from);

  inline InputSchema& operator=(const InputSchema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputSchema(InputSchema&& from) noexcept
    : InputSchema() {
    *this = ::std::move(from);
  }

  inline InputSchema& operator=(InputSchema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputSchema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputSchema* internal_default_instance() {
    return reinterpret_cast<const InputSchema*>(
               &_InputSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(InputSchema* other);
  friend void swap(InputSchema& a, InputSchema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputSchema* New() const final {
    return CreateMaybeMessage<InputSchema>(NULL);
  }

  InputSchema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InputSchema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InputSchema& from);
  void MergeFrom(const InputSchema& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputSchema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> properties = 2;
  int properties_size() const;
  void clear_properties();
  static const int kPropertiesFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      properties() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_properties();

  // repeated string required = 3;
  int required_size() const;
  void clear_required();
  static const int kRequiredFieldNumber = 3;
  const ::std::string& required(int index) const;
  ::std::string* mutable_required(int index);
  void set_required(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_required(int index, ::std::string&& value);
  #endif
  void set_required(int index, const char* value);
  void set_required(int index, const char* value, size_t size);
  ::std::string* add_required();
  void add_required(const ::std::string& value);
  #if LANG_CXX11
  void add_required(::std::string&& value);
  #endif
  void add_required(const char* value);
  void add_required(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& required() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_required();

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:mcp.InputSchema)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      InputSchema_PropertiesEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > properties_;
  ::google::protobuf::RepeatedPtrField< ::std::string> required_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ToolAnnotations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ToolAnnotations) */ {
 public:
  ToolAnnotations();
  virtual ~ToolAnnotations();

  ToolAnnotations(const ToolAnnotations& from);

  inline ToolAnnotations& operator=(const ToolAnnotations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ToolAnnotations(ToolAnnotations&& from) noexcept
    : ToolAnnotations() {
    *this = ::std::move(from);
  }

  inline ToolAnnotations& operator=(ToolAnnotations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ToolAnnotations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ToolAnnotations* internal_default_instance() {
    return reinterpret_cast<const ToolAnnotations*>(
               &_ToolAnnotations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(ToolAnnotations* other);
  friend void swap(ToolAnnotations& a, ToolAnnotations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ToolAnnotations* New() const final {
    return CreateMaybeMessage<ToolAnnotations>(NULL);
  }

  ToolAnnotations* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ToolAnnotations>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ToolAnnotations& from);
  void MergeFrom(const ToolAnnotations& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolAnnotations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string title = 1;
  void clear_title();
  static const int kTitleFieldNumber = 1;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // bool read_only_hint = 2;
  void clear_read_only_hint();
  static const int kReadOnlyHintFieldNumber = 2;
  bool read_only_hint() const;
  void set_read_only_hint(bool value);

  // bool destructive_hint = 3;
  void clear_destructive_hint();
  static const int kDestructiveHintFieldNumber = 3;
  bool destructive_hint() const;
  void set_destructive_hint(bool value);

  // bool idempotent_hint = 4;
  void clear_idempotent_hint();
  static const int kIdempotentHintFieldNumber = 4;
  bool idempotent_hint() const;
  void set_idempotent_hint(bool value);

  // bool open_world_hint = 5;
  void clear_open_world_hint();
  static const int kOpenWorldHintFieldNumber = 5;
  bool open_world_hint() const;
  void set_open_world_hint(bool value);

  // @@protoc_insertion_point(class_scope:mcp.ToolAnnotations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  bool read_only_hint_;
  bool destructive_hint_;
  bool idempotent_hint_;
  bool open_world_hint_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Annotations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Annotations) */ {
 public:
  Annotations();
  virtual ~Annotations();

  Annotations(const Annotations& from);

  inline Annotations& operator=(const Annotations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Annotations(Annotations&& from) noexcept
    : Annotations() {
    *this = ::std::move(from);
  }

  inline Annotations& operator=(Annotations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Annotations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Annotations* internal_default_instance() {
    return reinterpret_cast<const Annotations*>(
               &_Annotations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(Annotations* other);
  friend void swap(Annotations& a, Annotations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Annotations* New() const final {
    return CreateMaybeMessage<Annotations>(NULL);
  }

  Annotations* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Annotations>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Annotations& from);
  void MergeFrom(const Annotations& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Annotations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.Role audience = 1;
  int audience_size() const;
  void clear_audience();
  static const int kAudienceFieldNumber = 1;
  ::mcp::Role audience(int index) const;
  void set_audience(int index, ::mcp::Role value);
  void add_audience(::mcp::Role value);
  const ::google::protobuf::RepeatedField<int>& audience() const;
  ::google::protobuf::RepeatedField<int>* mutable_audience();

  // float priority = 2;
  void clear_priority();
  static const int kPriorityFieldNumber = 2;
  float priority() const;
  void set_priority(float value);

  // @@protoc_insertion_point(class_scope:mcp.Annotations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> audience_;
  mutable int _audience_cached_byte_size_;
  float priority_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.TextContent) */ {
 public:
  TextContent();
  virtual ~TextContent();

  TextContent(const TextContent& from);

  inline TextContent& operator=(const TextContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextContent(TextContent&& from) noexcept
    : TextContent() {
    *this = ::std::move(from);
  }

  inline TextContent& operator=(TextContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TextContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextContent* internal_default_instance() {
    return reinterpret_cast<const TextContent*>(
               &_TextContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(TextContent* other);
  friend void swap(TextContent& a, TextContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextContent* New() const final {
    return CreateMaybeMessage<TextContent>(NULL);
  }

  TextContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextContent& from);
  void MergeFrom(const TextContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .mcp.Annotations annotations = 3;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 3;
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  public:
  const ::mcp::Annotations& annotations() const;
  ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);

  // @@protoc_insertion_point(class_scope:mcp.TextContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::mcp::Annotations* annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ImageContent) */ {
 public:
  ImageContent();
  virtual ~ImageContent();

  ImageContent(const ImageContent& from);

  inline ImageContent& operator=(const ImageContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageContent(ImageContent&& from) noexcept
    : ImageContent() {
    *this = ::std::move(from);
  }

  inline ImageContent& operator=(ImageContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageContent* internal_default_instance() {
    return reinterpret_cast<const ImageContent*>(
               &_ImageContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(ImageContent* other);
  friend void swap(ImageContent& a, ImageContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageContent* New() const final {
    return CreateMaybeMessage<ImageContent>(NULL);
  }

  ImageContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImageContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImageContent& from);
  void MergeFrom(const ImageContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string mime_type = 3;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 3;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mime_type(::std::string&& value);
  #endif
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // .mcp.Annotations annotations = 4;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 4;
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  public:
  const ::mcp::Annotations& annotations() const;
  ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);

  // @@protoc_insertion_point(class_scope:mcp.ImageContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::mcp::Annotations* annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.AudioContent) */ {
 public:
  AudioContent();
  virtual ~AudioContent();

  AudioContent(const AudioContent& from);

  inline AudioContent& operator=(const AudioContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AudioContent(AudioContent&& from) noexcept
    : AudioContent() {
    *this = ::std::move(from);
  }

  inline AudioContent& operator=(AudioContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioContent* internal_default_instance() {
    return reinterpret_cast<const AudioContent*>(
               &_AudioContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(AudioContent* other);
  friend void swap(AudioContent& a, AudioContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AudioContent* New() const final {
    return CreateMaybeMessage<AudioContent>(NULL);
  }

  AudioContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AudioContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AudioContent& from);
  void MergeFrom(const AudioContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string mime_type = 3;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 3;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mime_type(::std::string&& value);
  #endif
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // .mcp.Annotations annotations = 4;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 4;
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  public:
  const ::mcp::Annotations& annotations() const;
  ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);

  // @@protoc_insertion_point(class_scope:mcp.AudioContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::mcp::Annotations* annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelPreferences : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ModelPreferences) */ {
 public:
  ModelPreferences();
  virtual ~ModelPreferences();

  ModelPreferences(const ModelPreferences& from);

  inline ModelPreferences& operator=(const ModelPreferences& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelPreferences(ModelPreferences&& from) noexcept
    : ModelPreferences() {
    *this = ::std::move(from);
  }

  inline ModelPreferences& operator=(ModelPreferences&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelPreferences& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelPreferences* internal_default_instance() {
    return reinterpret_cast<const ModelPreferences*>(
               &_ModelPreferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(ModelPreferences* other);
  friend void swap(ModelPreferences& a, ModelPreferences& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelPreferences* New() const final {
    return CreateMaybeMessage<ModelPreferences>(NULL);
  }

  ModelPreferences* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModelPreferences>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModelPreferences& from);
  void MergeFrom(const ModelPreferences& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelPreferences* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.ModelHint hints = 1;
  int hints_size() const;
  void clear_hints();
  static const int kHintsFieldNumber = 1;
  ::mcp::ModelHint* mutable_hints(int index);
  ::google::protobuf::RepeatedPtrField< ::mcp::ModelHint >*
      mutable_hints();
  const ::mcp::ModelHint& hints(int index) const;
  ::mcp::ModelHint* add_hints();
  const ::google::protobuf::RepeatedPtrField< ::mcp::ModelHint >&
      hints() const;

  // float cost_priority = 2;
  void clear_cost_priority();
  static const int kCostPriorityFieldNumber = 2;
  float cost_priority() const;
  void set_cost_priority(float value);

  // float speed_priority = 3;
  void clear_speed_priority();
  static const int kSpeedPriorityFieldNumber = 3;
  float speed_priority() const;
  void set_speed_priority(float value);

  // float intelligence_priority = 4;
  void clear_intelligence_priority();
  static const int kIntelligencePriorityFieldNumber = 4;
  float intelligence_priority() const;
  void set_intelligence_priority(float value);

  // @@protoc_insertion_point(class_scope:mcp.ModelPreferences)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mcp::ModelHint > hints_;
  float cost_priority_;
  float speed_priority_;
  float intelligence_priority_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelHint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ModelHint) */ {
 public:
  ModelHint();
  virtual ~ModelHint();

  ModelHint(const ModelHint& from);

  inline ModelHint& operator=(const ModelHint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelHint(ModelHint&& from) noexcept
    : ModelHint() {
    *this = ::std::move(from);
  }

  inline ModelHint& operator=(ModelHint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelHint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelHint* internal_default_instance() {
    return reinterpret_cast<const ModelHint*>(
               &_ModelHint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(ModelHint* other);
  friend void swap(ModelHint& a, ModelHint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelHint* New() const final {
    return CreateMaybeMessage<ModelHint>(NULL);
  }

  ModelHint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModelHint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModelHint& from);
  void MergeFrom(const ModelHint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelHint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mcp.ModelHint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourceReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ResourceReference) */ {
 public:
  ResourceReference();
  virtual ~ResourceReference();

  ResourceReference(const ResourceReference& from);

  inline ResourceReference& operator=(const ResourceReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceReference(ResourceReference&& from) noexcept
    : ResourceReference() {
    *this = ::std::move(from);
  }

  inline ResourceReference& operator=(ResourceReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceReference* internal_default_instance() {
    return reinterpret_cast<const ResourceReference*>(
               &_ResourceReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(ResourceReference* other);
  friend void swap(ResourceReference& a, ResourceReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceReference* New() const final {
    return CreateMaybeMessage<ResourceReference>(NULL);
  }

  ResourceReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourceReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResourceReference& from);
  void MergeFrom(const ResourceReference& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string uri = 2;
  void clear_uri();
  static const int kUriFieldNumber = 2;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // @@protoc_insertion_point(class_scope:mcp.ResourceReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PromptReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.PromptReference) */ {
 public:
  PromptReference();
  virtual ~PromptReference();

  PromptReference(const PromptReference& from);

  inline PromptReference& operator=(const PromptReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PromptReference(PromptReference&& from) noexcept
    : PromptReference() {
    *this = ::std::move(from);
  }

  inline PromptReference& operator=(PromptReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PromptReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PromptReference* internal_default_instance() {
    return reinterpret_cast<const PromptReference*>(
               &_PromptReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(PromptReference* other);
  friend void swap(PromptReference& a, PromptReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PromptReference* New() const final {
    return CreateMaybeMessage<PromptReference>(NULL);
  }

  PromptReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PromptReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PromptReference& from);
  void MergeFrom(const PromptReference& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromptReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mcp.PromptReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Root : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Root) */ {
 public:
  Root();
  virtual ~Root();

  Root(const Root& from);

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Root(Root&& from) noexcept
    : Root() {
    *this = ::std::move(from);
  }

  inline Root& operator=(Root&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Root& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Root* internal_default_instance() {
    return reinterpret_cast<const Root*>(
               &_Root_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(Root* other);
  friend void swap(Root& a, Root& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Root* New() const final {
    return CreateMaybeMessage<Root>(NULL);
  }

  Root* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Root>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Root& from);
  void MergeFrom(const Root& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Root* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mcp.Root)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitializeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.InitializeRequest) */ {
 public:
  InitializeRequest();
  virtual ~InitializeRequest();

  InitializeRequest(const InitializeRequest& from);

  inline InitializeRequest& operator=(const InitializeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitializeRequest(InitializeRequest&& from) noexcept
    : InitializeRequest() {
    *this = ::std::move(from);
  }

  inline InitializeRequest& operator=(InitializeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeRequest* internal_default_instance() {
    return reinterpret_cast<const InitializeRequest*>(
               &_InitializeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(InitializeRequest* other);
  friend void swap(InitializeRequest& a, InitializeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitializeRequest* New() const final {
    return CreateMaybeMessage<InitializeRequest>(NULL);
  }

  InitializeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitializeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitializeRequest& from);
  void MergeFrom(const InitializeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // .mcp.InitializeParams params = 2;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  private:
  const ::mcp::InitializeParams& _internal_params() const;
  public:
  const ::mcp::InitializeParams& params() const;
  ::mcp::InitializeParams* release_params();
  ::mcp::InitializeParams* mutable_params();
  void set_allocated_params(::mcp::InitializeParams* params);

  // @@protoc_insertion_point(class_scope:mcp.InitializeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::mcp::InitializeParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitializeParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.InitializeParams) */ {
 public:
  InitializeParams();
  virtual ~InitializeParams();

  InitializeParams(const InitializeParams& from);

  inline InitializeParams& operator=(const InitializeParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitializeParams(InitializeParams&& from) noexcept
    : InitializeParams() {
    *this = ::std::move(from);
  }

  inline InitializeParams& operator=(InitializeParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeParams* internal_default_instance() {
    return reinterpret_cast<const InitializeParams*>(
               &_InitializeParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(InitializeParams* other);
  friend void swap(InitializeParams& a, InitializeParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitializeParams* New() const final {
    return CreateMaybeMessage<InitializeParams>(NULL);
  }

  InitializeParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitializeParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitializeParams& from);
  void MergeFrom(const InitializeParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string protocol_version = 1;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  const ::std::string& protocol_version() const;
  void set_protocol_version(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_version(::std::string&& value);
  #endif
  void set_protocol_version(const char* value);
  void set_protocol_version(const char* value, size_t size);
  ::std::string* mutable_protocol_version();
  ::std::string* release_protocol_version();
  void set_allocated_protocol_version(::std::string* protocol_version);

  // .mcp.ClientCapabilities capabilities = 2;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 2;
  private:
  const ::mcp::ClientCapabilities& _internal_capabilities() const;
  public:
  const ::mcp::ClientCapabilities& capabilities() const;
  ::mcp::ClientCapabilities* release_capabilities();
  ::mcp::ClientCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ClientCapabilities* capabilities);

  // .mcp.Implementation client_info = 3;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 3;
  private:
  const ::mcp::Implementation& _internal_client_info() const;
  public:
  const ::mcp::Implementation& client_info() const;
  ::mcp::Implementation* release_client_info();
  ::mcp::Implementation* mutable_client_info();
  void set_allocated_client_info(::mcp::Implementation* client_info);

  // @@protoc_insertion_point(class_scope:mcp.InitializeParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr protocol_version_;
  ::mcp::ClientCapabilities* capabilities_;
  ::mcp::Implementation* client_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitializeResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.InitializeResult) */ {
 public:
  InitializeResult();
  virtual ~InitializeResult();

  InitializeResult(const InitializeResult& from);

  inline InitializeResult& operator=(const InitializeResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitializeResult(InitializeResult&& from) noexcept
    : InitializeResult() {
    *this = ::std::move(from);
  }

  inline InitializeResult& operator=(InitializeResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeResult* internal_default_instance() {
    return reinterpret_cast<const InitializeResult*>(
               &_InitializeResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(InitializeResult* other);
  friend void swap(InitializeResult& a, InitializeResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitializeResult* New() const final {
    return CreateMaybeMessage<InitializeResult>(NULL);
  }

  InitializeResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitializeResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitializeResult& from);
  void MergeFrom(const InitializeResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string protocol_version = 1;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  const ::std::string& protocol_version() const;
  void set_protocol_version(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_version(::std::string&& value);
  #endif
  void set_protocol_version(const char* value);
  void set_protocol_version(const char* value, size_t size);
  ::std::string* mutable_protocol_version();
  ::std::string* release_protocol_version();
  void set_allocated_protocol_version(::std::string* protocol_version);

  // string instructions = 4;
  void clear_instructions();
  static const int kInstructionsFieldNumber = 4;
  const ::std::string& instructions() const;
  void set_instructions(const ::std::string& value);
  #if LANG_CXX11
  void set_instructions(::std::string&& value);
  #endif
  void set_instructions(const char* value);
  void set_instructions(const char* value, size_t size);
  ::std::string* mutable_instructions();
  ::std::string* release_instructions();
  void set_allocated_instructions(::std::string* instructions);

  // .mcp.ServerCapabilities capabilities = 2;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 2;
  private:
  const ::mcp::ServerCapabilities& _internal_capabilities() const;
  public:
  const ::mcp::ServerCapabilities& capabilities() const;
  ::mcp::ServerCapabilities* release_capabilities();
  ::mcp::ServerCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ServerCapabilities* capabilities);

  // .mcp.Implementation server_info = 3;
  bool has_server_info() const;
  void clear_server_info();
  static const int kServerInfoFieldNumber = 3;
  private:
  const ::mcp::Implementation& _internal_server_info() const;
  public:
  const ::mcp::Implementation& server_info() const;
  ::mcp::Implementation* release_server_info();
  ::mcp::Implementation* mutable_server_info();
  void set_allocated_server_info(::mcp::Implementation* server_info);

  // @@protoc_insertion_point(class_scope:mcp.InitializeResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr protocol_version_;
  ::google::protobuf::internal::ArenaStringPtr instructions_;
  ::mcp::ServerCapabilities* capabilities_;
  ::mcp::Implementation* server_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListResourcesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ListResourcesRequest) */ {
 public:
  ListResourcesRequest();
  virtual ~ListResourcesRequest();

  ListResourcesRequest(const ListResourcesRequest& from);

  inline ListResourcesRequest& operator=(const ListResourcesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListResourcesRequest(ListResourcesRequest&& from) noexcept
    : ListResourcesRequest() {
    *this = ::std::move(from);
  }

  inline ListResourcesRequest& operator=(ListResourcesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListResourcesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListResourcesRequest* internal_default_instance() {
    return reinterpret_cast<const ListResourcesRequest*>(
               &_ListResourcesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(ListResourcesRequest* other);
  friend void swap(ListResourcesRequest& a, ListResourcesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListResourcesRequest* New() const final {
    return CreateMaybeMessage<ListResourcesRequest>(NULL);
  }

  ListResourcesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListResourcesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListResourcesRequest& from);
  void MergeFrom(const ListResourcesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResourcesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // .mcp.PaginatedParams params = 2;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  private:
  const ::mcp::PaginatedParams& _internal_params() const;
  public:
  const ::mcp::PaginatedParams& params() const;
  ::mcp::PaginatedParams* release_params();
  ::mcp::PaginatedParams* mutable_params();
  void set_allocated_params(::mcp::PaginatedParams* params);

  // @@protoc_insertion_point(class_scope:mcp.ListResourcesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::mcp::PaginatedParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListResourcesResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ListResourcesResult) */ {
 public:
  ListResourcesResult();
  virtual ~ListResourcesResult();

  ListResourcesResult(const ListResourcesResult& from);

  inline ListResourcesResult& operator=(const ListResourcesResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListResourcesResult(ListResourcesResult&& from) noexcept
    : ListResourcesResult() {
    *this = ::std::move(from);
  }

  inline ListResourcesResult& operator=(ListResourcesResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListResourcesResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListResourcesResult* internal_default_instance() {
    return reinterpret_cast<const ListResourcesResult*>(
               &_ListResourcesResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(ListResourcesResult* other);
  friend void swap(ListResourcesResult& a, ListResourcesResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListResourcesResult* New() const final {
    return CreateMaybeMessage<ListResourcesResult>(NULL);
  }

  ListResourcesResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListResourcesResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListResourcesResult& from);
  void MergeFrom(const ListResourcesResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResourcesResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.Resource resources = 1;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 1;
  ::mcp::Resource* mutable_resources(int index);
  ::google::protobuf::RepeatedPtrField< ::mcp::Resource >*
      mutable_resources();
  const ::mcp::Resource& resources(int index) const;
  ::mcp::Resource* add_resources();
  const ::google::protobuf::RepeatedPtrField< ::mcp::Resource >&
      resources() const;

  // string next_cursor = 2;
  void clear_next_cursor();
  static const int kNextCursorFieldNumber = 2;
  const ::std::string& next_cursor() const;
  void set_next_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_next_cursor(::std::string&& value);
  #endif
  void set_next_cursor(const char* value);
  void set_next_cursor(const char* value, size_t size);
  ::std::string* mutable_next_cursor();
  ::std::string* release_next_cursor();
  void set_allocated_next_cursor(::std::string* next_cursor);

  // @@protoc_insertion_point(class_scope:mcp.ListResourcesResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mcp::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr next_cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadResourceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ReadResourceRequest) */ {
 public:
  ReadResourceRequest();
  virtual ~ReadResourceRequest();

  ReadResourceRequest(const ReadResourceRequest& from);

  inline ReadResourceRequest& operator=(const ReadResourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadResourceRequest(ReadResourceRequest&& from) noexcept
    : ReadResourceRequest() {
    *this = ::std::move(from);
  }

  inline ReadResourceRequest& operator=(ReadResourceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadResourceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadResourceRequest* internal_default_instance() {
    return reinterpret_cast<const ReadResourceRequest*>(
               &_ReadResourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(ReadResourceRequest* other);
  friend void swap(ReadResourceRequest& a, ReadResourceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadResourceRequest* New() const final {
    return CreateMaybeMessage<ReadResourceRequest>(NULL);
  }

  ReadResourceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadResourceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadResourceRequest& from);
  void MergeFrom(const ReadResourceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResourceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // .mcp.ReadResourceParams params = 2;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  private:
  const ::mcp::ReadResourceParams& _internal_params() const;
  public:
  const ::mcp::ReadResourceParams& params() const;
  ::mcp::ReadResourceParams* release_params();
  ::mcp::ReadResourceParams* mutable_params();
  void set_allocated_params(::mcp::ReadResourceParams* params);

  // @@protoc_insertion_point(class_scope:mcp.ReadResourceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::mcp::ReadResourceParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadResourceParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ReadResourceParams) */ {
 public:
  ReadResourceParams();
  virtual ~ReadResourceParams();

  ReadResourceParams(const ReadResourceParams& from);

  inline ReadResourceParams& operator=(const ReadResourceParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadResourceParams(ReadResourceParams&& from) noexcept
    : ReadResourceParams() {
    *this = ::std::move(from);
  }

  inline ReadResourceParams& operator=(ReadResourceParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadResourceParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadResourceParams* internal_default_instance() {
    return reinterpret_cast<const ReadResourceParams*>(
               &_ReadResourceParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(ReadResourceParams* other);
  friend void swap(ReadResourceParams& a, ReadResourceParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadResourceParams* New() const final {
    return CreateMaybeMessage<ReadResourceParams>(NULL);
  }

  ReadResourceParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadResourceParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadResourceParams& from);
  void MergeFrom(const ReadResourceParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResourceParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // @@protoc_insertion_point(class_scope:mcp.ReadResourceParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadResourceResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ReadResourceResult) */ {
 public:
  ReadResourceResult();
  virtual ~ReadResourceResult();

  ReadResourceResult(const ReadResourceResult& from);

  inline ReadResourceResult& operator=(const ReadResourceResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadResourceResult(ReadResourceResult&& from) noexcept
    : ReadResourceResult() {
    *this = ::std::move(from);
  }

  inline ReadResourceResult& operator=(ReadResourceResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadResourceResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadResourceResult* internal_default_instance() {
    return reinterpret_cast<const ReadResourceResult*>(
               &_ReadResourceResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(ReadResourceResult* other);
  friend void swap(ReadResourceResult& a, ReadResourceResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadResourceResult* New() const final {
    return CreateMaybeMessage<ReadResourceResult>(NULL);
  }

  ReadResourceResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadResourceResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadResourceResult& from);
  void MergeFrom(const ReadResourceResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResourceResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.ResourceContents contents = 1;
  int contents_size() const;
  void clear_contents();
  static const int kContentsFieldNumber = 1;
  ::mcp::ResourceContents* mutable_contents(int index);
  ::google::protobuf::RepeatedPtrField< ::mcp::ResourceContents >*
      mutable_contents();
  const ::mcp::ResourceContents& contents(int index) const;
  ::mcp::ResourceContents* add_contents();
  const ::google::protobuf::RepeatedPtrField< ::mcp::ResourceContents >&
      contents() const;

  // @@protoc_insertion_point(class_scope:mcp.ReadResourceResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mcp::ResourceContents > contents_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaginatedParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.PaginatedParams) */ {
 public:
  PaginatedParams();
  virtual ~PaginatedParams();

  PaginatedParams(const PaginatedParams& from);

  inline PaginatedParams& operator=(const PaginatedParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PaginatedParams(PaginatedParams&& from) noexcept
    : PaginatedParams() {
    *this = ::std::move(from);
  }

  inline PaginatedParams& operator=(PaginatedParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PaginatedParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaginatedParams* internal_default_instance() {
    return reinterpret_cast<const PaginatedParams*>(
               &_PaginatedParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(PaginatedParams* other);
  friend void swap(PaginatedParams& a, PaginatedParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PaginatedParams* New() const final {
    return CreateMaybeMessage<PaginatedParams>(NULL);
  }

  PaginatedParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PaginatedParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PaginatedParams& from);
  void MergeFrom(const PaginatedParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginatedParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cursor = 1;
  void clear_cursor();
  static const int kCursorFieldNumber = 1;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_cursor(::std::string&& value);
  #endif
  void set_cursor(const char* value);
  void set_cursor(const char* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:mcp.PaginatedParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JSONRPCMessage

// .mcp.JSONRPCRequest request = 1;
inline bool JSONRPCMessage::has_request() const {
  return message_case() == kRequest;
}
inline void JSONRPCMessage::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void JSONRPCMessage::clear_request() {
  if (has_request()) {
    delete message_.request_;
    clear_has_message();
  }
}
inline const ::mcp::JSONRPCRequest& JSONRPCMessage::_internal_request() const {
  return *message_.request_;
}
inline ::mcp::JSONRPCRequest* JSONRPCMessage::release_request() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.request)
  if (has_request()) {
    clear_has_message();
      ::mcp::JSONRPCRequest* temp = message_.request_;
    message_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::JSONRPCRequest& JSONRPCMessage::request() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.request)
  return has_request()
      ? *message_.request_
      : *reinterpret_cast< ::mcp::JSONRPCRequest*>(&::mcp::_JSONRPCRequest_default_instance_);
}
inline ::mcp::JSONRPCRequest* JSONRPCMessage::mutable_request() {
  if (!has_request()) {
    clear_message();
    set_has_request();
    message_.request_ = CreateMaybeMessage< ::mcp::JSONRPCRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.request)
  return message_.request_;
}

// .mcp.JSONRPCNotification notification = 2;
inline bool JSONRPCMessage::has_notification() const {
  return message_case() == kNotification;
}
inline void JSONRPCMessage::set_has_notification() {
  _oneof_case_[0] = kNotification;
}
inline void JSONRPCMessage::clear_notification() {
  if (has_notification()) {
    delete message_.notification_;
    clear_has_message();
  }
}
inline const ::mcp::JSONRPCNotification& JSONRPCMessage::_internal_notification() const {
  return *message_.notification_;
}
inline ::mcp::JSONRPCNotification* JSONRPCMessage::release_notification() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.notification)
  if (has_notification()) {
    clear_has_message();
      ::mcp::JSONRPCNotification* temp = message_.notification_;
    message_.notification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::JSONRPCNotification& JSONRPCMessage::notification() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.notification)
  return has_notification()
      ? *message_.notification_
      : *reinterpret_cast< ::mcp::JSONRPCNotification*>(&::mcp::_JSONRPCNotification_default_instance_);
}
inline ::mcp::JSONRPCNotification* JSONRPCMessage::mutable_notification() {
  if (!has_notification()) {
    clear_message();
    set_has_notification();
    message_.notification_ = CreateMaybeMessage< ::mcp::JSONRPCNotification >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.notification)
  return message_.notification_;
}

// .mcp.JSONRPCBatchRequest batch_request = 3;
inline bool JSONRPCMessage::has_batch_request() const {
  return message_case() == kBatchRequest;
}
inline void JSONRPCMessage::set_has_batch_request() {
  _oneof_case_[0] = kBatchRequest;
}
inline void JSONRPCMessage::clear_batch_request() {
  if (has_batch_request()) {
    delete message_.batch_request_;
    clear_has_message();
  }
}
inline const ::mcp::JSONRPCBatchRequest& JSONRPCMessage::_internal_batch_request() const {
  return *message_.batch_request_;
}
inline ::mcp::JSONRPCBatchRequest* JSONRPCMessage::release_batch_request() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.batch_request)
  if (has_batch_request()) {
    clear_has_message();
      ::mcp::JSONRPCBatchRequest* temp = message_.batch_request_;
    message_.batch_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::JSONRPCBatchRequest& JSONRPCMessage::batch_request() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.batch_request)
  return has_batch_request()
      ? *message_.batch_request_
      : *reinterpret_cast< ::mcp::JSONRPCBatchRequest*>(&::mcp::_JSONRPCBatchRequest_default_instance_);
}
inline ::mcp::JSONRPCBatchRequest* JSONRPCMessage::mutable_batch_request() {
  if (!has_batch_request()) {
    clear_message();
    set_has_batch_request();
    message_.batch_request_ = CreateMaybeMessage< ::mcp::JSONRPCBatchRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.batch_request)
  return message_.batch_request_;
}

// .mcp.JSONRPCResponse response = 4;
inline bool JSONRPCMessage::has_response() const {
  return message_case() == kResponse;
}
inline void JSONRPCMessage::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void JSONRPCMessage::clear_response() {
  if (has_response()) {
    delete message_.response_;
    clear_has_message();
  }
}
inline const ::mcp::JSONRPCResponse& JSONRPCMessage::_internal_response() const {
  return *message_.response_;
}
inline ::mcp::JSONRPCResponse* JSONRPCMessage::release_response() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.response)
  if (has_response()) {
    clear_has_message();
      ::mcp::JSONRPCResponse* temp = message_.response_;
    message_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::JSONRPCResponse& JSONRPCMessage::response() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.response)
  return has_response()
      ? *message_.response_
      : *reinterpret_cast< ::mcp::JSONRPCResponse*>(&::mcp::_JSONRPCResponse_default_instance_);
}
inline ::mcp::JSONRPCResponse* JSONRPCMessage::mutable_response() {
  if (!has_response()) {
    clear_message();
    set_has_response();
    message_.response_ = CreateMaybeMessage< ::mcp::JSONRPCResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.response)
  return message_.response_;
}

// .mcp.JSONRPCError error = 5;
inline bool JSONRPCMessage::has_error() const {
  return message_case() == kError;
}
inline void JSONRPCMessage::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void JSONRPCMessage::clear_error() {
  if (has_error()) {
    delete message_.error_;
    clear_has_message();
  }
}
inline const ::mcp::JSONRPCError& JSONRPCMessage::_internal_error() const {
  return *message_.error_;
}
inline ::mcp::JSONRPCError* JSONRPCMessage::release_error() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.error)
  if (has_error()) {
    clear_has_message();
      ::mcp::JSONRPCError* temp = message_.error_;
    message_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::JSONRPCError& JSONRPCMessage::error() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.error)
  return has_error()
      ? *message_.error_
      : *reinterpret_cast< ::mcp::JSONRPCError*>(&::mcp::_JSONRPCError_default_instance_);
}
inline ::mcp::JSONRPCError* JSONRPCMessage::mutable_error() {
  if (!has_error()) {
    clear_message();
    set_has_error();
    message_.error_ = CreateMaybeMessage< ::mcp::JSONRPCError >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.error)
  return message_.error_;
}

// .mcp.JSONRPCBatchResponse batch_response = 6;
inline bool JSONRPCMessage::has_batch_response() const {
  return message_case() == kBatchResponse;
}
inline void JSONRPCMessage::set_has_batch_response() {
  _oneof_case_[0] = kBatchResponse;
}
inline void JSONRPCMessage::clear_batch_response() {
  if (has_batch_response()) {
    delete message_.batch_response_;
    clear_has_message();
  }
}
inline const ::mcp::JSONRPCBatchResponse& JSONRPCMessage::_internal_batch_response() const {
  return *message_.batch_response_;
}
inline ::mcp::JSONRPCBatchResponse* JSONRPCMessage::release_batch_response() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCMessage.batch_response)
  if (has_batch_response()) {
    clear_has_message();
      ::mcp::JSONRPCBatchResponse* temp = message_.batch_response_;
    message_.batch_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::JSONRPCBatchResponse& JSONRPCMessage::batch_response() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCMessage.batch_response)
  return has_batch_response()
      ? *message_.batch_response_
      : *reinterpret_cast< ::mcp::JSONRPCBatchResponse*>(&::mcp::_JSONRPCBatchResponse_default_instance_);
}
inline ::mcp::JSONRPCBatchResponse* JSONRPCMessage::mutable_batch_response() {
  if (!has_batch_response()) {
    clear_message();
    set_has_batch_response();
    message_.batch_response_ = CreateMaybeMessage< ::mcp::JSONRPCBatchResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCMessage.batch_response)
  return message_.batch_response_;
}

inline bool JSONRPCMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void JSONRPCMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline JSONRPCMessage::MessageCase JSONRPCMessage::message_case() const {
  return JSONRPCMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// JSONRPCRequest

// string jsonrpc = 1;
inline void JSONRPCRequest::clear_jsonrpc() {
  jsonrpc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCRequest::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.jsonrpc)
  return jsonrpc_.GetNoArena();
}
inline void JSONRPCRequest::set_jsonrpc(const ::std::string& value) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCRequest.jsonrpc)
}
#if LANG_CXX11
inline void JSONRPCRequest::set_jsonrpc(::std::string&& value) {
  
  jsonrpc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCRequest.jsonrpc)
}
#endif
inline void JSONRPCRequest::set_jsonrpc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCRequest.jsonrpc)
}
inline void JSONRPCRequest::set_jsonrpc(const char* value, size_t size) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCRequest.jsonrpc)
}
inline ::std::string* JSONRPCRequest::mutable_jsonrpc() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.jsonrpc)
  return jsonrpc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCRequest::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.jsonrpc)
  
  return jsonrpc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCRequest::set_allocated_jsonrpc(::std::string* jsonrpc) {
  if (jsonrpc != NULL) {
    
  } else {
    
  }
  jsonrpc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jsonrpc);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.jsonrpc)
}

// string id = 2;
inline void JSONRPCRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCRequest::id() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.id)
  return id_.GetNoArena();
}
inline void JSONRPCRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCRequest.id)
}
#if LANG_CXX11
inline void JSONRPCRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCRequest.id)
}
#endif
inline void JSONRPCRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCRequest.id)
}
inline void JSONRPCRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCRequest.id)
}
inline ::std::string* JSONRPCRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCRequest::release_id() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.id)
}

// string method = 3;
inline void JSONRPCRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.method)
  return method_.GetNoArena();
}
inline void JSONRPCRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCRequest.method)
}
#if LANG_CXX11
inline void JSONRPCRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCRequest.method)
}
#endif
inline void JSONRPCRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCRequest.method)
}
inline void JSONRPCRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCRequest.method)
}
inline ::std::string* JSONRPCRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCRequest::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.method)
}

// .mcp.RequestParams params = 4;
inline bool JSONRPCRequest::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void JSONRPCRequest::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::mcp::RequestParams& JSONRPCRequest::_internal_params() const {
  return *params_;
}
inline const ::mcp::RequestParams& JSONRPCRequest::params() const {
  const ::mcp::RequestParams* p = params_;
  // @@protoc_insertion_point(field_get:mcp.JSONRPCRequest.params)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::RequestParams*>(
      &::mcp::_RequestParams_default_instance_);
}
inline ::mcp::RequestParams* JSONRPCRequest::release_params() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCRequest.params)
  
  ::mcp::RequestParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::mcp::RequestParams* JSONRPCRequest::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::RequestParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCRequest.params)
  return params_;
}
inline void JSONRPCRequest::set_allocated_params(::mcp::RequestParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCRequest.params)
}

// -------------------------------------------------------------------

// JSONRPCNotification

// string jsonrpc = 1;
inline void JSONRPCNotification::clear_jsonrpc() {
  jsonrpc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCNotification::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCNotification.jsonrpc)
  return jsonrpc_.GetNoArena();
}
inline void JSONRPCNotification::set_jsonrpc(const ::std::string& value) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCNotification.jsonrpc)
}
#if LANG_CXX11
inline void JSONRPCNotification::set_jsonrpc(::std::string&& value) {
  
  jsonrpc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCNotification.jsonrpc)
}
#endif
inline void JSONRPCNotification::set_jsonrpc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCNotification.jsonrpc)
}
inline void JSONRPCNotification::set_jsonrpc(const char* value, size_t size) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCNotification.jsonrpc)
}
inline ::std::string* JSONRPCNotification::mutable_jsonrpc() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCNotification.jsonrpc)
  return jsonrpc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCNotification::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCNotification.jsonrpc)
  
  return jsonrpc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCNotification::set_allocated_jsonrpc(::std::string* jsonrpc) {
  if (jsonrpc != NULL) {
    
  } else {
    
  }
  jsonrpc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jsonrpc);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCNotification.jsonrpc)
}

// string method = 2;
inline void JSONRPCNotification::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCNotification::method() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCNotification.method)
  return method_.GetNoArena();
}
inline void JSONRPCNotification::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCNotification.method)
}
#if LANG_CXX11
inline void JSONRPCNotification::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCNotification.method)
}
#endif
inline void JSONRPCNotification::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCNotification.method)
}
inline void JSONRPCNotification::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCNotification.method)
}
inline ::std::string* JSONRPCNotification::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCNotification.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCNotification::release_method() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCNotification.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCNotification::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCNotification.method)
}

// .mcp.NotificationParams params = 3;
inline bool JSONRPCNotification::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void JSONRPCNotification::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::mcp::NotificationParams& JSONRPCNotification::_internal_params() const {
  return *params_;
}
inline const ::mcp::NotificationParams& JSONRPCNotification::params() const {
  const ::mcp::NotificationParams* p = params_;
  // @@protoc_insertion_point(field_get:mcp.JSONRPCNotification.params)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::NotificationParams*>(
      &::mcp::_NotificationParams_default_instance_);
}
inline ::mcp::NotificationParams* JSONRPCNotification::release_params() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCNotification.params)
  
  ::mcp::NotificationParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::mcp::NotificationParams* JSONRPCNotification::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::NotificationParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCNotification.params)
  return params_;
}
inline void JSONRPCNotification::set_allocated_params(::mcp::NotificationParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCNotification.params)
}

// -------------------------------------------------------------------

// JSONRPCResponse

// string jsonrpc = 1;
inline void JSONRPCResponse::clear_jsonrpc() {
  jsonrpc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCResponse::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCResponse.jsonrpc)
  return jsonrpc_.GetNoArena();
}
inline void JSONRPCResponse::set_jsonrpc(const ::std::string& value) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCResponse.jsonrpc)
}
#if LANG_CXX11
inline void JSONRPCResponse::set_jsonrpc(::std::string&& value) {
  
  jsonrpc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCResponse.jsonrpc)
}
#endif
inline void JSONRPCResponse::set_jsonrpc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCResponse.jsonrpc)
}
inline void JSONRPCResponse::set_jsonrpc(const char* value, size_t size) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCResponse.jsonrpc)
}
inline ::std::string* JSONRPCResponse::mutable_jsonrpc() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCResponse.jsonrpc)
  return jsonrpc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCResponse::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCResponse.jsonrpc)
  
  return jsonrpc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCResponse::set_allocated_jsonrpc(::std::string* jsonrpc) {
  if (jsonrpc != NULL) {
    
  } else {
    
  }
  jsonrpc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jsonrpc);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCResponse.jsonrpc)
}

// string id = 2;
inline void JSONRPCResponse::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCResponse::id() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCResponse.id)
  return id_.GetNoArena();
}
inline void JSONRPCResponse::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCResponse.id)
}
#if LANG_CXX11
inline void JSONRPCResponse::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCResponse.id)
}
#endif
inline void JSONRPCResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCResponse.id)
}
inline void JSONRPCResponse::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCResponse.id)
}
inline ::std::string* JSONRPCResponse::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCResponse.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCResponse::release_id() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCResponse.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCResponse::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCResponse.id)
}

// .mcp.Result result = 3;
inline bool JSONRPCResponse::has_result() const {
  return this != internal_default_instance() && result_ != NULL;
}
inline void JSONRPCResponse::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) {
    delete result_;
  }
  result_ = NULL;
}
inline const ::mcp::Result& JSONRPCResponse::_internal_result() const {
  return *result_;
}
inline const ::mcp::Result& JSONRPCResponse::result() const {
  const ::mcp::Result* p = result_;
  // @@protoc_insertion_point(field_get:mcp.JSONRPCResponse.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Result*>(
      &::mcp::_Result_default_instance_);
}
inline ::mcp::Result* JSONRPCResponse::release_result() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCResponse.result)
  
  ::mcp::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mcp::Result* JSONRPCResponse::mutable_result() {
  
  if (result_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Result>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCResponse.result)
  return result_;
}
inline void JSONRPCResponse::set_allocated_result(::mcp::Result* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete result_;
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCResponse.result)
}

// -------------------------------------------------------------------

// JSONRPCError

// string jsonrpc = 1;
inline void JSONRPCError::clear_jsonrpc() {
  jsonrpc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCError::jsonrpc() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCError.jsonrpc)
  return jsonrpc_.GetNoArena();
}
inline void JSONRPCError::set_jsonrpc(const ::std::string& value) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCError.jsonrpc)
}
#if LANG_CXX11
inline void JSONRPCError::set_jsonrpc(::std::string&& value) {
  
  jsonrpc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCError.jsonrpc)
}
#endif
inline void JSONRPCError::set_jsonrpc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCError.jsonrpc)
}
inline void JSONRPCError::set_jsonrpc(const char* value, size_t size) {
  
  jsonrpc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCError.jsonrpc)
}
inline ::std::string* JSONRPCError::mutable_jsonrpc() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCError.jsonrpc)
  return jsonrpc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCError::release_jsonrpc() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCError.jsonrpc)
  
  return jsonrpc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCError::set_allocated_jsonrpc(::std::string* jsonrpc) {
  if (jsonrpc != NULL) {
    
  } else {
    
  }
  jsonrpc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jsonrpc);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCError.jsonrpc)
}

// string id = 2;
inline void JSONRPCError::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSONRPCError::id() const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCError.id)
  return id_.GetNoArena();
}
inline void JSONRPCError::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.JSONRPCError.id)
}
#if LANG_CXX11
inline void JSONRPCError::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.JSONRPCError.id)
}
#endif
inline void JSONRPCError::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.JSONRPCError.id)
}
inline void JSONRPCError::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.JSONRPCError.id)
}
inline ::std::string* JSONRPCError::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCError.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSONRPCError::release_id() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCError.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSONRPCError::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCError.id)
}

// .mcp.Error error = 3;
inline bool JSONRPCError::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void JSONRPCError::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::mcp::Error& JSONRPCError::_internal_error() const {
  return *error_;
}
inline const ::mcp::Error& JSONRPCError::error() const {
  const ::mcp::Error* p = error_;
  // @@protoc_insertion_point(field_get:mcp.JSONRPCError.error)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Error*>(
      &::mcp::_Error_default_instance_);
}
inline ::mcp::Error* JSONRPCError::release_error() {
  // @@protoc_insertion_point(field_release:mcp.JSONRPCError.error)
  
  ::mcp::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::mcp::Error* JSONRPCError::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCError.error)
  return error_;
}
inline void JSONRPCError::set_allocated_error(::mcp::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:mcp.JSONRPCError.error)
}

// -------------------------------------------------------------------

// JSONRPCBatchRequest

// repeated .mcp.JSONRPCRequest requests = 1;
inline int JSONRPCBatchRequest::requests_size() const {
  return requests_.size();
}
inline void JSONRPCBatchRequest::clear_requests() {
  requests_.Clear();
}
inline ::mcp::JSONRPCRequest* JSONRPCBatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCBatchRequest.requests)
  return requests_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCRequest >*
JSONRPCBatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:mcp.JSONRPCBatchRequest.requests)
  return &requests_;
}
inline const ::mcp::JSONRPCRequest& JSONRPCBatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCBatchRequest.requests)
  return requests_.Get(index);
}
inline ::mcp::JSONRPCRequest* JSONRPCBatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:mcp.JSONRPCBatchRequest.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCRequest >&
JSONRPCBatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:mcp.JSONRPCBatchRequest.requests)
  return requests_;
}

// -------------------------------------------------------------------

// JSONRPCBatchResponse

// repeated .mcp.JSONRPCResponse responses = 1;
inline int JSONRPCBatchResponse::responses_size() const {
  return responses_.size();
}
inline void JSONRPCBatchResponse::clear_responses() {
  responses_.Clear();
}
inline ::mcp::JSONRPCResponse* JSONRPCBatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.JSONRPCBatchResponse.responses)
  return responses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCResponse >*
JSONRPCBatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:mcp.JSONRPCBatchResponse.responses)
  return &responses_;
}
inline const ::mcp::JSONRPCResponse& JSONRPCBatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:mcp.JSONRPCBatchResponse.responses)
  return responses_.Get(index);
}
inline ::mcp::JSONRPCResponse* JSONRPCBatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:mcp.JSONRPCBatchResponse.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcp::JSONRPCResponse >&
JSONRPCBatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:mcp.JSONRPCBatchResponse.responses)
  return responses_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RequestParams

// .mcp.MetaParams _meta = 1;
inline bool RequestParams::has__meta() const {
  return this != internal_default_instance() && _meta_ != NULL;
}
inline void RequestParams::clear__meta() {
  if (GetArenaNoVirtual() == NULL && _meta_ != NULL) {
    delete _meta_;
  }
  _meta_ = NULL;
}
inline const ::mcp::MetaParams& RequestParams::_internal__meta() const {
  return *_meta_;
}
inline const ::mcp::MetaParams& RequestParams::_meta() const {
  const ::mcp::MetaParams* p = _meta_;
  // @@protoc_insertion_point(field_get:mcp.RequestParams._meta)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::MetaParams*>(
      &::mcp::_MetaParams_default_instance_);
}
inline ::mcp::MetaParams* RequestParams::release__meta() {
  // @@protoc_insertion_point(field_release:mcp.RequestParams._meta)
  
  ::mcp::MetaParams* temp = _meta_;
  _meta_ = NULL;
  return temp;
}
inline ::mcp::MetaParams* RequestParams::mutable__meta() {
  
  if (_meta_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::MetaParams>(GetArenaNoVirtual());
    _meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RequestParams._meta)
  return _meta_;
}
inline void RequestParams::set_allocated__meta(::mcp::MetaParams* _meta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete _meta_;
  }
  if (_meta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      _meta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, _meta, submessage_arena);
    }
    
  } else {
    
  }
  _meta_ = _meta;
  // @@protoc_insertion_point(field_set_allocated:mcp.RequestParams._meta)
}

// map<string, bytes> additional_params = 2;
inline int RequestParams::additional_params_size() const {
  return additional_params_.size();
}
inline void RequestParams::clear_additional_params() {
  additional_params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
RequestParams::additional_params() const {
  // @@protoc_insertion_point(field_map:mcp.RequestParams.additional_params)
  return additional_params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
RequestParams::mutable_additional_params() {
  // @@protoc_insertion_point(field_mutable_map:mcp.RequestParams.additional_params)
  return additional_params_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NotificationParams

// .mcp.MetaParams _meta = 1;
inline bool NotificationParams::has__meta() const {
  return this != internal_default_instance() && _meta_ != NULL;
}
inline void NotificationParams::clear__meta() {
  if (GetArenaNoVirtual() == NULL && _meta_ != NULL) {
    delete _meta_;
  }
  _meta_ = NULL;
}
inline const ::mcp::MetaParams& NotificationParams::_internal__meta() const {
  return *_meta_;
}
inline const ::mcp::MetaParams& NotificationParams::_meta() const {
  const ::mcp::MetaParams* p = _meta_;
  // @@protoc_insertion_point(field_get:mcp.NotificationParams._meta)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::MetaParams*>(
      &::mcp::_MetaParams_default_instance_);
}
inline ::mcp::MetaParams* NotificationParams::release__meta() {
  // @@protoc_insertion_point(field_release:mcp.NotificationParams._meta)
  
  ::mcp::MetaParams* temp = _meta_;
  _meta_ = NULL;
  return temp;
}
inline ::mcp::MetaParams* NotificationParams::mutable__meta() {
  
  if (_meta_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::MetaParams>(GetArenaNoVirtual());
    _meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.NotificationParams._meta)
  return _meta_;
}
inline void NotificationParams::set_allocated__meta(::mcp::MetaParams* _meta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete _meta_;
  }
  if (_meta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      _meta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, _meta, submessage_arena);
    }
    
  } else {
    
  }
  _meta_ = _meta;
  // @@protoc_insertion_point(field_set_allocated:mcp.NotificationParams._meta)
}

// map<string, bytes> additional_params = 2;
inline int NotificationParams::additional_params_size() const {
  return additional_params_.size();
}
inline void NotificationParams::clear_additional_params() {
  additional_params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
NotificationParams::additional_params() const {
  // @@protoc_insertion_point(field_map:mcp.NotificationParams.additional_params)
  return additional_params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
NotificationParams::mutable_additional_params() {
  // @@protoc_insertion_point(field_mutable_map:mcp.NotificationParams.additional_params)
  return additional_params_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaParams

// string progress_token = 1;
inline void MetaParams::clear_progress_token() {
  progress_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MetaParams::progress_token() const {
  // @@protoc_insertion_point(field_get:mcp.MetaParams.progress_token)
  return progress_token_.GetNoArena();
}
inline void MetaParams::set_progress_token(const ::std::string& value) {
  
  progress_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.MetaParams.progress_token)
}
#if LANG_CXX11
inline void MetaParams::set_progress_token(::std::string&& value) {
  
  progress_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.MetaParams.progress_token)
}
#endif
inline void MetaParams::set_progress_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  progress_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.MetaParams.progress_token)
}
inline void MetaParams::set_progress_token(const char* value, size_t size) {
  
  progress_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.MetaParams.progress_token)
}
inline ::std::string* MetaParams::mutable_progress_token() {
  
  // @@protoc_insertion_point(field_mutable:mcp.MetaParams.progress_token)
  return progress_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetaParams::release_progress_token() {
  // @@protoc_insertion_point(field_release:mcp.MetaParams.progress_token)
  
  return progress_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaParams::set_allocated_progress_token(::std::string* progress_token) {
  if (progress_token != NULL) {
    
  } else {
    
  }
  progress_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), progress_token);
  // @@protoc_insertion_point(field_set_allocated:mcp.MetaParams.progress_token)
}

// map<string, bytes> additional_meta = 2;
inline int MetaParams::additional_meta_size() const {
  return additional_meta_.size();
}
inline void MetaParams::clear_additional_meta() {
  additional_meta_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
MetaParams::additional_meta() const {
  // @@protoc_insertion_point(field_map:mcp.MetaParams.additional_meta)
  return additional_meta_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
MetaParams::mutable_additional_meta() {
  // @@protoc_insertion_point(field_mutable_map:mcp.MetaParams.additional_meta)
  return additional_meta_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Result

// .mcp.MetaResult _meta = 1;
inline bool Result::has__meta() const {
  return this != internal_default_instance() && _meta_ != NULL;
}
inline void Result::clear__meta() {
  if (GetArenaNoVirtual() == NULL && _meta_ != NULL) {
    delete _meta_;
  }
  _meta_ = NULL;
}
inline const ::mcp::MetaResult& Result::_internal__meta() const {
  return *_meta_;
}
inline const ::mcp::MetaResult& Result::_meta() const {
  const ::mcp::MetaResult* p = _meta_;
  // @@protoc_insertion_point(field_get:mcp.Result._meta)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::MetaResult*>(
      &::mcp::_MetaResult_default_instance_);
}
inline ::mcp::MetaResult* Result::release__meta() {
  // @@protoc_insertion_point(field_release:mcp.Result._meta)
  
  ::mcp::MetaResult* temp = _meta_;
  _meta_ = NULL;
  return temp;
}
inline ::mcp::MetaResult* Result::mutable__meta() {
  
  if (_meta_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::MetaResult>(GetArenaNoVirtual());
    _meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.Result._meta)
  return _meta_;
}
inline void Result::set_allocated__meta(::mcp::MetaResult* _meta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete _meta_;
  }
  if (_meta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      _meta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, _meta, submessage_arena);
    }
    
  } else {
    
  }
  _meta_ = _meta;
  // @@protoc_insertion_point(field_set_allocated:mcp.Result._meta)
}

// map<string, bytes> additional_result = 2;
inline int Result::additional_result_size() const {
  return additional_result_.size();
}
inline void Result::clear_additional_result() {
  additional_result_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Result::additional_result() const {
  // @@protoc_insertion_point(field_map:mcp.Result.additional_result)
  return additional_result_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Result::mutable_additional_result() {
  // @@protoc_insertion_point(field_mutable_map:mcp.Result.additional_result)
  return additional_result_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaResult

// map<string, bytes> additional_meta = 1;
inline int MetaResult::additional_meta_size() const {
  return additional_meta_.size();
}
inline void MetaResult::clear_additional_meta() {
  additional_meta_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
MetaResult::additional_meta() const {
  // @@protoc_insertion_point(field_map:mcp.MetaResult.additional_meta)
  return additional_meta_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
MetaResult::mutable_additional_meta() {
  // @@protoc_insertion_point(field_mutable_map:mcp.MetaResult.additional_meta)
  return additional_meta_.MutableMap();
}

// -------------------------------------------------------------------

// Error

// int32 code = 1;
inline void Error::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 Error::code() const {
  // @@protoc_insertion_point(field_get:mcp.Error.code)
  return code_;
}
inline void Error::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:mcp.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:mcp.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:mcp.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mcp.Error.message)
}

// bytes data = 3;
inline void Error::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::data() const {
  // @@protoc_insertion_point(field_get:mcp.Error.data)
  return data_.GetNoArena();
}
inline void Error::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Error.data)
}
#if LANG_CXX11
inline void Error::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Error.data)
}
#endif
inline void Error::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Error.data)
}
inline void Error::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Error.data)
}
inline ::std::string* Error::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Error.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_data() {
  // @@protoc_insertion_point(field_release:mcp.Error.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mcp.Error.data)
}

// -------------------------------------------------------------------

// Implementation

// string name = 1;
inline void Implementation::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Implementation::name() const {
  // @@protoc_insertion_point(field_get:mcp.Implementation.name)
  return name_.GetNoArena();
}
inline void Implementation::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Implementation.name)
}
#if LANG_CXX11
inline void Implementation::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Implementation.name)
}
#endif
inline void Implementation::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Implementation.name)
}
inline void Implementation::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Implementation.name)
}
inline ::std::string* Implementation::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Implementation.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Implementation::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Implementation.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Implementation::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.Implementation.name)
}

// string version = 2;
inline void Implementation::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Implementation::version() const {
  // @@protoc_insertion_point(field_get:mcp.Implementation.version)
  return version_.GetNoArena();
}
inline void Implementation::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Implementation.version)
}
#if LANG_CXX11
inline void Implementation::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Implementation.version)
}
#endif
inline void Implementation::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Implementation.version)
}
inline void Implementation::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Implementation.version)
}
inline ::std::string* Implementation::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Implementation.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Implementation::release_version() {
  // @@protoc_insertion_point(field_release:mcp.Implementation.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Implementation::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mcp.Implementation.version)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ClientCapabilities

// map<string, bytes> experimental = 1;
inline int ClientCapabilities::experimental_size() const {
  return experimental_.size();
}
inline void ClientCapabilities::clear_experimental() {
  experimental_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ClientCapabilities::experimental() const {
  // @@protoc_insertion_point(field_map:mcp.ClientCapabilities.experimental)
  return experimental_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ClientCapabilities::mutable_experimental() {
  // @@protoc_insertion_point(field_mutable_map:mcp.ClientCapabilities.experimental)
  return experimental_.MutableMap();
}

// .mcp.RootsCapability roots = 2;
inline bool ClientCapabilities::has_roots() const {
  return this != internal_default_instance() && roots_ != NULL;
}
inline void ClientCapabilities::clear_roots() {
  if (GetArenaNoVirtual() == NULL && roots_ != NULL) {
    delete roots_;
  }
  roots_ = NULL;
}
inline const ::mcp::RootsCapability& ClientCapabilities::_internal_roots() const {
  return *roots_;
}
inline const ::mcp::RootsCapability& ClientCapabilities::roots() const {
  const ::mcp::RootsCapability* p = roots_;
  // @@protoc_insertion_point(field_get:mcp.ClientCapabilities.roots)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::RootsCapability*>(
      &::mcp::_RootsCapability_default_instance_);
}
inline ::mcp::RootsCapability* ClientCapabilities::release_roots() {
  // @@protoc_insertion_point(field_release:mcp.ClientCapabilities.roots)
  
  ::mcp::RootsCapability* temp = roots_;
  roots_ = NULL;
  return temp;
}
inline ::mcp::RootsCapability* ClientCapabilities::mutable_roots() {
  
  if (roots_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::RootsCapability>(GetArenaNoVirtual());
    roots_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ClientCapabilities.roots)
  return roots_;
}
inline void ClientCapabilities::set_allocated_roots(::mcp::RootsCapability* roots) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roots_;
  }
  if (roots) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roots = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roots, submessage_arena);
    }
    
  } else {
    
  }
  roots_ = roots;
  // @@protoc_insertion_point(field_set_allocated:mcp.ClientCapabilities.roots)
}

// .mcp.SamplingCapability sampling = 3;
inline bool ClientCapabilities::has_sampling() const {
  return this != internal_default_instance() && sampling_ != NULL;
}
inline void ClientCapabilities::clear_sampling() {
  if (GetArenaNoVirtual() == NULL && sampling_ != NULL) {
    delete sampling_;
  }
  sampling_ = NULL;
}
inline const ::mcp::SamplingCapability& ClientCapabilities::_internal_sampling() const {
  return *sampling_;
}
inline const ::mcp::SamplingCapability& ClientCapabilities::sampling() const {
  const ::mcp::SamplingCapability* p = sampling_;
  // @@protoc_insertion_point(field_get:mcp.ClientCapabilities.sampling)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::SamplingCapability*>(
      &::mcp::_SamplingCapability_default_instance_);
}
inline ::mcp::SamplingCapability* ClientCapabilities::release_sampling() {
  // @@protoc_insertion_point(field_release:mcp.ClientCapabilities.sampling)
  
  ::mcp::SamplingCapability* temp = sampling_;
  sampling_ = NULL;
  return temp;
}
inline ::mcp::SamplingCapability* ClientCapabilities::mutable_sampling() {
  
  if (sampling_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::SamplingCapability>(GetArenaNoVirtual());
    sampling_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ClientCapabilities.sampling)
  return sampling_;
}
inline void ClientCapabilities::set_allocated_sampling(::mcp::SamplingCapability* sampling) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sampling_;
  }
  if (sampling) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sampling = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sampling, submessage_arena);
    }
    
  } else {
    
  }
  sampling_ = sampling;
  // @@protoc_insertion_point(field_set_allocated:mcp.ClientCapabilities.sampling)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServerCapabilities

// map<string, bytes> experimental = 1;
inline int ServerCapabilities::experimental_size() const {
  return experimental_.size();
}
inline void ServerCapabilities::clear_experimental() {
  experimental_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ServerCapabilities::experimental() const {
  // @@protoc_insertion_point(field_map:mcp.ServerCapabilities.experimental)
  return experimental_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ServerCapabilities::mutable_experimental() {
  // @@protoc_insertion_point(field_mutable_map:mcp.ServerCapabilities.experimental)
  return experimental_.MutableMap();
}

// .mcp.LoggingCapability logging = 2;
inline bool ServerCapabilities::has_logging() const {
  return this != internal_default_instance() && logging_ != NULL;
}
inline void ServerCapabilities::clear_logging() {
  if (GetArenaNoVirtual() == NULL && logging_ != NULL) {
    delete logging_;
  }
  logging_ = NULL;
}
inline const ::mcp::LoggingCapability& ServerCapabilities::_internal_logging() const {
  return *logging_;
}
inline const ::mcp::LoggingCapability& ServerCapabilities::logging() const {
  const ::mcp::LoggingCapability* p = logging_;
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.logging)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::LoggingCapability*>(
      &::mcp::_LoggingCapability_default_instance_);
}
inline ::mcp::LoggingCapability* ServerCapabilities::release_logging() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.logging)
  
  ::mcp::LoggingCapability* temp = logging_;
  logging_ = NULL;
  return temp;
}
inline ::mcp::LoggingCapability* ServerCapabilities::mutable_logging() {
  
  if (logging_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::LoggingCapability>(GetArenaNoVirtual());
    logging_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.logging)
  return logging_;
}
inline void ServerCapabilities::set_allocated_logging(::mcp::LoggingCapability* logging) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete logging_;
  }
  if (logging) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      logging = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logging, submessage_arena);
    }
    
  } else {
    
  }
  logging_ = logging;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.logging)
}

// .mcp.CompletionsCapability completions = 3;
inline bool ServerCapabilities::has_completions() const {
  return this != internal_default_instance() && completions_ != NULL;
}
inline void ServerCapabilities::clear_completions() {
  if (GetArenaNoVirtual() == NULL && completions_ != NULL) {
    delete completions_;
  }
  completions_ = NULL;
}
inline const ::mcp::CompletionsCapability& ServerCapabilities::_internal_completions() const {
  return *completions_;
}
inline const ::mcp::CompletionsCapability& ServerCapabilities::completions() const {
  const ::mcp::CompletionsCapability* p = completions_;
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.completions)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::CompletionsCapability*>(
      &::mcp::_CompletionsCapability_default_instance_);
}
inline ::mcp::CompletionsCapability* ServerCapabilities::release_completions() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.completions)
  
  ::mcp::CompletionsCapability* temp = completions_;
  completions_ = NULL;
  return temp;
}
inline ::mcp::CompletionsCapability* ServerCapabilities::mutable_completions() {
  
  if (completions_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::CompletionsCapability>(GetArenaNoVirtual());
    completions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.completions)
  return completions_;
}
inline void ServerCapabilities::set_allocated_completions(::mcp::CompletionsCapability* completions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete completions_;
  }
  if (completions) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      completions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, completions, submessage_arena);
    }
    
  } else {
    
  }
  completions_ = completions;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.completions)
}

// .mcp.PromptsCapability prompts = 4;
inline bool ServerCapabilities::has_prompts() const {
  return this != internal_default_instance() && prompts_ != NULL;
}
inline void ServerCapabilities::clear_prompts() {
  if (GetArenaNoVirtual() == NULL && prompts_ != NULL) {
    delete prompts_;
  }
  prompts_ = NULL;
}
inline const ::mcp::PromptsCapability& ServerCapabilities::_internal_prompts() const {
  return *prompts_;
}
inline const ::mcp::PromptsCapability& ServerCapabilities::prompts() const {
  const ::mcp::PromptsCapability* p = prompts_;
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.prompts)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::PromptsCapability*>(
      &::mcp::_PromptsCapability_default_instance_);
}
inline ::mcp::PromptsCapability* ServerCapabilities::release_prompts() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.prompts)
  
  ::mcp::PromptsCapability* temp = prompts_;
  prompts_ = NULL;
  return temp;
}
inline ::mcp::PromptsCapability* ServerCapabilities::mutable_prompts() {
  
  if (prompts_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::PromptsCapability>(GetArenaNoVirtual());
    prompts_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.prompts)
  return prompts_;
}
inline void ServerCapabilities::set_allocated_prompts(::mcp::PromptsCapability* prompts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prompts_;
  }
  if (prompts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prompts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prompts, submessage_arena);
    }
    
  } else {
    
  }
  prompts_ = prompts;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.prompts)
}

// .mcp.ResourcesCapability resources = 5;
inline bool ServerCapabilities::has_resources() const {
  return this != internal_default_instance() && resources_ != NULL;
}
inline void ServerCapabilities::clear_resources() {
  if (GetArenaNoVirtual() == NULL && resources_ != NULL) {
    delete resources_;
  }
  resources_ = NULL;
}
inline const ::mcp::ResourcesCapability& ServerCapabilities::_internal_resources() const {
  return *resources_;
}
inline const ::mcp::ResourcesCapability& ServerCapabilities::resources() const {
  const ::mcp::ResourcesCapability* p = resources_;
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.resources)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ResourcesCapability*>(
      &::mcp::_ResourcesCapability_default_instance_);
}
inline ::mcp::ResourcesCapability* ServerCapabilities::release_resources() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.resources)
  
  ::mcp::ResourcesCapability* temp = resources_;
  resources_ = NULL;
  return temp;
}
inline ::mcp::ResourcesCapability* ServerCapabilities::mutable_resources() {
  
  if (resources_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ResourcesCapability>(GetArenaNoVirtual());
    resources_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.resources)
  return resources_;
}
inline void ServerCapabilities::set_allocated_resources(::mcp::ResourcesCapability* resources) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resources_;
  }
  if (resources) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resources = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.resources)
}

// .mcp.ToolsCapability tools = 6;
inline bool ServerCapabilities::has_tools() const {
  return this != internal_default_instance() && tools_ != NULL;
}
inline void ServerCapabilities::clear_tools() {
  if (GetArenaNoVirtual() == NULL && tools_ != NULL) {
    delete tools_;
  }
  tools_ = NULL;
}
inline const ::mcp::ToolsCapability& ServerCapabilities::_internal_tools() const {
  return *tools_;
}
inline const ::mcp::ToolsCapability& ServerCapabilities::tools() const {
  const ::mcp::ToolsCapability* p = tools_;
  // @@protoc_insertion_point(field_get:mcp.ServerCapabilities.tools)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ToolsCapability*>(
      &::mcp::_ToolsCapability_default_instance_);
}
inline ::mcp::ToolsCapability* ServerCapabilities::release_tools() {
  // @@protoc_insertion_point(field_release:mcp.ServerCapabilities.tools)
  
  ::mcp::ToolsCapability* temp = tools_;
  tools_ = NULL;
  return temp;
}
inline ::mcp::ToolsCapability* ServerCapabilities::mutable_tools() {
  
  if (tools_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ToolsCapability>(GetArenaNoVirtual());
    tools_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ServerCapabilities.tools)
  return tools_;
}
inline void ServerCapabilities::set_allocated_tools(::mcp::ToolsCapability* tools) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tools_;
  }
  if (tools) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tools = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tools, submessage_arena);
    }
    
  } else {
    
  }
  tools_ = tools;
  // @@protoc_insertion_point(field_set_allocated:mcp.ServerCapabilities.tools)
}

// -------------------------------------------------------------------

// RootsCapability

// bool list_changed = 1;
inline void RootsCapability::clear_list_changed() {
  list_changed_ = false;
}
inline bool RootsCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.RootsCapability.list_changed)
  return list_changed_;
}
inline void RootsCapability::set_list_changed(bool value) {
  
  list_changed_ = value;
  // @@protoc_insertion_point(field_set:mcp.RootsCapability.list_changed)
}

// -------------------------------------------------------------------

// SamplingCapability

// -------------------------------------------------------------------

// LoggingCapability

// -------------------------------------------------------------------

// CompletionsCapability

// -------------------------------------------------------------------

// PromptsCapability

// bool list_changed = 1;
inline void PromptsCapability::clear_list_changed() {
  list_changed_ = false;
}
inline bool PromptsCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.PromptsCapability.list_changed)
  return list_changed_;
}
inline void PromptsCapability::set_list_changed(bool value) {
  
  list_changed_ = value;
  // @@protoc_insertion_point(field_set:mcp.PromptsCapability.list_changed)
}

// -------------------------------------------------------------------

// ResourcesCapability

// bool subscribe = 1;
inline void ResourcesCapability::clear_subscribe() {
  subscribe_ = false;
}
inline bool ResourcesCapability::subscribe() const {
  // @@protoc_insertion_point(field_get:mcp.ResourcesCapability.subscribe)
  return subscribe_;
}
inline void ResourcesCapability::set_subscribe(bool value) {
  
  subscribe_ = value;
  // @@protoc_insertion_point(field_set:mcp.ResourcesCapability.subscribe)
}

// bool list_changed = 2;
inline void ResourcesCapability::clear_list_changed() {
  list_changed_ = false;
}
inline bool ResourcesCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.ResourcesCapability.list_changed)
  return list_changed_;
}
inline void ResourcesCapability::set_list_changed(bool value) {
  
  list_changed_ = value;
  // @@protoc_insertion_point(field_set:mcp.ResourcesCapability.list_changed)
}

// -------------------------------------------------------------------

// ToolsCapability

// bool list_changed = 1;
inline void ToolsCapability::clear_list_changed() {
  list_changed_ = false;
}
inline bool ToolsCapability::list_changed() const {
  // @@protoc_insertion_point(field_get:mcp.ToolsCapability.list_changed)
  return list_changed_;
}
inline void ToolsCapability::set_list_changed(bool value) {
  
  list_changed_ = value;
  // @@protoc_insertion_point(field_set:mcp.ToolsCapability.list_changed)
}

// -------------------------------------------------------------------

// Resource

// string uri = 1;
inline void Resource::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resource::uri() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.uri)
  return uri_.GetNoArena();
}
inline void Resource::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Resource.uri)
}
#if LANG_CXX11
inline void Resource::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Resource.uri)
}
#endif
inline void Resource::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Resource.uri)
}
inline void Resource::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Resource.uri)
}
inline ::std::string* Resource::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Resource.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resource::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.Resource.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resource::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.uri)
}

// string name = 2;
inline void Resource::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.name)
  return name_.GetNoArena();
}
inline void Resource::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Resource.name)
}
#if LANG_CXX11
inline void Resource::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Resource.name)
}
#endif
inline void Resource::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Resource.name)
}
inline void Resource::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Resource.name)
}
inline ::std::string* Resource::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Resource.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resource::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Resource.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resource::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.name)
}

// string description = 3;
inline void Resource::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resource::description() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.description)
  return description_.GetNoArena();
}
inline void Resource::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Resource.description)
}
#if LANG_CXX11
inline void Resource::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Resource.description)
}
#endif
inline void Resource::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Resource.description)
}
inline void Resource::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Resource.description)
}
inline ::std::string* Resource::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Resource.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resource::release_description() {
  // @@protoc_insertion_point(field_release:mcp.Resource.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resource::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.description)
}

// string mime_type = 4;
inline void Resource::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resource::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.mime_type)
  return mime_type_.GetNoArena();
}
inline void Resource::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Resource.mime_type)
}
#if LANG_CXX11
inline void Resource::set_mime_type(::std::string&& value) {
  
  mime_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Resource.mime_type)
}
#endif
inline void Resource::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Resource.mime_type)
}
inline void Resource::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Resource.mime_type)
}
inline ::std::string* Resource::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Resource.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resource::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.Resource.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resource::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.mime_type)
}

// .mcp.Annotations annotations = 5;
inline bool Resource::has_annotations() const {
  return this != internal_default_instance() && annotations_ != NULL;
}
inline void Resource::clear_annotations() {
  if (GetArenaNoVirtual() == NULL && annotations_ != NULL) {
    delete annotations_;
  }
  annotations_ = NULL;
}
inline const ::mcp::Annotations& Resource::_internal_annotations() const {
  return *annotations_;
}
inline const ::mcp::Annotations& Resource::annotations() const {
  const ::mcp::Annotations* p = annotations_;
  // @@protoc_insertion_point(field_get:mcp.Resource.annotations)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Annotations*>(
      &::mcp::_Annotations_default_instance_);
}
inline ::mcp::Annotations* Resource::release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.Resource.annotations)
  
  ::mcp::Annotations* temp = annotations_;
  annotations_ = NULL;
  return temp;
}
inline ::mcp::Annotations* Resource::mutable_annotations() {
  
  if (annotations_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.Resource.annotations)
  return annotations_;
}
inline void Resource::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotations_;
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.Resource.annotations)
}

// int64 size = 6;
inline void Resource::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Resource::size() const {
  // @@protoc_insertion_point(field_get:mcp.Resource.size)
  return size_;
}
inline void Resource::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:mcp.Resource.size)
}

// -------------------------------------------------------------------

// ResourceTemplate

// string uri_template = 1;
inline void ResourceTemplate::clear_uri_template() {
  uri_template_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceTemplate::uri_template() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.uri_template)
  return uri_template_.GetNoArena();
}
inline void ResourceTemplate::set_uri_template(const ::std::string& value) {
  
  uri_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.uri_template)
}
#if LANG_CXX11
inline void ResourceTemplate::set_uri_template(::std::string&& value) {
  
  uri_template_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceTemplate.uri_template)
}
#endif
inline void ResourceTemplate::set_uri_template(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceTemplate.uri_template)
}
inline void ResourceTemplate::set_uri_template(const char* value, size_t size) {
  
  uri_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceTemplate.uri_template)
}
inline ::std::string* ResourceTemplate::mutable_uri_template() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.uri_template)
  return uri_template_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceTemplate::release_uri_template() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.uri_template)
  
  return uri_template_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceTemplate::set_allocated_uri_template(::std::string* uri_template) {
  if (uri_template != NULL) {
    
  } else {
    
  }
  uri_template_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri_template);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.uri_template)
}

// string name = 2;
inline void ResourceTemplate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceTemplate::name() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.name)
  return name_.GetNoArena();
}
inline void ResourceTemplate::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.name)
}
#if LANG_CXX11
inline void ResourceTemplate::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceTemplate.name)
}
#endif
inline void ResourceTemplate::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceTemplate.name)
}
inline void ResourceTemplate::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceTemplate.name)
}
inline ::std::string* ResourceTemplate::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceTemplate::release_name() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceTemplate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.name)
}

// string description = 3;
inline void ResourceTemplate::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceTemplate::description() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.description)
  return description_.GetNoArena();
}
inline void ResourceTemplate::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.description)
}
#if LANG_CXX11
inline void ResourceTemplate::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceTemplate.description)
}
#endif
inline void ResourceTemplate::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceTemplate.description)
}
inline void ResourceTemplate::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceTemplate.description)
}
inline ::std::string* ResourceTemplate::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceTemplate::release_description() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceTemplate::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.description)
}

// string mime_type = 4;
inline void ResourceTemplate::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceTemplate::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.mime_type)
  return mime_type_.GetNoArena();
}
inline void ResourceTemplate::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceTemplate.mime_type)
}
#if LANG_CXX11
inline void ResourceTemplate::set_mime_type(::std::string&& value) {
  
  mime_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceTemplate.mime_type)
}
#endif
inline void ResourceTemplate::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceTemplate.mime_type)
}
inline void ResourceTemplate::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceTemplate.mime_type)
}
inline ::std::string* ResourceTemplate::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceTemplate::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceTemplate::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.mime_type)
}

// .mcp.Annotations annotations = 5;
inline bool ResourceTemplate::has_annotations() const {
  return this != internal_default_instance() && annotations_ != NULL;
}
inline void ResourceTemplate::clear_annotations() {
  if (GetArenaNoVirtual() == NULL && annotations_ != NULL) {
    delete annotations_;
  }
  annotations_ = NULL;
}
inline const ::mcp::Annotations& ResourceTemplate::_internal_annotations() const {
  return *annotations_;
}
inline const ::mcp::Annotations& ResourceTemplate::annotations() const {
  const ::mcp::Annotations* p = annotations_;
  // @@protoc_insertion_point(field_get:mcp.ResourceTemplate.annotations)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Annotations*>(
      &::mcp::_Annotations_default_instance_);
}
inline ::mcp::Annotations* ResourceTemplate::release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.ResourceTemplate.annotations)
  
  ::mcp::Annotations* temp = annotations_;
  annotations_ = NULL;
  return temp;
}
inline ::mcp::Annotations* ResourceTemplate::mutable_annotations() {
  
  if (annotations_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ResourceTemplate.annotations)
  return annotations_;
}
inline void ResourceTemplate::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotations_;
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceTemplate.annotations)
}

// -------------------------------------------------------------------

// ResourceContents

// string uri = 1;
inline void ResourceContents::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceContents::uri() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.uri)
  return uri_.GetNoArena();
}
inline void ResourceContents::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceContents.uri)
}
#if LANG_CXX11
inline void ResourceContents::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceContents.uri)
}
#endif
inline void ResourceContents::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceContents.uri)
}
inline void ResourceContents::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceContents.uri)
}
inline ::std::string* ResourceContents::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceContents::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceContents::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceContents.uri)
}

// string mime_type = 2;
inline void ResourceContents::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceContents::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.mime_type)
  return mime_type_.GetNoArena();
}
inline void ResourceContents::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceContents.mime_type)
}
#if LANG_CXX11
inline void ResourceContents::set_mime_type(::std::string&& value) {
  
  mime_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceContents.mime_type)
}
#endif
inline void ResourceContents::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceContents.mime_type)
}
inline void ResourceContents::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceContents.mime_type)
}
inline ::std::string* ResourceContents::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceContents::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceContents::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceContents.mime_type)
}

// .mcp.TextResourceContents text = 3;
inline bool ResourceContents::has_text() const {
  return content_case() == kText;
}
inline void ResourceContents::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void ResourceContents::clear_text() {
  if (has_text()) {
    delete content_.text_;
    clear_has_content();
  }
}
inline const ::mcp::TextResourceContents& ResourceContents::_internal_text() const {
  return *content_.text_;
}
inline ::mcp::TextResourceContents* ResourceContents::release_text() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.text)
  if (has_text()) {
    clear_has_content();
      ::mcp::TextResourceContents* temp = content_.text_;
    content_.text_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::TextResourceContents& ResourceContents::text() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.text)
  return has_text()
      ? *content_.text_
      : *reinterpret_cast< ::mcp::TextResourceContents*>(&::mcp::_TextResourceContents_default_instance_);
}
inline ::mcp::TextResourceContents* ResourceContents::mutable_text() {
  if (!has_text()) {
    clear_content();
    set_has_text();
    content_.text_ = CreateMaybeMessage< ::mcp::TextResourceContents >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.text)
  return content_.text_;
}

// .mcp.BlobResourceContents blob = 4;
inline bool ResourceContents::has_blob() const {
  return content_case() == kBlob;
}
inline void ResourceContents::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void ResourceContents::clear_blob() {
  if (has_blob()) {
    delete content_.blob_;
    clear_has_content();
  }
}
inline const ::mcp::BlobResourceContents& ResourceContents::_internal_blob() const {
  return *content_.blob_;
}
inline ::mcp::BlobResourceContents* ResourceContents::release_blob() {
  // @@protoc_insertion_point(field_release:mcp.ResourceContents.blob)
  if (has_blob()) {
    clear_has_content();
      ::mcp::BlobResourceContents* temp = content_.blob_;
    content_.blob_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mcp::BlobResourceContents& ResourceContents::blob() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceContents.blob)
  return has_blob()
      ? *content_.blob_
      : *reinterpret_cast< ::mcp::BlobResourceContents*>(&::mcp::_BlobResourceContents_default_instance_);
}
inline ::mcp::BlobResourceContents* ResourceContents::mutable_blob() {
  if (!has_blob()) {
    clear_content();
    set_has_blob();
    content_.blob_ = CreateMaybeMessage< ::mcp::BlobResourceContents >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mcp.ResourceContents.blob)
  return content_.blob_;
}

inline bool ResourceContents::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void ResourceContents::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline ResourceContents::ContentCase ResourceContents::content_case() const {
  return ResourceContents::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextResourceContents

// string text = 1;
inline void TextResourceContents::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextResourceContents::text() const {
  // @@protoc_insertion_point(field_get:mcp.TextResourceContents.text)
  return text_.GetNoArena();
}
inline void TextResourceContents::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.TextResourceContents.text)
}
#if LANG_CXX11
inline void TextResourceContents::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.TextResourceContents.text)
}
#endif
inline void TextResourceContents::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.TextResourceContents.text)
}
inline void TextResourceContents::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.TextResourceContents.text)
}
inline ::std::string* TextResourceContents::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:mcp.TextResourceContents.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextResourceContents::release_text() {
  // @@protoc_insertion_point(field_release:mcp.TextResourceContents.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextResourceContents::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:mcp.TextResourceContents.text)
}

// -------------------------------------------------------------------

// BlobResourceContents

// bytes blob = 1;
inline void BlobResourceContents::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlobResourceContents::blob() const {
  // @@protoc_insertion_point(field_get:mcp.BlobResourceContents.blob)
  return blob_.GetNoArena();
}
inline void BlobResourceContents::set_blob(const ::std::string& value) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.BlobResourceContents.blob)
}
#if LANG_CXX11
inline void BlobResourceContents::set_blob(::std::string&& value) {
  
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.BlobResourceContents.blob)
}
#endif
inline void BlobResourceContents::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.BlobResourceContents.blob)
}
inline void BlobResourceContents::set_blob(const void* value, size_t size) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.BlobResourceContents.blob)
}
inline ::std::string* BlobResourceContents::mutable_blob() {
  
  // @@protoc_insertion_point(field_mutable:mcp.BlobResourceContents.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlobResourceContents::release_blob() {
  // @@protoc_insertion_point(field_release:mcp.BlobResourceContents.blob)
  
  return blob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlobResourceContents::set_allocated_blob(::std::string* blob) {
  if (blob != NULL) {
    
  } else {
    
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:mcp.BlobResourceContents.blob)
}

// -------------------------------------------------------------------

// Tool

// string name = 1;
inline void Tool::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tool::name() const {
  // @@protoc_insertion_point(field_get:mcp.Tool.name)
  return name_.GetNoArena();
}
inline void Tool::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Tool.name)
}
#if LANG_CXX11
inline void Tool::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Tool.name)
}
#endif
inline void Tool::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Tool.name)
}
inline void Tool::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Tool.name)
}
inline ::std::string* Tool::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Tool.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tool::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Tool.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tool::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.name)
}

// string description = 2;
inline void Tool::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tool::description() const {
  // @@protoc_insertion_point(field_get:mcp.Tool.description)
  return description_.GetNoArena();
}
inline void Tool::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Tool.description)
}
#if LANG_CXX11
inline void Tool::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Tool.description)
}
#endif
inline void Tool::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Tool.description)
}
inline void Tool::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Tool.description)
}
inline ::std::string* Tool::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Tool.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tool::release_description() {
  // @@protoc_insertion_point(field_release:mcp.Tool.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tool::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.description)
}

// .mcp.InputSchema input_schema = 3;
inline bool Tool::has_input_schema() const {
  return this != internal_default_instance() && input_schema_ != NULL;
}
inline void Tool::clear_input_schema() {
  if (GetArenaNoVirtual() == NULL && input_schema_ != NULL) {
    delete input_schema_;
  }
  input_schema_ = NULL;
}
inline const ::mcp::InputSchema& Tool::_internal_input_schema() const {
  return *input_schema_;
}
inline const ::mcp::InputSchema& Tool::input_schema() const {
  const ::mcp::InputSchema* p = input_schema_;
  // @@protoc_insertion_point(field_get:mcp.Tool.input_schema)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::InputSchema*>(
      &::mcp::_InputSchema_default_instance_);
}
inline ::mcp::InputSchema* Tool::release_input_schema() {
  // @@protoc_insertion_point(field_release:mcp.Tool.input_schema)
  
  ::mcp::InputSchema* temp = input_schema_;
  input_schema_ = NULL;
  return temp;
}
inline ::mcp::InputSchema* Tool::mutable_input_schema() {
  
  if (input_schema_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::InputSchema>(GetArenaNoVirtual());
    input_schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.Tool.input_schema)
  return input_schema_;
}
inline void Tool::set_allocated_input_schema(::mcp::InputSchema* input_schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_schema_;
  }
  if (input_schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input_schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input_schema, submessage_arena);
    }
    
  } else {
    
  }
  input_schema_ = input_schema;
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.input_schema)
}

// .mcp.ToolAnnotations annotations = 4;
inline bool Tool::has_annotations() const {
  return this != internal_default_instance() && annotations_ != NULL;
}
inline void Tool::clear_annotations() {
  if (GetArenaNoVirtual() == NULL && annotations_ != NULL) {
    delete annotations_;
  }
  annotations_ = NULL;
}
inline const ::mcp::ToolAnnotations& Tool::_internal_annotations() const {
  return *annotations_;
}
inline const ::mcp::ToolAnnotations& Tool::annotations() const {
  const ::mcp::ToolAnnotations* p = annotations_;
  // @@protoc_insertion_point(field_get:mcp.Tool.annotations)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ToolAnnotations*>(
      &::mcp::_ToolAnnotations_default_instance_);
}
inline ::mcp::ToolAnnotations* Tool::release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.Tool.annotations)
  
  ::mcp::ToolAnnotations* temp = annotations_;
  annotations_ = NULL;
  return temp;
}
inline ::mcp::ToolAnnotations* Tool::mutable_annotations() {
  
  if (annotations_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ToolAnnotations>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.Tool.annotations)
  return annotations_;
}
inline void Tool::set_allocated_annotations(::mcp::ToolAnnotations* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotations_;
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.Tool.annotations)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InputSchema

// string type = 1;
inline void InputSchema::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InputSchema::type() const {
  // @@protoc_insertion_point(field_get:mcp.InputSchema.type)
  return type_.GetNoArena();
}
inline void InputSchema::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.InputSchema.type)
}
#if LANG_CXX11
inline void InputSchema::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.InputSchema.type)
}
#endif
inline void InputSchema::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.InputSchema.type)
}
inline void InputSchema::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.InputSchema.type)
}
inline ::std::string* InputSchema::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.InputSchema.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputSchema::release_type() {
  // @@protoc_insertion_point(field_release:mcp.InputSchema.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputSchema::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcp.InputSchema.type)
}

// map<string, bytes> properties = 2;
inline int InputSchema::properties_size() const {
  return properties_.size();
}
inline void InputSchema::clear_properties() {
  properties_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
InputSchema::properties() const {
  // @@protoc_insertion_point(field_map:mcp.InputSchema.properties)
  return properties_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
InputSchema::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:mcp.InputSchema.properties)
  return properties_.MutableMap();
}

// repeated string required = 3;
inline int InputSchema::required_size() const {
  return required_.size();
}
inline void InputSchema::clear_required() {
  required_.Clear();
}
inline const ::std::string& InputSchema::required(int index) const {
  // @@protoc_insertion_point(field_get:mcp.InputSchema.required)
  return required_.Get(index);
}
inline ::std::string* InputSchema::mutable_required(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.InputSchema.required)
  return required_.Mutable(index);
}
inline void InputSchema::set_required(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mcp.InputSchema.required)
  required_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void InputSchema::set_required(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mcp.InputSchema.required)
  required_.Mutable(index)->assign(std::move(value));
}
#endif
inline void InputSchema::set_required(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  required_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcp.InputSchema.required)
}
inline void InputSchema::set_required(int index, const char* value, size_t size) {
  required_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcp.InputSchema.required)
}
inline ::std::string* InputSchema::add_required() {
  // @@protoc_insertion_point(field_add_mutable:mcp.InputSchema.required)
  return required_.Add();
}
inline void InputSchema::add_required(const ::std::string& value) {
  required_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcp.InputSchema.required)
}
#if LANG_CXX11
inline void InputSchema::add_required(::std::string&& value) {
  required_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcp.InputSchema.required)
}
#endif
inline void InputSchema::add_required(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  required_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcp.InputSchema.required)
}
inline void InputSchema::add_required(const char* value, size_t size) {
  required_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcp.InputSchema.required)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InputSchema::required() const {
  // @@protoc_insertion_point(field_list:mcp.InputSchema.required)
  return required_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InputSchema::mutable_required() {
  // @@protoc_insertion_point(field_mutable_list:mcp.InputSchema.required)
  return &required_;
}

// -------------------------------------------------------------------

// ToolAnnotations

// string title = 1;
inline void ToolAnnotations::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ToolAnnotations::title() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.title)
  return title_.GetNoArena();
}
inline void ToolAnnotations::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.title)
}
#if LANG_CXX11
inline void ToolAnnotations::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ToolAnnotations.title)
}
#endif
inline void ToolAnnotations::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ToolAnnotations.title)
}
inline void ToolAnnotations::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ToolAnnotations.title)
}
inline ::std::string* ToolAnnotations::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ToolAnnotations.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ToolAnnotations::release_title() {
  // @@protoc_insertion_point(field_release:mcp.ToolAnnotations.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ToolAnnotations::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:mcp.ToolAnnotations.title)
}

// bool read_only_hint = 2;
inline void ToolAnnotations::clear_read_only_hint() {
  read_only_hint_ = false;
}
inline bool ToolAnnotations::read_only_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.read_only_hint)
  return read_only_hint_;
}
inline void ToolAnnotations::set_read_only_hint(bool value) {
  
  read_only_hint_ = value;
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.read_only_hint)
}

// bool destructive_hint = 3;
inline void ToolAnnotations::clear_destructive_hint() {
  destructive_hint_ = false;
}
inline bool ToolAnnotations::destructive_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.destructive_hint)
  return destructive_hint_;
}
inline void ToolAnnotations::set_destructive_hint(bool value) {
  
  destructive_hint_ = value;
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.destructive_hint)
}

// bool idempotent_hint = 4;
inline void ToolAnnotations::clear_idempotent_hint() {
  idempotent_hint_ = false;
}
inline bool ToolAnnotations::idempotent_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.idempotent_hint)
  return idempotent_hint_;
}
inline void ToolAnnotations::set_idempotent_hint(bool value) {
  
  idempotent_hint_ = value;
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.idempotent_hint)
}

// bool open_world_hint = 5;
inline void ToolAnnotations::clear_open_world_hint() {
  open_world_hint_ = false;
}
inline bool ToolAnnotations::open_world_hint() const {
  // @@protoc_insertion_point(field_get:mcp.ToolAnnotations.open_world_hint)
  return open_world_hint_;
}
inline void ToolAnnotations::set_open_world_hint(bool value) {
  
  open_world_hint_ = value;
  // @@protoc_insertion_point(field_set:mcp.ToolAnnotations.open_world_hint)
}

// -------------------------------------------------------------------

// Annotations

// repeated .mcp.Role audience = 1;
inline int Annotations::audience_size() const {
  return audience_.size();
}
inline void Annotations::clear_audience() {
  audience_.Clear();
}
inline ::mcp::Role Annotations::audience(int index) const {
  // @@protoc_insertion_point(field_get:mcp.Annotations.audience)
  return static_cast< ::mcp::Role >(audience_.Get(index));
}
inline void Annotations::set_audience(int index, ::mcp::Role value) {
  audience_.Set(index, value);
  // @@protoc_insertion_point(field_set:mcp.Annotations.audience)
}
inline void Annotations::add_audience(::mcp::Role value) {
  audience_.Add(value);
  // @@protoc_insertion_point(field_add:mcp.Annotations.audience)
}
inline const ::google::protobuf::RepeatedField<int>&
Annotations::audience() const {
  // @@protoc_insertion_point(field_list:mcp.Annotations.audience)
  return audience_;
}
inline ::google::protobuf::RepeatedField<int>*
Annotations::mutable_audience() {
  // @@protoc_insertion_point(field_mutable_list:mcp.Annotations.audience)
  return &audience_;
}

// float priority = 2;
inline void Annotations::clear_priority() {
  priority_ = 0;
}
inline float Annotations::priority() const {
  // @@protoc_insertion_point(field_get:mcp.Annotations.priority)
  return priority_;
}
inline void Annotations::set_priority(float value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:mcp.Annotations.priority)
}

// -------------------------------------------------------------------

// TextContent

// string type = 1;
inline void TextContent::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextContent::type() const {
  // @@protoc_insertion_point(field_get:mcp.TextContent.type)
  return type_.GetNoArena();
}
inline void TextContent::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.TextContent.type)
}
#if LANG_CXX11
inline void TextContent::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.TextContent.type)
}
#endif
inline void TextContent::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.TextContent.type)
}
inline void TextContent::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.TextContent.type)
}
inline ::std::string* TextContent::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.TextContent.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextContent::release_type() {
  // @@protoc_insertion_point(field_release:mcp.TextContent.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextContent::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcp.TextContent.type)
}

// string text = 2;
inline void TextContent::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextContent::text() const {
  // @@protoc_insertion_point(field_get:mcp.TextContent.text)
  return text_.GetNoArena();
}
inline void TextContent::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.TextContent.text)
}
#if LANG_CXX11
inline void TextContent::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.TextContent.text)
}
#endif
inline void TextContent::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.TextContent.text)
}
inline void TextContent::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.TextContent.text)
}
inline ::std::string* TextContent::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:mcp.TextContent.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextContent::release_text() {
  // @@protoc_insertion_point(field_release:mcp.TextContent.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextContent::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:mcp.TextContent.text)
}

// .mcp.Annotations annotations = 3;
inline bool TextContent::has_annotations() const {
  return this != internal_default_instance() && annotations_ != NULL;
}
inline void TextContent::clear_annotations() {
  if (GetArenaNoVirtual() == NULL && annotations_ != NULL) {
    delete annotations_;
  }
  annotations_ = NULL;
}
inline const ::mcp::Annotations& TextContent::_internal_annotations() const {
  return *annotations_;
}
inline const ::mcp::Annotations& TextContent::annotations() const {
  const ::mcp::Annotations* p = annotations_;
  // @@protoc_insertion_point(field_get:mcp.TextContent.annotations)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Annotations*>(
      &::mcp::_Annotations_default_instance_);
}
inline ::mcp::Annotations* TextContent::release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.TextContent.annotations)
  
  ::mcp::Annotations* temp = annotations_;
  annotations_ = NULL;
  return temp;
}
inline ::mcp::Annotations* TextContent::mutable_annotations() {
  
  if (annotations_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.TextContent.annotations)
  return annotations_;
}
inline void TextContent::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotations_;
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.TextContent.annotations)
}

// -------------------------------------------------------------------

// ImageContent

// string type = 1;
inline void ImageContent::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImageContent::type() const {
  // @@protoc_insertion_point(field_get:mcp.ImageContent.type)
  return type_.GetNoArena();
}
inline void ImageContent::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ImageContent.type)
}
#if LANG_CXX11
inline void ImageContent::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ImageContent.type)
}
#endif
inline void ImageContent::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ImageContent.type)
}
inline void ImageContent::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ImageContent.type)
}
inline ::std::string* ImageContent::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageContent::release_type() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageContent::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.type)
}

// bytes data = 2;
inline void ImageContent::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImageContent::data() const {
  // @@protoc_insertion_point(field_get:mcp.ImageContent.data)
  return data_.GetNoArena();
}
inline void ImageContent::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ImageContent.data)
}
#if LANG_CXX11
inline void ImageContent::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ImageContent.data)
}
#endif
inline void ImageContent::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ImageContent.data)
}
inline void ImageContent::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ImageContent.data)
}
inline ::std::string* ImageContent::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageContent::release_data() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageContent::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.data)
}

// string mime_type = 3;
inline void ImageContent::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImageContent::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.ImageContent.mime_type)
  return mime_type_.GetNoArena();
}
inline void ImageContent::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ImageContent.mime_type)
}
#if LANG_CXX11
inline void ImageContent::set_mime_type(::std::string&& value) {
  
  mime_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ImageContent.mime_type)
}
#endif
inline void ImageContent::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ImageContent.mime_type)
}
inline void ImageContent::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ImageContent.mime_type)
}
inline ::std::string* ImageContent::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageContent::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageContent::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.mime_type)
}

// .mcp.Annotations annotations = 4;
inline bool ImageContent::has_annotations() const {
  return this != internal_default_instance() && annotations_ != NULL;
}
inline void ImageContent::clear_annotations() {
  if (GetArenaNoVirtual() == NULL && annotations_ != NULL) {
    delete annotations_;
  }
  annotations_ = NULL;
}
inline const ::mcp::Annotations& ImageContent::_internal_annotations() const {
  return *annotations_;
}
inline const ::mcp::Annotations& ImageContent::annotations() const {
  const ::mcp::Annotations* p = annotations_;
  // @@protoc_insertion_point(field_get:mcp.ImageContent.annotations)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Annotations*>(
      &::mcp::_Annotations_default_instance_);
}
inline ::mcp::Annotations* ImageContent::release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.ImageContent.annotations)
  
  ::mcp::Annotations* temp = annotations_;
  annotations_ = NULL;
  return temp;
}
inline ::mcp::Annotations* ImageContent::mutable_annotations() {
  
  if (annotations_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ImageContent.annotations)
  return annotations_;
}
inline void ImageContent::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotations_;
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.ImageContent.annotations)
}

// -------------------------------------------------------------------

// AudioContent

// string type = 1;
inline void AudioContent::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AudioContent::type() const {
  // @@protoc_insertion_point(field_get:mcp.AudioContent.type)
  return type_.GetNoArena();
}
inline void AudioContent::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.AudioContent.type)
}
#if LANG_CXX11
inline void AudioContent::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.AudioContent.type)
}
#endif
inline void AudioContent::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.AudioContent.type)
}
inline void AudioContent::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.AudioContent.type)
}
inline ::std::string* AudioContent::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioContent::release_type() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioContent::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.type)
}

// bytes data = 2;
inline void AudioContent::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AudioContent::data() const {
  // @@protoc_insertion_point(field_get:mcp.AudioContent.data)
  return data_.GetNoArena();
}
inline void AudioContent::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.AudioContent.data)
}
#if LANG_CXX11
inline void AudioContent::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.AudioContent.data)
}
#endif
inline void AudioContent::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.AudioContent.data)
}
inline void AudioContent::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.AudioContent.data)
}
inline ::std::string* AudioContent::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioContent::release_data() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioContent::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.data)
}

// string mime_type = 3;
inline void AudioContent::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AudioContent::mime_type() const {
  // @@protoc_insertion_point(field_get:mcp.AudioContent.mime_type)
  return mime_type_.GetNoArena();
}
inline void AudioContent::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.AudioContent.mime_type)
}
#if LANG_CXX11
inline void AudioContent::set_mime_type(::std::string&& value) {
  
  mime_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.AudioContent.mime_type)
}
#endif
inline void AudioContent::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.AudioContent.mime_type)
}
inline void AudioContent::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.AudioContent.mime_type)
}
inline ::std::string* AudioContent::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioContent::release_mime_type() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioContent::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.mime_type)
}

// .mcp.Annotations annotations = 4;
inline bool AudioContent::has_annotations() const {
  return this != internal_default_instance() && annotations_ != NULL;
}
inline void AudioContent::clear_annotations() {
  if (GetArenaNoVirtual() == NULL && annotations_ != NULL) {
    delete annotations_;
  }
  annotations_ = NULL;
}
inline const ::mcp::Annotations& AudioContent::_internal_annotations() const {
  return *annotations_;
}
inline const ::mcp::Annotations& AudioContent::annotations() const {
  const ::mcp::Annotations* p = annotations_;
  // @@protoc_insertion_point(field_get:mcp.AudioContent.annotations)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Annotations*>(
      &::mcp::_Annotations_default_instance_);
}
inline ::mcp::Annotations* AudioContent::release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.AudioContent.annotations)
  
  ::mcp::Annotations* temp = annotations_;
  annotations_ = NULL;
  return temp;
}
inline ::mcp::Annotations* AudioContent::mutable_annotations() {
  
  if (annotations_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.AudioContent.annotations)
  return annotations_;
}
inline void AudioContent::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete annotations_;
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.AudioContent.annotations)
}

// -------------------------------------------------------------------

// ModelPreferences

// repeated .mcp.ModelHint hints = 1;
inline int ModelPreferences::hints_size() const {
  return hints_.size();
}
inline void ModelPreferences::clear_hints() {
  hints_.Clear();
}
inline ::mcp::ModelHint* ModelPreferences::mutable_hints(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ModelPreferences.hints)
  return hints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mcp::ModelHint >*
ModelPreferences::mutable_hints() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ModelPreferences.hints)
  return &hints_;
}
inline const ::mcp::ModelHint& ModelPreferences::hints(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.hints)
  return hints_.Get(index);
}
inline ::mcp::ModelHint* ModelPreferences::add_hints() {
  // @@protoc_insertion_point(field_add:mcp.ModelPreferences.hints)
  return hints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcp::ModelHint >&
ModelPreferences::hints() const {
  // @@protoc_insertion_point(field_list:mcp.ModelPreferences.hints)
  return hints_;
}

// float cost_priority = 2;
inline void ModelPreferences::clear_cost_priority() {
  cost_priority_ = 0;
}
inline float ModelPreferences::cost_priority() const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.cost_priority)
  return cost_priority_;
}
inline void ModelPreferences::set_cost_priority(float value) {
  
  cost_priority_ = value;
  // @@protoc_insertion_point(field_set:mcp.ModelPreferences.cost_priority)
}

// float speed_priority = 3;
inline void ModelPreferences::clear_speed_priority() {
  speed_priority_ = 0;
}
inline float ModelPreferences::speed_priority() const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.speed_priority)
  return speed_priority_;
}
inline void ModelPreferences::set_speed_priority(float value) {
  
  speed_priority_ = value;
  // @@protoc_insertion_point(field_set:mcp.ModelPreferences.speed_priority)
}

// float intelligence_priority = 4;
inline void ModelPreferences::clear_intelligence_priority() {
  intelligence_priority_ = 0;
}
inline float ModelPreferences::intelligence_priority() const {
  // @@protoc_insertion_point(field_get:mcp.ModelPreferences.intelligence_priority)
  return intelligence_priority_;
}
inline void ModelPreferences::set_intelligence_priority(float value) {
  
  intelligence_priority_ = value;
  // @@protoc_insertion_point(field_set:mcp.ModelPreferences.intelligence_priority)
}

// -------------------------------------------------------------------

// ModelHint

// string name = 1;
inline void ModelHint::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModelHint::name() const {
  // @@protoc_insertion_point(field_get:mcp.ModelHint.name)
  return name_.GetNoArena();
}
inline void ModelHint::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ModelHint.name)
}
#if LANG_CXX11
inline void ModelHint::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ModelHint.name)
}
#endif
inline void ModelHint::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ModelHint.name)
}
inline void ModelHint::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ModelHint.name)
}
inline ::std::string* ModelHint::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ModelHint.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelHint::release_name() {
  // @@protoc_insertion_point(field_release:mcp.ModelHint.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelHint::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.ModelHint.name)
}

// -------------------------------------------------------------------

// ResourceReference

// string type = 1;
inline void ResourceReference::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceReference::type() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceReference.type)
  return type_.GetNoArena();
}
inline void ResourceReference::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceReference.type)
}
#if LANG_CXX11
inline void ResourceReference::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceReference.type)
}
#endif
inline void ResourceReference::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceReference.type)
}
inline void ResourceReference::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceReference.type)
}
inline ::std::string* ResourceReference::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceReference.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceReference::release_type() {
  // @@protoc_insertion_point(field_release:mcp.ResourceReference.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceReference::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceReference.type)
}

// string uri = 2;
inline void ResourceReference::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceReference::uri() const {
  // @@protoc_insertion_point(field_get:mcp.ResourceReference.uri)
  return uri_.GetNoArena();
}
inline void ResourceReference::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ResourceReference.uri)
}
#if LANG_CXX11
inline void ResourceReference::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ResourceReference.uri)
}
#endif
inline void ResourceReference::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ResourceReference.uri)
}
inline void ResourceReference::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ResourceReference.uri)
}
inline ::std::string* ResourceReference::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ResourceReference.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceReference::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.ResourceReference.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceReference::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:mcp.ResourceReference.uri)
}

// -------------------------------------------------------------------

// PromptReference

// string type = 1;
inline void PromptReference::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PromptReference::type() const {
  // @@protoc_insertion_point(field_get:mcp.PromptReference.type)
  return type_.GetNoArena();
}
inline void PromptReference::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.PromptReference.type)
}
#if LANG_CXX11
inline void PromptReference::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.PromptReference.type)
}
#endif
inline void PromptReference::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.PromptReference.type)
}
inline void PromptReference::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.PromptReference.type)
}
inline ::std::string* PromptReference::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:mcp.PromptReference.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PromptReference::release_type() {
  // @@protoc_insertion_point(field_release:mcp.PromptReference.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PromptReference::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcp.PromptReference.type)
}

// string name = 2;
inline void PromptReference::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PromptReference::name() const {
  // @@protoc_insertion_point(field_get:mcp.PromptReference.name)
  return name_.GetNoArena();
}
inline void PromptReference::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.PromptReference.name)
}
#if LANG_CXX11
inline void PromptReference::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.PromptReference.name)
}
#endif
inline void PromptReference::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.PromptReference.name)
}
inline void PromptReference::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.PromptReference.name)
}
inline ::std::string* PromptReference::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.PromptReference.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PromptReference::release_name() {
  // @@protoc_insertion_point(field_release:mcp.PromptReference.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PromptReference::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.PromptReference.name)
}

// -------------------------------------------------------------------

// Root

// string uri = 1;
inline void Root::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Root::uri() const {
  // @@protoc_insertion_point(field_get:mcp.Root.uri)
  return uri_.GetNoArena();
}
inline void Root::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Root.uri)
}
#if LANG_CXX11
inline void Root::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Root.uri)
}
#endif
inline void Root::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Root.uri)
}
inline void Root::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Root.uri)
}
inline ::std::string* Root::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Root.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Root::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.Root.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Root::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:mcp.Root.uri)
}

// string name = 2;
inline void Root::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Root::name() const {
  // @@protoc_insertion_point(field_get:mcp.Root.name)
  return name_.GetNoArena();
}
inline void Root::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Root.name)
}
#if LANG_CXX11
inline void Root::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Root.name)
}
#endif
inline void Root::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Root.name)
}
inline void Root::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Root.name)
}
inline ::std::string* Root::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Root.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Root::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Root.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Root::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.Root.name)
}

// -------------------------------------------------------------------

// InitializeRequest

// string method = 1;
inline void InitializeRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitializeRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeRequest.method)
  return method_.GetNoArena();
}
inline void InitializeRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.InitializeRequest.method)
}
#if LANG_CXX11
inline void InitializeRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.InitializeRequest.method)
}
#endif
inline void InitializeRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.InitializeRequest.method)
}
inline void InitializeRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.InitializeRequest.method)
}
inline ::std::string* InitializeRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:mcp.InitializeRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitializeRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.InitializeRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeRequest::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeRequest.method)
}

// .mcp.InitializeParams params = 2;
inline bool InitializeRequest::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void InitializeRequest::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::mcp::InitializeParams& InitializeRequest::_internal_params() const {
  return *params_;
}
inline const ::mcp::InitializeParams& InitializeRequest::params() const {
  const ::mcp::InitializeParams* p = params_;
  // @@protoc_insertion_point(field_get:mcp.InitializeRequest.params)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::InitializeParams*>(
      &::mcp::_InitializeParams_default_instance_);
}
inline ::mcp::InitializeParams* InitializeRequest::release_params() {
  // @@protoc_insertion_point(field_release:mcp.InitializeRequest.params)
  
  ::mcp::InitializeParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::mcp::InitializeParams* InitializeRequest::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::InitializeParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.InitializeRequest.params)
  return params_;
}
inline void InitializeRequest::set_allocated_params(::mcp::InitializeParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeRequest.params)
}

// -------------------------------------------------------------------

// InitializeParams

// string protocol_version = 1;
inline void InitializeParams::clear_protocol_version() {
  protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitializeParams::protocol_version() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeParams.protocol_version)
  return protocol_version_.GetNoArena();
}
inline void InitializeParams::set_protocol_version(const ::std::string& value) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.InitializeParams.protocol_version)
}
#if LANG_CXX11
inline void InitializeParams::set_protocol_version(::std::string&& value) {
  
  protocol_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.InitializeParams.protocol_version)
}
#endif
inline void InitializeParams::set_protocol_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.InitializeParams.protocol_version)
}
inline void InitializeParams::set_protocol_version(const char* value, size_t size) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.InitializeParams.protocol_version)
}
inline ::std::string* InitializeParams::mutable_protocol_version() {
  
  // @@protoc_insertion_point(field_mutable:mcp.InitializeParams.protocol_version)
  return protocol_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitializeParams::release_protocol_version() {
  // @@protoc_insertion_point(field_release:mcp.InitializeParams.protocol_version)
  
  return protocol_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeParams::set_allocated_protocol_version(::std::string* protocol_version) {
  if (protocol_version != NULL) {
    
  } else {
    
  }
  protocol_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_version);
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeParams.protocol_version)
}

// .mcp.ClientCapabilities capabilities = 2;
inline bool InitializeParams::has_capabilities() const {
  return this != internal_default_instance() && capabilities_ != NULL;
}
inline void InitializeParams::clear_capabilities() {
  if (GetArenaNoVirtual() == NULL && capabilities_ != NULL) {
    delete capabilities_;
  }
  capabilities_ = NULL;
}
inline const ::mcp::ClientCapabilities& InitializeParams::_internal_capabilities() const {
  return *capabilities_;
}
inline const ::mcp::ClientCapabilities& InitializeParams::capabilities() const {
  const ::mcp::ClientCapabilities* p = capabilities_;
  // @@protoc_insertion_point(field_get:mcp.InitializeParams.capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ClientCapabilities*>(
      &::mcp::_ClientCapabilities_default_instance_);
}
inline ::mcp::ClientCapabilities* InitializeParams::release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.InitializeParams.capabilities)
  
  ::mcp::ClientCapabilities* temp = capabilities_;
  capabilities_ = NULL;
  return temp;
}
inline ::mcp::ClientCapabilities* InitializeParams::mutable_capabilities() {
  
  if (capabilities_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ClientCapabilities>(GetArenaNoVirtual());
    capabilities_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.InitializeParams.capabilities)
  return capabilities_;
}
inline void InitializeParams::set_allocated_capabilities(::mcp::ClientCapabilities* capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete capabilities_;
  }
  if (capabilities) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeParams.capabilities)
}

// .mcp.Implementation client_info = 3;
inline bool InitializeParams::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline void InitializeParams::clear_client_info() {
  if (GetArenaNoVirtual() == NULL && client_info_ != NULL) {
    delete client_info_;
  }
  client_info_ = NULL;
}
inline const ::mcp::Implementation& InitializeParams::_internal_client_info() const {
  return *client_info_;
}
inline const ::mcp::Implementation& InitializeParams::client_info() const {
  const ::mcp::Implementation* p = client_info_;
  // @@protoc_insertion_point(field_get:mcp.InitializeParams.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Implementation*>(
      &::mcp::_Implementation_default_instance_);
}
inline ::mcp::Implementation* InitializeParams::release_client_info() {
  // @@protoc_insertion_point(field_release:mcp.InitializeParams.client_info)
  
  ::mcp::Implementation* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::mcp::Implementation* InitializeParams::mutable_client_info() {
  
  if (client_info_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaNoVirtual());
    client_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.InitializeParams.client_info)
  return client_info_;
}
inline void InitializeParams::set_allocated_client_info(::mcp::Implementation* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_info_;
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeParams.client_info)
}

// -------------------------------------------------------------------

// InitializeResult

// string protocol_version = 1;
inline void InitializeResult::clear_protocol_version() {
  protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitializeResult::protocol_version() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.protocol_version)
  return protocol_version_.GetNoArena();
}
inline void InitializeResult::set_protocol_version(const ::std::string& value) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.InitializeResult.protocol_version)
}
#if LANG_CXX11
inline void InitializeResult::set_protocol_version(::std::string&& value) {
  
  protocol_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.InitializeResult.protocol_version)
}
#endif
inline void InitializeResult::set_protocol_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.InitializeResult.protocol_version)
}
inline void InitializeResult::set_protocol_version(const char* value, size_t size) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.InitializeResult.protocol_version)
}
inline ::std::string* InitializeResult::mutable_protocol_version() {
  
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.protocol_version)
  return protocol_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitializeResult::release_protocol_version() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.protocol_version)
  
  return protocol_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeResult::set_allocated_protocol_version(::std::string* protocol_version) {
  if (protocol_version != NULL) {
    
  } else {
    
  }
  protocol_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_version);
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.protocol_version)
}

// .mcp.ServerCapabilities capabilities = 2;
inline bool InitializeResult::has_capabilities() const {
  return this != internal_default_instance() && capabilities_ != NULL;
}
inline void InitializeResult::clear_capabilities() {
  if (GetArenaNoVirtual() == NULL && capabilities_ != NULL) {
    delete capabilities_;
  }
  capabilities_ = NULL;
}
inline const ::mcp::ServerCapabilities& InitializeResult::_internal_capabilities() const {
  return *capabilities_;
}
inline const ::mcp::ServerCapabilities& InitializeResult::capabilities() const {
  const ::mcp::ServerCapabilities* p = capabilities_;
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ServerCapabilities*>(
      &::mcp::_ServerCapabilities_default_instance_);
}
inline ::mcp::ServerCapabilities* InitializeResult::release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.capabilities)
  
  ::mcp::ServerCapabilities* temp = capabilities_;
  capabilities_ = NULL;
  return temp;
}
inline ::mcp::ServerCapabilities* InitializeResult::mutable_capabilities() {
  
  if (capabilities_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ServerCapabilities>(GetArenaNoVirtual());
    capabilities_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.capabilities)
  return capabilities_;
}
inline void InitializeResult::set_allocated_capabilities(::mcp::ServerCapabilities* capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete capabilities_;
  }
  if (capabilities) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.capabilities)
}

// .mcp.Implementation server_info = 3;
inline bool InitializeResult::has_server_info() const {
  return this != internal_default_instance() && server_info_ != NULL;
}
inline void InitializeResult::clear_server_info() {
  if (GetArenaNoVirtual() == NULL && server_info_ != NULL) {
    delete server_info_;
  }
  server_info_ = NULL;
}
inline const ::mcp::Implementation& InitializeResult::_internal_server_info() const {
  return *server_info_;
}
inline const ::mcp::Implementation& InitializeResult::server_info() const {
  const ::mcp::Implementation* p = server_info_;
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.server_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Implementation*>(
      &::mcp::_Implementation_default_instance_);
}
inline ::mcp::Implementation* InitializeResult::release_server_info() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.server_info)
  
  ::mcp::Implementation* temp = server_info_;
  server_info_ = NULL;
  return temp;
}
inline ::mcp::Implementation* InitializeResult::mutable_server_info() {
  
  if (server_info_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaNoVirtual());
    server_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.server_info)
  return server_info_;
}
inline void InitializeResult::set_allocated_server_info(::mcp::Implementation* server_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_info_;
  }
  if (server_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_info, submessage_arena);
    }
    
  } else {
    
  }
  server_info_ = server_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.server_info)
}

// string instructions = 4;
inline void InitializeResult::clear_instructions() {
  instructions_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitializeResult::instructions() const {
  // @@protoc_insertion_point(field_get:mcp.InitializeResult.instructions)
  return instructions_.GetNoArena();
}
inline void InitializeResult::set_instructions(const ::std::string& value) {
  
  instructions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.InitializeResult.instructions)
}
#if LANG_CXX11
inline void InitializeResult::set_instructions(::std::string&& value) {
  
  instructions_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.InitializeResult.instructions)
}
#endif
inline void InitializeResult::set_instructions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  instructions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.InitializeResult.instructions)
}
inline void InitializeResult::set_instructions(const char* value, size_t size) {
  
  instructions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.InitializeResult.instructions)
}
inline ::std::string* InitializeResult::mutable_instructions() {
  
  // @@protoc_insertion_point(field_mutable:mcp.InitializeResult.instructions)
  return instructions_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitializeResult::release_instructions() {
  // @@protoc_insertion_point(field_release:mcp.InitializeResult.instructions)
  
  return instructions_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeResult::set_allocated_instructions(::std::string* instructions) {
  if (instructions != NULL) {
    
  } else {
    
  }
  instructions_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instructions);
  // @@protoc_insertion_point(field_set_allocated:mcp.InitializeResult.instructions)
}

// -------------------------------------------------------------------

// ListResourcesRequest

// string method = 1;
inline void ListResourcesRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListResourcesRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.ListResourcesRequest.method)
  return method_.GetNoArena();
}
inline void ListResourcesRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ListResourcesRequest.method)
}
#if LANG_CXX11
inline void ListResourcesRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ListResourcesRequest.method)
}
#endif
inline void ListResourcesRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ListResourcesRequest.method)
}
inline void ListResourcesRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ListResourcesRequest.method)
}
inline ::std::string* ListResourcesRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListResourcesRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.ListResourcesRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListResourcesRequest::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:mcp.ListResourcesRequest.method)
}

// .mcp.PaginatedParams params = 2;
inline bool ListResourcesRequest::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void ListResourcesRequest::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::mcp::PaginatedParams& ListResourcesRequest::_internal_params() const {
  return *params_;
}
inline const ::mcp::PaginatedParams& ListResourcesRequest::params() const {
  const ::mcp::PaginatedParams* p = params_;
  // @@protoc_insertion_point(field_get:mcp.ListResourcesRequest.params)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::PaginatedParams*>(
      &::mcp::_PaginatedParams_default_instance_);
}
inline ::mcp::PaginatedParams* ListResourcesRequest::release_params() {
  // @@protoc_insertion_point(field_release:mcp.ListResourcesRequest.params)
  
  ::mcp::PaginatedParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::mcp::PaginatedParams* ListResourcesRequest::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::PaginatedParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesRequest.params)
  return params_;
}
inline void ListResourcesRequest::set_allocated_params(::mcp::PaginatedParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ListResourcesRequest.params)
}

// -------------------------------------------------------------------

// ListResourcesResult

// repeated .mcp.Resource resources = 1;
inline int ListResourcesResult::resources_size() const {
  return resources_.size();
}
inline void ListResourcesResult::clear_resources() {
  resources_.Clear();
}
inline ::mcp::Resource* ListResourcesResult::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesResult.resources)
  return resources_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mcp::Resource >*
ListResourcesResult::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ListResourcesResult.resources)
  return &resources_;
}
inline const ::mcp::Resource& ListResourcesResult::resources(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ListResourcesResult.resources)
  return resources_.Get(index);
}
inline ::mcp::Resource* ListResourcesResult::add_resources() {
  // @@protoc_insertion_point(field_add:mcp.ListResourcesResult.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcp::Resource >&
ListResourcesResult::resources() const {
  // @@protoc_insertion_point(field_list:mcp.ListResourcesResult.resources)
  return resources_;
}

// string next_cursor = 2;
inline void ListResourcesResult::clear_next_cursor() {
  next_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListResourcesResult::next_cursor() const {
  // @@protoc_insertion_point(field_get:mcp.ListResourcesResult.next_cursor)
  return next_cursor_.GetNoArena();
}
inline void ListResourcesResult::set_next_cursor(const ::std::string& value) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ListResourcesResult.next_cursor)
}
#if LANG_CXX11
inline void ListResourcesResult::set_next_cursor(::std::string&& value) {
  
  next_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ListResourcesResult.next_cursor)
}
#endif
inline void ListResourcesResult::set_next_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ListResourcesResult.next_cursor)
}
inline void ListResourcesResult::set_next_cursor(const char* value, size_t size) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ListResourcesResult.next_cursor)
}
inline ::std::string* ListResourcesResult::mutable_next_cursor() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ListResourcesResult.next_cursor)
  return next_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListResourcesResult::release_next_cursor() {
  // @@protoc_insertion_point(field_release:mcp.ListResourcesResult.next_cursor)
  
  return next_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListResourcesResult::set_allocated_next_cursor(::std::string* next_cursor) {
  if (next_cursor != NULL) {
    
  } else {
    
  }
  next_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_cursor);
  // @@protoc_insertion_point(field_set_allocated:mcp.ListResourcesResult.next_cursor)
}

// -------------------------------------------------------------------

// ReadResourceRequest

// string method = 1;
inline void ReadResourceRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadResourceRequest::method() const {
  // @@protoc_insertion_point(field_get:mcp.ReadResourceRequest.method)
  return method_.GetNoArena();
}
inline void ReadResourceRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ReadResourceRequest.method)
}
#if LANG_CXX11
inline void ReadResourceRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ReadResourceRequest.method)
}
#endif
inline void ReadResourceRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ReadResourceRequest.method)
}
inline void ReadResourceRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ReadResourceRequest.method)
}
inline ::std::string* ReadResourceRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadResourceRequest::release_method() {
  // @@protoc_insertion_point(field_release:mcp.ReadResourceRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadResourceRequest::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:mcp.ReadResourceRequest.method)
}

// .mcp.ReadResourceParams params = 2;
inline bool ReadResourceRequest::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void ReadResourceRequest::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::mcp::ReadResourceParams& ReadResourceRequest::_internal_params() const {
  return *params_;
}
inline const ::mcp::ReadResourceParams& ReadResourceRequest::params() const {
  const ::mcp::ReadResourceParams* p = params_;
  // @@protoc_insertion_point(field_get:mcp.ReadResourceRequest.params)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ReadResourceParams*>(
      &::mcp::_ReadResourceParams_default_instance_);
}
inline ::mcp::ReadResourceParams* ReadResourceRequest::release_params() {
  // @@protoc_insertion_point(field_release:mcp.ReadResourceRequest.params)
  
  ::mcp::ReadResourceParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::mcp::ReadResourceParams* ReadResourceRequest::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ReadResourceParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceRequest.params)
  return params_;
}
inline void ReadResourceRequest::set_allocated_params(::mcp::ReadResourceParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ReadResourceRequest.params)
}

// -------------------------------------------------------------------

// ReadResourceParams

// string uri = 1;
inline void ReadResourceParams::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadResourceParams::uri() const {
  // @@protoc_insertion_point(field_get:mcp.ReadResourceParams.uri)
  return uri_.GetNoArena();
}
inline void ReadResourceParams::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ReadResourceParams.uri)
}
#if LANG_CXX11
inline void ReadResourceParams::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ReadResourceParams.uri)
}
#endif
inline void ReadResourceParams::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ReadResourceParams.uri)
}
inline void ReadResourceParams::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ReadResourceParams.uri)
}
inline ::std::string* ReadResourceParams::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceParams.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadResourceParams::release_uri() {
  // @@protoc_insertion_point(field_release:mcp.ReadResourceParams.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadResourceParams::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:mcp.ReadResourceParams.uri)
}

// -------------------------------------------------------------------

// ReadResourceResult

// repeated .mcp.ResourceContents contents = 1;
inline int ReadResourceResult::contents_size() const {
  return contents_.size();
}
inline void ReadResourceResult::clear_contents() {
  contents_.Clear();
}
inline ::mcp::ResourceContents* ReadResourceResult::mutable_contents(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ReadResourceResult.contents)
  return contents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mcp::ResourceContents >*
ReadResourceResult::mutable_contents() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ReadResourceResult.contents)
  return &contents_;
}
inline const ::mcp::ResourceContents& ReadResourceResult::contents(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ReadResourceResult.contents)
  return contents_.Get(index);
}
inline ::mcp::ResourceContents* ReadResourceResult::add_contents() {
  // @@protoc_insertion_point(field_add:mcp.ReadResourceResult.contents)
  return contents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcp::ResourceContents >&
ReadResourceResult::contents() const {
  // @@protoc_insertion_point(field_list:mcp.ReadResourceResult.contents)
  return contents_;
}

// -------------------------------------------------------------------

// PaginatedParams

// string cursor = 1;
inline void PaginatedParams::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PaginatedParams::cursor() const {
  // @@protoc_insertion_point(field_get:mcp.PaginatedParams.cursor)
  return cursor_.GetNoArena();
}
inline void PaginatedParams::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.PaginatedParams.cursor)
}
#if LANG_CXX11
inline void PaginatedParams::set_cursor(::std::string&& value) {
  
  cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.PaginatedParams.cursor)
}
#endif
inline void PaginatedParams::set_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.PaginatedParams.cursor)
}
inline void PaginatedParams::set_cursor(const char* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.PaginatedParams.cursor)
}
inline ::std::string* PaginatedParams::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:mcp.PaginatedParams.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaginatedParams::release_cursor() {
  // @@protoc_insertion_point(field_release:mcp.PaginatedParams.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaginatedParams::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:mcp.PaginatedParams.cursor)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcp

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mcp::Role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcp::Role>() {
  return ::mcp::Role_descriptor();
}
template <> struct is_proto_enum< ::mcp::LoggingLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcp::LoggingLevel>() {
  return ::mcp::LoggingLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mcp_2eproto
