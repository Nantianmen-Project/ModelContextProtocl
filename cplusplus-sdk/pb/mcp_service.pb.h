// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcp_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mcp_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mcp_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "mcp.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mcp_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mcp_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mcp_5fservice_2eproto;
namespace mcp {
class DeletePromptRequest;
struct DeletePromptRequestDefaultTypeInternal;
extern DeletePromptRequestDefaultTypeInternal _DeletePromptRequest_default_instance_;
class DeletePromptResponse;
struct DeletePromptResponseDefaultTypeInternal;
extern DeletePromptResponseDefaultTypeInternal _DeletePromptResponse_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class GetInputSchemaRequest;
struct GetInputSchemaRequestDefaultTypeInternal;
extern GetInputSchemaRequestDefaultTypeInternal _GetInputSchemaRequest_default_instance_;
class GetPromptRequest;
struct GetPromptRequestDefaultTypeInternal;
extern GetPromptRequestDefaultTypeInternal _GetPromptRequest_default_instance_;
class ListPromptsRequest;
struct ListPromptsRequestDefaultTypeInternal;
extern ListPromptsRequestDefaultTypeInternal _ListPromptsRequest_default_instance_;
class ListPromptsResponse;
struct ListPromptsResponseDefaultTypeInternal;
extern ListPromptsResponseDefaultTypeInternal _ListPromptsResponse_default_instance_;
class ListToolsRequest;
struct ListToolsRequestDefaultTypeInternal;
extern ListToolsRequestDefaultTypeInternal _ListToolsRequest_default_instance_;
class ListToolsResponse;
struct ListToolsResponseDefaultTypeInternal;
extern ListToolsResponseDefaultTypeInternal _ListToolsResponse_default_instance_;
class Prompt;
struct PromptDefaultTypeInternal;
extern PromptDefaultTypeInternal _Prompt_default_instance_;
class Prompt_MetadataEntry_DoNotUse;
struct Prompt_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Prompt_MetadataEntry_DoNotUseDefaultTypeInternal _Prompt_MetadataEntry_DoNotUse_default_instance_;
class RegisterInputSchemaRequest;
struct RegisterInputSchemaRequestDefaultTypeInternal;
extern RegisterInputSchemaRequestDefaultTypeInternal _RegisterInputSchemaRequest_default_instance_;
class RegisterInputSchemaResponse;
struct RegisterInputSchemaResponseDefaultTypeInternal;
extern RegisterInputSchemaResponseDefaultTypeInternal _RegisterInputSchemaResponse_default_instance_;
class RegisterPromptRequest;
struct RegisterPromptRequestDefaultTypeInternal;
extern RegisterPromptRequestDefaultTypeInternal _RegisterPromptRequest_default_instance_;
class RegisterPromptResponse;
struct RegisterPromptResponseDefaultTypeInternal;
extern RegisterPromptResponseDefaultTypeInternal _RegisterPromptResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class RegisterToolRequest;
struct RegisterToolRequestDefaultTypeInternal;
extern RegisterToolRequestDefaultTypeInternal _RegisterToolRequest_default_instance_;
class RegisterToolResponse;
struct RegisterToolResponseDefaultTypeInternal;
extern RegisterToolResponseDefaultTypeInternal _RegisterToolResponse_default_instance_;
class UpdatePromptRequest;
struct UpdatePromptRequestDefaultTypeInternal;
extern UpdatePromptRequestDefaultTypeInternal _UpdatePromptRequest_default_instance_;
class UpdatePromptResponse;
struct UpdatePromptResponseDefaultTypeInternal;
extern UpdatePromptResponseDefaultTypeInternal _UpdatePromptResponse_default_instance_;
}  // namespace mcp
PROTOBUF_NAMESPACE_OPEN
template<> ::mcp::DeletePromptRequest* Arena::CreateMaybeMessage<::mcp::DeletePromptRequest>(Arena*);
template<> ::mcp::DeletePromptResponse* Arena::CreateMaybeMessage<::mcp::DeletePromptResponse>(Arena*);
template<> ::mcp::Empty* Arena::CreateMaybeMessage<::mcp::Empty>(Arena*);
template<> ::mcp::GetInputSchemaRequest* Arena::CreateMaybeMessage<::mcp::GetInputSchemaRequest>(Arena*);
template<> ::mcp::GetPromptRequest* Arena::CreateMaybeMessage<::mcp::GetPromptRequest>(Arena*);
template<> ::mcp::ListPromptsRequest* Arena::CreateMaybeMessage<::mcp::ListPromptsRequest>(Arena*);
template<> ::mcp::ListPromptsResponse* Arena::CreateMaybeMessage<::mcp::ListPromptsResponse>(Arena*);
template<> ::mcp::ListToolsRequest* Arena::CreateMaybeMessage<::mcp::ListToolsRequest>(Arena*);
template<> ::mcp::ListToolsResponse* Arena::CreateMaybeMessage<::mcp::ListToolsResponse>(Arena*);
template<> ::mcp::Prompt* Arena::CreateMaybeMessage<::mcp::Prompt>(Arena*);
template<> ::mcp::Prompt_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::Prompt_MetadataEntry_DoNotUse>(Arena*);
template<> ::mcp::RegisterInputSchemaRequest* Arena::CreateMaybeMessage<::mcp::RegisterInputSchemaRequest>(Arena*);
template<> ::mcp::RegisterInputSchemaResponse* Arena::CreateMaybeMessage<::mcp::RegisterInputSchemaResponse>(Arena*);
template<> ::mcp::RegisterPromptRequest* Arena::CreateMaybeMessage<::mcp::RegisterPromptRequest>(Arena*);
template<> ::mcp::RegisterPromptResponse* Arena::CreateMaybeMessage<::mcp::RegisterPromptResponse>(Arena*);
template<> ::mcp::RegisterRequest* Arena::CreateMaybeMessage<::mcp::RegisterRequest>(Arena*);
template<> ::mcp::RegisterResponse* Arena::CreateMaybeMessage<::mcp::RegisterResponse>(Arena*);
template<> ::mcp::RegisterToolRequest* Arena::CreateMaybeMessage<::mcp::RegisterToolRequest>(Arena*);
template<> ::mcp::RegisterToolResponse* Arena::CreateMaybeMessage<::mcp::RegisterToolResponse>(Arena*);
template<> ::mcp::UpdatePromptRequest* Arena::CreateMaybeMessage<::mcp::UpdatePromptRequest>(Arena*);
template<> ::mcp::UpdatePromptResponse* Arena::CreateMaybeMessage<::mcp::UpdatePromptResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mcp {

// ===================================================================

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kCapabilitiesFieldNumber = 2,
    kClientInfoFieldNumber = 3,
  };
  // string client_id = 1;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // .mcp.ClientCapabilities capabilities = 2;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::mcp::ClientCapabilities& capabilities() const;
  PROTOBUF_NODISCARD ::mcp::ClientCapabilities* release_capabilities();
  ::mcp::ClientCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ClientCapabilities* capabilities);
  private:
  const ::mcp::ClientCapabilities& _internal_capabilities() const;
  ::mcp::ClientCapabilities* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::mcp::ClientCapabilities* capabilities);
  ::mcp::ClientCapabilities* unsafe_arena_release_capabilities();

  // .mcp.Implementation client_info = 3;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::mcp::Implementation& client_info() const;
  PROTOBUF_NODISCARD ::mcp::Implementation* release_client_info();
  ::mcp::Implementation* mutable_client_info();
  void set_allocated_client_info(::mcp::Implementation* client_info);
  private:
  const ::mcp::Implementation& _internal_client_info() const;
  ::mcp::Implementation* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::mcp::Implementation* client_info);
  ::mcp::Implementation* unsafe_arena_release_client_info();

  // @@protoc_insertion_point(class_scope:mcp.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::mcp::ClientCapabilities* capabilities_;
    ::mcp::Implementation* client_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kCapabilitiesFieldNumber = 3,
    kServerInfoFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .mcp.ServerCapabilities capabilities = 3;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::mcp::ServerCapabilities& capabilities() const;
  PROTOBUF_NODISCARD ::mcp::ServerCapabilities* release_capabilities();
  ::mcp::ServerCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ServerCapabilities* capabilities);
  private:
  const ::mcp::ServerCapabilities& _internal_capabilities() const;
  ::mcp::ServerCapabilities* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::mcp::ServerCapabilities* capabilities);
  ::mcp::ServerCapabilities* unsafe_arena_release_capabilities();

  // .mcp.Implementation server_info = 4;
  bool has_server_info() const;
  private:
  bool _internal_has_server_info() const;
  public:
  void clear_server_info();
  const ::mcp::Implementation& server_info() const;
  PROTOBUF_NODISCARD ::mcp::Implementation* release_server_info();
  ::mcp::Implementation* mutable_server_info();
  void set_allocated_server_info(::mcp::Implementation* server_info);
  private:
  const ::mcp::Implementation& _internal_server_info() const;
  ::mcp::Implementation* _internal_mutable_server_info();
  public:
  void unsafe_arena_set_allocated_server_info(
      ::mcp::Implementation* server_info);
  ::mcp::Implementation* unsafe_arena_release_server_info();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.RegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::mcp::ServerCapabilities* capabilities_;
    ::mcp::Implementation* server_info_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterInputSchemaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterInputSchemaRequest) */ {
 public:
  inline RegisterInputSchemaRequest() : RegisterInputSchemaRequest(nullptr) {}
  ~RegisterInputSchemaRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterInputSchemaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterInputSchemaRequest(const RegisterInputSchemaRequest& from);
  RegisterInputSchemaRequest(RegisterInputSchemaRequest&& from) noexcept
    : RegisterInputSchemaRequest() {
    *this = ::std::move(from);
  }

  inline RegisterInputSchemaRequest& operator=(const RegisterInputSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterInputSchemaRequest& operator=(RegisterInputSchemaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterInputSchemaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterInputSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterInputSchemaRequest*>(
               &_RegisterInputSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterInputSchemaRequest& a, RegisterInputSchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterInputSchemaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterInputSchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterInputSchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterInputSchemaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterInputSchemaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterInputSchemaRequest& from) {
    RegisterInputSchemaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterInputSchemaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterInputSchemaRequest";
  }
  protected:
  explicit RegisterInputSchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolNameFieldNumber = 1,
    kSchemaFieldNumber = 2,
  };
  // string tool_name = 1;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // .mcp.InputSchema schema = 2;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::mcp::InputSchema& schema() const;
  PROTOBUF_NODISCARD ::mcp::InputSchema* release_schema();
  ::mcp::InputSchema* mutable_schema();
  void set_allocated_schema(::mcp::InputSchema* schema);
  private:
  const ::mcp::InputSchema& _internal_schema() const;
  ::mcp::InputSchema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::mcp::InputSchema* schema);
  ::mcp::InputSchema* unsafe_arena_release_schema();

  // @@protoc_insertion_point(class_scope:mcp.RegisterInputSchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    ::mcp::InputSchema* schema_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterInputSchemaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterInputSchemaResponse) */ {
 public:
  inline RegisterInputSchemaResponse() : RegisterInputSchemaResponse(nullptr) {}
  ~RegisterInputSchemaResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterInputSchemaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterInputSchemaResponse(const RegisterInputSchemaResponse& from);
  RegisterInputSchemaResponse(RegisterInputSchemaResponse&& from) noexcept
    : RegisterInputSchemaResponse() {
    *this = ::std::move(from);
  }

  inline RegisterInputSchemaResponse& operator=(const RegisterInputSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterInputSchemaResponse& operator=(RegisterInputSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterInputSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterInputSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterInputSchemaResponse*>(
               &_RegisterInputSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterInputSchemaResponse& a, RegisterInputSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterInputSchemaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterInputSchemaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterInputSchemaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterInputSchemaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterInputSchemaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterInputSchemaResponse& from) {
    RegisterInputSchemaResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterInputSchemaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterInputSchemaResponse";
  }
  protected:
  explicit RegisterInputSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string schema_id = 2;
  void clear_schema_id();
  const std::string& schema_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_id();
  PROTOBUF_NODISCARD std::string* release_schema_id();
  void set_allocated_schema_id(std::string* schema_id);
  private:
  const std::string& _internal_schema_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_id(const std::string& value);
  std::string* _internal_mutable_schema_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.RegisterInputSchemaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetInputSchemaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.GetInputSchemaRequest) */ {
 public:
  inline GetInputSchemaRequest() : GetInputSchemaRequest(nullptr) {}
  ~GetInputSchemaRequest() override;
  explicit PROTOBUF_CONSTEXPR GetInputSchemaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInputSchemaRequest(const GetInputSchemaRequest& from);
  GetInputSchemaRequest(GetInputSchemaRequest&& from) noexcept
    : GetInputSchemaRequest() {
    *this = ::std::move(from);
  }

  inline GetInputSchemaRequest& operator=(const GetInputSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInputSchemaRequest& operator=(GetInputSchemaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInputSchemaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInputSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const GetInputSchemaRequest*>(
               &_GetInputSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetInputSchemaRequest& a, GetInputSchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInputSchemaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInputSchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInputSchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInputSchemaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInputSchemaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInputSchemaRequest& from) {
    GetInputSchemaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInputSchemaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.GetInputSchemaRequest";
  }
  protected:
  explicit GetInputSchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolNameFieldNumber = 1,
  };
  // string tool_name = 1;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // @@protoc_insertion_point(class_scope:mcp.GetInputSchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterToolRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterToolRequest) */ {
 public:
  inline RegisterToolRequest() : RegisterToolRequest(nullptr) {}
  ~RegisterToolRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterToolRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterToolRequest(const RegisterToolRequest& from);
  RegisterToolRequest(RegisterToolRequest&& from) noexcept
    : RegisterToolRequest() {
    *this = ::std::move(from);
  }

  inline RegisterToolRequest& operator=(const RegisterToolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterToolRequest& operator=(RegisterToolRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterToolRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterToolRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterToolRequest*>(
               &_RegisterToolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegisterToolRequest& a, RegisterToolRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterToolRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterToolRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterToolRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterToolRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterToolRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterToolRequest& from) {
    RegisterToolRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterToolRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterToolRequest";
  }
  protected:
  explicit RegisterToolRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolFieldNumber = 1,
  };
  // .mcp.Tool tool = 1;
  bool has_tool() const;
  private:
  bool _internal_has_tool() const;
  public:
  void clear_tool();
  const ::mcp::Tool& tool() const;
  PROTOBUF_NODISCARD ::mcp::Tool* release_tool();
  ::mcp::Tool* mutable_tool();
  void set_allocated_tool(::mcp::Tool* tool);
  private:
  const ::mcp::Tool& _internal_tool() const;
  ::mcp::Tool* _internal_mutable_tool();
  public:
  void unsafe_arena_set_allocated_tool(
      ::mcp::Tool* tool);
  ::mcp::Tool* unsafe_arena_release_tool();

  // @@protoc_insertion_point(class_scope:mcp.RegisterToolRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mcp::Tool* tool_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterToolResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterToolResponse) */ {
 public:
  inline RegisterToolResponse() : RegisterToolResponse(nullptr) {}
  ~RegisterToolResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterToolResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterToolResponse(const RegisterToolResponse& from);
  RegisterToolResponse(RegisterToolResponse&& from) noexcept
    : RegisterToolResponse() {
    *this = ::std::move(from);
  }

  inline RegisterToolResponse& operator=(const RegisterToolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterToolResponse& operator=(RegisterToolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterToolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterToolResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterToolResponse*>(
               &_RegisterToolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterToolResponse& a, RegisterToolResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterToolResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterToolResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterToolResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterToolResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterToolResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterToolResponse& from) {
    RegisterToolResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterToolResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterToolResponse";
  }
  protected:
  explicit RegisterToolResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string tool_id = 2;
  void clear_tool_id();
  const std::string& tool_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_id();
  PROTOBUF_NODISCARD std::string* release_tool_id();
  void set_allocated_tool_id(std::string* tool_id);
  private:
  const std::string& _internal_tool_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_id(const std::string& value);
  std::string* _internal_mutable_tool_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.RegisterToolResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListToolsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ListToolsRequest) */ {
 public:
  inline ListToolsRequest() : ListToolsRequest(nullptr) {}
  ~ListToolsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListToolsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListToolsRequest(const ListToolsRequest& from);
  ListToolsRequest(ListToolsRequest&& from) noexcept
    : ListToolsRequest() {
    *this = ::std::move(from);
  }

  inline ListToolsRequest& operator=(const ListToolsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListToolsRequest& operator=(ListToolsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListToolsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListToolsRequest* internal_default_instance() {
    return reinterpret_cast<const ListToolsRequest*>(
               &_ListToolsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListToolsRequest& a, ListToolsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListToolsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListToolsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListToolsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListToolsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListToolsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListToolsRequest& from) {
    ListToolsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListToolsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ListToolsRequest";
  }
  protected:
  explicit ListToolsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .mcp.PaginatedParams params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::mcp::PaginatedParams& params() const;
  PROTOBUF_NODISCARD ::mcp::PaginatedParams* release_params();
  ::mcp::PaginatedParams* mutable_params();
  void set_allocated_params(::mcp::PaginatedParams* params);
  private:
  const ::mcp::PaginatedParams& _internal_params() const;
  ::mcp::PaginatedParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::mcp::PaginatedParams* params);
  ::mcp::PaginatedParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:mcp.ListToolsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mcp::PaginatedParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListToolsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ListToolsResponse) */ {
 public:
  inline ListToolsResponse() : ListToolsResponse(nullptr) {}
  ~ListToolsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListToolsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListToolsResponse(const ListToolsResponse& from);
  ListToolsResponse(ListToolsResponse&& from) noexcept
    : ListToolsResponse() {
    *this = ::std::move(from);
  }

  inline ListToolsResponse& operator=(const ListToolsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListToolsResponse& operator=(ListToolsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListToolsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListToolsResponse* internal_default_instance() {
    return reinterpret_cast<const ListToolsResponse*>(
               &_ListToolsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListToolsResponse& a, ListToolsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListToolsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListToolsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListToolsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListToolsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListToolsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListToolsResponse& from) {
    ListToolsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListToolsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ListToolsResponse";
  }
  protected:
  explicit ListToolsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolsFieldNumber = 1,
    kNextCursorFieldNumber = 2,
  };
  // repeated .mcp.Tool tools = 1;
  int tools_size() const;
  private:
  int _internal_tools_size() const;
  public:
  void clear_tools();
  ::mcp::Tool* mutable_tools(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Tool >*
      mutable_tools();
  private:
  const ::mcp::Tool& _internal_tools(int index) const;
  ::mcp::Tool* _internal_add_tools();
  public:
  const ::mcp::Tool& tools(int index) const;
  ::mcp::Tool* add_tools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Tool >&
      tools() const;

  // string next_cursor = 2;
  void clear_next_cursor();
  const std::string& next_cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_cursor();
  PROTOBUF_NODISCARD std::string* release_next_cursor();
  void set_allocated_next_cursor(std::string* next_cursor);
  private:
  const std::string& _internal_next_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_cursor(const std::string& value);
  std::string* _internal_mutable_next_cursor();
  public:

  // @@protoc_insertion_point(class_scope:mcp.ListToolsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Tool > tools_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_cursor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Prompt_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Prompt_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Prompt_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Prompt_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Prompt_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Prompt_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Prompt_MetadataEntry_DoNotUse& other);
  static const Prompt_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Prompt_MetadataEntry_DoNotUse*>(&_Prompt_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcp.Prompt.MetadataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};

// -------------------------------------------------------------------

class Prompt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.Prompt) */ {
 public:
  inline Prompt() : Prompt(nullptr) {}
  ~Prompt() override;
  explicit PROTOBUF_CONSTEXPR Prompt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Prompt(const Prompt& from);
  Prompt(Prompt&& from) noexcept
    : Prompt() {
    *this = ::std::move(from);
  }

  inline Prompt& operator=(const Prompt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Prompt& operator=(Prompt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Prompt& default_instance() {
    return *internal_default_instance();
  }
  static inline const Prompt* internal_default_instance() {
    return reinterpret_cast<const Prompt*>(
               &_Prompt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Prompt& a, Prompt& b) {
    a.Swap(&b);
  }
  inline void Swap(Prompt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Prompt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Prompt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Prompt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Prompt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Prompt& from) {
    Prompt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Prompt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Prompt";
  }
  protected:
  explicit Prompt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 6,
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kModelPreferencesFieldNumber = 4,
    kAnnotationsFieldNumber = 5,
  };
  // map<string, bytes> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .mcp.ModelPreferences model_preferences = 4;
  bool has_model_preferences() const;
  private:
  bool _internal_has_model_preferences() const;
  public:
  void clear_model_preferences();
  const ::mcp::ModelPreferences& model_preferences() const;
  PROTOBUF_NODISCARD ::mcp::ModelPreferences* release_model_preferences();
  ::mcp::ModelPreferences* mutable_model_preferences();
  void set_allocated_model_preferences(::mcp::ModelPreferences* model_preferences);
  private:
  const ::mcp::ModelPreferences& _internal_model_preferences() const;
  ::mcp::ModelPreferences* _internal_mutable_model_preferences();
  public:
  void unsafe_arena_set_allocated_model_preferences(
      ::mcp::ModelPreferences* model_preferences);
  ::mcp::ModelPreferences* unsafe_arena_release_model_preferences();

  // .mcp.Annotations annotations = 5;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::mcp::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  ::mcp::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::mcp::Annotations* annotations);
  ::mcp::Annotations* unsafe_arena_release_annotations();

  // @@protoc_insertion_point(class_scope:mcp.Prompt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Prompt_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::mcp::ModelPreferences* model_preferences_;
    ::mcp::Annotations* annotations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterPromptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterPromptRequest) */ {
 public:
  inline RegisterPromptRequest() : RegisterPromptRequest(nullptr) {}
  ~RegisterPromptRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterPromptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterPromptRequest(const RegisterPromptRequest& from);
  RegisterPromptRequest(RegisterPromptRequest&& from) noexcept
    : RegisterPromptRequest() {
    *this = ::std::move(from);
  }

  inline RegisterPromptRequest& operator=(const RegisterPromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterPromptRequest& operator=(RegisterPromptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterPromptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterPromptRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterPromptRequest*>(
               &_RegisterPromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RegisterPromptRequest& a, RegisterPromptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterPromptRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterPromptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterPromptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterPromptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterPromptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterPromptRequest& from) {
    RegisterPromptRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPromptRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterPromptRequest";
  }
  protected:
  explicit RegisterPromptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPromptFieldNumber = 1,
  };
  // .mcp.Prompt prompt = 1;
  bool has_prompt() const;
  private:
  bool _internal_has_prompt() const;
  public:
  void clear_prompt();
  const ::mcp::Prompt& prompt() const;
  PROTOBUF_NODISCARD ::mcp::Prompt* release_prompt();
  ::mcp::Prompt* mutable_prompt();
  void set_allocated_prompt(::mcp::Prompt* prompt);
  private:
  const ::mcp::Prompt& _internal_prompt() const;
  ::mcp::Prompt* _internal_mutable_prompt();
  public:
  void unsafe_arena_set_allocated_prompt(
      ::mcp::Prompt* prompt);
  ::mcp::Prompt* unsafe_arena_release_prompt();

  // @@protoc_insertion_point(class_scope:mcp.RegisterPromptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mcp::Prompt* prompt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterPromptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterPromptResponse) */ {
 public:
  inline RegisterPromptResponse() : RegisterPromptResponse(nullptr) {}
  ~RegisterPromptResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterPromptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterPromptResponse(const RegisterPromptResponse& from);
  RegisterPromptResponse(RegisterPromptResponse&& from) noexcept
    : RegisterPromptResponse() {
    *this = ::std::move(from);
  }

  inline RegisterPromptResponse& operator=(const RegisterPromptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterPromptResponse& operator=(RegisterPromptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterPromptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterPromptResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterPromptResponse*>(
               &_RegisterPromptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RegisterPromptResponse& a, RegisterPromptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterPromptResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterPromptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterPromptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterPromptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterPromptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterPromptResponse& from) {
    RegisterPromptResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPromptResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.RegisterPromptResponse";
  }
  protected:
  explicit RegisterPromptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPromptIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string prompt_id = 2;
  void clear_prompt_id();
  const std::string& prompt_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prompt_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prompt_id();
  PROTOBUF_NODISCARD std::string* release_prompt_id();
  void set_allocated_prompt_id(std::string* prompt_id);
  private:
  const std::string& _internal_prompt_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prompt_id(const std::string& value);
  std::string* _internal_mutable_prompt_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.RegisterPromptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prompt_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetPromptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.GetPromptRequest) */ {
 public:
  inline GetPromptRequest() : GetPromptRequest(nullptr) {}
  ~GetPromptRequest() override;
  explicit PROTOBUF_CONSTEXPR GetPromptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPromptRequest(const GetPromptRequest& from);
  GetPromptRequest(GetPromptRequest&& from) noexcept
    : GetPromptRequest() {
    *this = ::std::move(from);
  }

  inline GetPromptRequest& operator=(const GetPromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPromptRequest& operator=(GetPromptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPromptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPromptRequest* internal_default_instance() {
    return reinterpret_cast<const GetPromptRequest*>(
               &_GetPromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetPromptRequest& a, GetPromptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPromptRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPromptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPromptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPromptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPromptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPromptRequest& from) {
    GetPromptRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPromptRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.GetPromptRequest";
  }
  protected:
  explicit GetPromptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mcp.GetPromptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListPromptsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ListPromptsRequest) */ {
 public:
  inline ListPromptsRequest() : ListPromptsRequest(nullptr) {}
  ~ListPromptsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListPromptsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPromptsRequest(const ListPromptsRequest& from);
  ListPromptsRequest(ListPromptsRequest&& from) noexcept
    : ListPromptsRequest() {
    *this = ::std::move(from);
  }

  inline ListPromptsRequest& operator=(const ListPromptsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPromptsRequest& operator=(ListPromptsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPromptsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPromptsRequest* internal_default_instance() {
    return reinterpret_cast<const ListPromptsRequest*>(
               &_ListPromptsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListPromptsRequest& a, ListPromptsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPromptsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPromptsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPromptsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPromptsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPromptsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPromptsRequest& from) {
    ListPromptsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPromptsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ListPromptsRequest";
  }
  protected:
  explicit ListPromptsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 2,
    kParamsFieldNumber = 1,
  };
  // string filter = 2;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // .mcp.PaginatedParams params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::mcp::PaginatedParams& params() const;
  PROTOBUF_NODISCARD ::mcp::PaginatedParams* release_params();
  ::mcp::PaginatedParams* mutable_params();
  void set_allocated_params(::mcp::PaginatedParams* params);
  private:
  const ::mcp::PaginatedParams& _internal_params() const;
  ::mcp::PaginatedParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::mcp::PaginatedParams* params);
  ::mcp::PaginatedParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:mcp.ListPromptsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::mcp::PaginatedParams* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListPromptsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.ListPromptsResponse) */ {
 public:
  inline ListPromptsResponse() : ListPromptsResponse(nullptr) {}
  ~ListPromptsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListPromptsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPromptsResponse(const ListPromptsResponse& from);
  ListPromptsResponse(ListPromptsResponse&& from) noexcept
    : ListPromptsResponse() {
    *this = ::std::move(from);
  }

  inline ListPromptsResponse& operator=(const ListPromptsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPromptsResponse& operator=(ListPromptsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPromptsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPromptsResponse* internal_default_instance() {
    return reinterpret_cast<const ListPromptsResponse*>(
               &_ListPromptsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListPromptsResponse& a, ListPromptsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPromptsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPromptsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPromptsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPromptsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPromptsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPromptsResponse& from) {
    ListPromptsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPromptsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.ListPromptsResponse";
  }
  protected:
  explicit ListPromptsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPromptsFieldNumber = 1,
    kNextCursorFieldNumber = 2,
  };
  // repeated .mcp.Prompt prompts = 1;
  int prompts_size() const;
  private:
  int _internal_prompts_size() const;
  public:
  void clear_prompts();
  ::mcp::Prompt* mutable_prompts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Prompt >*
      mutable_prompts();
  private:
  const ::mcp::Prompt& _internal_prompts(int index) const;
  ::mcp::Prompt* _internal_add_prompts();
  public:
  const ::mcp::Prompt& prompts(int index) const;
  ::mcp::Prompt* add_prompts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Prompt >&
      prompts() const;

  // string next_cursor = 2;
  void clear_next_cursor();
  const std::string& next_cursor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_cursor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_cursor();
  PROTOBUF_NODISCARD std::string* release_next_cursor();
  void set_allocated_next_cursor(std::string* next_cursor);
  private:
  const std::string& _internal_next_cursor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_cursor(const std::string& value);
  std::string* _internal_mutable_next_cursor();
  public:

  // @@protoc_insertion_point(class_scope:mcp.ListPromptsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Prompt > prompts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_cursor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdatePromptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.UpdatePromptRequest) */ {
 public:
  inline UpdatePromptRequest() : UpdatePromptRequest(nullptr) {}
  ~UpdatePromptRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdatePromptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePromptRequest(const UpdatePromptRequest& from);
  UpdatePromptRequest(UpdatePromptRequest&& from) noexcept
    : UpdatePromptRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePromptRequest& operator=(const UpdatePromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePromptRequest& operator=(UpdatePromptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePromptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePromptRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePromptRequest*>(
               &_UpdatePromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdatePromptRequest& a, UpdatePromptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePromptRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePromptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePromptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePromptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePromptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdatePromptRequest& from) {
    UpdatePromptRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePromptRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.UpdatePromptRequest";
  }
  protected:
  explicit UpdatePromptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPromptFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mcp.Prompt prompt = 2;
  bool has_prompt() const;
  private:
  bool _internal_has_prompt() const;
  public:
  void clear_prompt();
  const ::mcp::Prompt& prompt() const;
  PROTOBUF_NODISCARD ::mcp::Prompt* release_prompt();
  ::mcp::Prompt* mutable_prompt();
  void set_allocated_prompt(::mcp::Prompt* prompt);
  private:
  const ::mcp::Prompt& _internal_prompt() const;
  ::mcp::Prompt* _internal_mutable_prompt();
  public:
  void unsafe_arena_set_allocated_prompt(
      ::mcp::Prompt* prompt);
  ::mcp::Prompt* unsafe_arena_release_prompt();

  // @@protoc_insertion_point(class_scope:mcp.UpdatePromptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::mcp::Prompt* prompt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdatePromptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.UpdatePromptResponse) */ {
 public:
  inline UpdatePromptResponse() : UpdatePromptResponse(nullptr) {}
  ~UpdatePromptResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdatePromptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePromptResponse(const UpdatePromptResponse& from);
  UpdatePromptResponse(UpdatePromptResponse&& from) noexcept
    : UpdatePromptResponse() {
    *this = ::std::move(from);
  }

  inline UpdatePromptResponse& operator=(const UpdatePromptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePromptResponse& operator=(UpdatePromptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePromptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePromptResponse* internal_default_instance() {
    return reinterpret_cast<const UpdatePromptResponse*>(
               &_UpdatePromptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdatePromptResponse& a, UpdatePromptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePromptResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePromptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePromptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePromptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePromptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdatePromptResponse& from) {
    UpdatePromptResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePromptResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.UpdatePromptResponse";
  }
  protected:
  explicit UpdatePromptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.UpdatePromptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeletePromptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.DeletePromptRequest) */ {
 public:
  inline DeletePromptRequest() : DeletePromptRequest(nullptr) {}
  ~DeletePromptRequest() override;
  explicit PROTOBUF_CONSTEXPR DeletePromptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePromptRequest(const DeletePromptRequest& from);
  DeletePromptRequest(DeletePromptRequest&& from) noexcept
    : DeletePromptRequest() {
    *this = ::std::move(from);
  }

  inline DeletePromptRequest& operator=(const DeletePromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePromptRequest& operator=(DeletePromptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePromptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePromptRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePromptRequest*>(
               &_DeletePromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeletePromptRequest& a, DeletePromptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePromptRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePromptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePromptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeletePromptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePromptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeletePromptRequest& from) {
    DeletePromptRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePromptRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.DeletePromptRequest";
  }
  protected:
  explicit DeletePromptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mcp.DeletePromptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeletePromptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcp.DeletePromptResponse) */ {
 public:
  inline DeletePromptResponse() : DeletePromptResponse(nullptr) {}
  ~DeletePromptResponse() override;
  explicit PROTOBUF_CONSTEXPR DeletePromptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePromptResponse(const DeletePromptResponse& from);
  DeletePromptResponse(DeletePromptResponse&& from) noexcept
    : DeletePromptResponse() {
    *this = ::std::move(from);
  }

  inline DeletePromptResponse& operator=(const DeletePromptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePromptResponse& operator=(DeletePromptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePromptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePromptResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePromptResponse*>(
               &_DeletePromptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DeletePromptResponse& a, DeletePromptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePromptResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePromptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePromptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeletePromptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePromptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeletePromptResponse& from) {
    DeletePromptResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePromptResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.DeletePromptResponse";
  }
  protected:
  explicit DeletePromptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcp.DeletePromptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mcp.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcp.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_mcp_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterRequest

// string client_id = 1;
inline void RegisterRequest::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& RegisterRequest::client_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.RegisterRequest.client_id)
}
inline std::string* RegisterRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterRequest.client_id)
  return _s;
}
inline const std::string& RegisterRequest::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void RegisterRequest::_internal_set_client_id(const std::string& value) {
  
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_client_id() {
  
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void RegisterRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterRequest.client_id)
}

// .mcp.ClientCapabilities capabilities = 2;
inline bool RegisterRequest::_internal_has_capabilities() const {
  return this != internal_default_instance() && _impl_.capabilities_ != nullptr;
}
inline bool RegisterRequest::has_capabilities() const {
  return _internal_has_capabilities();
}
inline const ::mcp::ClientCapabilities& RegisterRequest::_internal_capabilities() const {
  const ::mcp::ClientCapabilities* p = _impl_.capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ClientCapabilities&>(
      ::mcp::_ClientCapabilities_default_instance_);
}
inline const ::mcp::ClientCapabilities& RegisterRequest::capabilities() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterRequest.capabilities)
  return _internal_capabilities();
}
inline void RegisterRequest::unsafe_arena_set_allocated_capabilities(
    ::mcp::ClientCapabilities* capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  _impl_.capabilities_ = capabilities;
  if (capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RegisterRequest.capabilities)
}
inline ::mcp::ClientCapabilities* RegisterRequest::release_capabilities() {
  
  ::mcp::ClientCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ClientCapabilities* RegisterRequest::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.RegisterRequest.capabilities)
  
  ::mcp::ClientCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
  return temp;
}
inline ::mcp::ClientCapabilities* RegisterRequest::_internal_mutable_capabilities() {
  
  if (_impl_.capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ClientCapabilities>(GetArenaForAllocation());
    _impl_.capabilities_ = p;
  }
  return _impl_.capabilities_;
}
inline ::mcp::ClientCapabilities* RegisterRequest::mutable_capabilities() {
  ::mcp::ClientCapabilities* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterRequest.capabilities)
  return _msg;
}
inline void RegisterRequest::set_allocated_capabilities(::mcp::ClientCapabilities* capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  if (capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilities));
    if (message_arena != submessage_arena) {
      capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterRequest.capabilities)
}

// .mcp.Implementation client_info = 3;
inline bool RegisterRequest::_internal_has_client_info() const {
  return this != internal_default_instance() && _impl_.client_info_ != nullptr;
}
inline bool RegisterRequest::has_client_info() const {
  return _internal_has_client_info();
}
inline const ::mcp::Implementation& RegisterRequest::_internal_client_info() const {
  const ::mcp::Implementation* p = _impl_.client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Implementation&>(
      ::mcp::_Implementation_default_instance_);
}
inline const ::mcp::Implementation& RegisterRequest::client_info() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterRequest.client_info)
  return _internal_client_info();
}
inline void RegisterRequest::unsafe_arena_set_allocated_client_info(
    ::mcp::Implementation* client_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_info_);
  }
  _impl_.client_info_ = client_info;
  if (client_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RegisterRequest.client_info)
}
inline ::mcp::Implementation* RegisterRequest::release_client_info() {
  
  ::mcp::Implementation* temp = _impl_.client_info_;
  _impl_.client_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Implementation* RegisterRequest::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_release:mcp.RegisterRequest.client_info)
  
  ::mcp::Implementation* temp = _impl_.client_info_;
  _impl_.client_info_ = nullptr;
  return temp;
}
inline ::mcp::Implementation* RegisterRequest::_internal_mutable_client_info() {
  
  if (_impl_.client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaForAllocation());
    _impl_.client_info_ = p;
  }
  return _impl_.client_info_;
}
inline ::mcp::Implementation* RegisterRequest::mutable_client_info() {
  ::mcp::Implementation* _msg = _internal_mutable_client_info();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterRequest.client_info)
  return _msg;
}
inline void RegisterRequest::set_allocated_client_info(::mcp::Implementation* client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_info_);
  }
  if (client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info));
    if (message_arena != submessage_arena) {
      client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterRequest.client_info)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool success = 1;
inline void RegisterResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RegisterResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.success)
  return _internal_success();
}
inline void RegisterResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RegisterResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mcp.RegisterResponse.success)
}

// string session_id = 2;
inline void RegisterResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& RegisterResponse::session_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.RegisterResponse.session_id)
}
inline std::string* RegisterResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterResponse.session_id)
  return _s;
}
inline const std::string& RegisterResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void RegisterResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void RegisterResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterResponse.session_id)
}

// .mcp.ServerCapabilities capabilities = 3;
inline bool RegisterResponse::_internal_has_capabilities() const {
  return this != internal_default_instance() && _impl_.capabilities_ != nullptr;
}
inline bool RegisterResponse::has_capabilities() const {
  return _internal_has_capabilities();
}
inline const ::mcp::ServerCapabilities& RegisterResponse::_internal_capabilities() const {
  const ::mcp::ServerCapabilities* p = _impl_.capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ServerCapabilities&>(
      ::mcp::_ServerCapabilities_default_instance_);
}
inline const ::mcp::ServerCapabilities& RegisterResponse::capabilities() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.capabilities)
  return _internal_capabilities();
}
inline void RegisterResponse::unsafe_arena_set_allocated_capabilities(
    ::mcp::ServerCapabilities* capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  _impl_.capabilities_ = capabilities;
  if (capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RegisterResponse.capabilities)
}
inline ::mcp::ServerCapabilities* RegisterResponse::release_capabilities() {
  
  ::mcp::ServerCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ServerCapabilities* RegisterResponse::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.RegisterResponse.capabilities)
  
  ::mcp::ServerCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
  return temp;
}
inline ::mcp::ServerCapabilities* RegisterResponse::_internal_mutable_capabilities() {
  
  if (_impl_.capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ServerCapabilities>(GetArenaForAllocation());
    _impl_.capabilities_ = p;
  }
  return _impl_.capabilities_;
}
inline ::mcp::ServerCapabilities* RegisterResponse::mutable_capabilities() {
  ::mcp::ServerCapabilities* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterResponse.capabilities)
  return _msg;
}
inline void RegisterResponse::set_allocated_capabilities(::mcp::ServerCapabilities* capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  if (capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilities));
    if (message_arena != submessage_arena) {
      capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterResponse.capabilities)
}

// .mcp.Implementation server_info = 4;
inline bool RegisterResponse::_internal_has_server_info() const {
  return this != internal_default_instance() && _impl_.server_info_ != nullptr;
}
inline bool RegisterResponse::has_server_info() const {
  return _internal_has_server_info();
}
inline const ::mcp::Implementation& RegisterResponse::_internal_server_info() const {
  const ::mcp::Implementation* p = _impl_.server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Implementation&>(
      ::mcp::_Implementation_default_instance_);
}
inline const ::mcp::Implementation& RegisterResponse::server_info() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.server_info)
  return _internal_server_info();
}
inline void RegisterResponse::unsafe_arena_set_allocated_server_info(
    ::mcp::Implementation* server_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_info_);
  }
  _impl_.server_info_ = server_info;
  if (server_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RegisterResponse.server_info)
}
inline ::mcp::Implementation* RegisterResponse::release_server_info() {
  
  ::mcp::Implementation* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Implementation* RegisterResponse::unsafe_arena_release_server_info() {
  // @@protoc_insertion_point(field_release:mcp.RegisterResponse.server_info)
  
  ::mcp::Implementation* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  return temp;
}
inline ::mcp::Implementation* RegisterResponse::_internal_mutable_server_info() {
  
  if (_impl_.server_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaForAllocation());
    _impl_.server_info_ = p;
  }
  return _impl_.server_info_;
}
inline ::mcp::Implementation* RegisterResponse::mutable_server_info() {
  ::mcp::Implementation* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterResponse.server_info)
  return _msg;
}
inline void RegisterResponse::set_allocated_server_info(::mcp::Implementation* server_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_info_);
  }
  if (server_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_info));
    if (message_arena != submessage_arena) {
      server_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_info_ = server_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterResponse.server_info)
}

// -------------------------------------------------------------------

// RegisterInputSchemaRequest

// string tool_name = 1;
inline void RegisterInputSchemaRequest::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& RegisterInputSchemaRequest::tool_name() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaRequest.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterInputSchemaRequest::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.RegisterInputSchemaRequest.tool_name)
}
inline std::string* RegisterInputSchemaRequest::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterInputSchemaRequest.tool_name)
  return _s;
}
inline const std::string& RegisterInputSchemaRequest::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void RegisterInputSchemaRequest::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterInputSchemaRequest::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterInputSchemaRequest::release_tool_name() {
  // @@protoc_insertion_point(field_release:mcp.RegisterInputSchemaRequest.tool_name)
  return _impl_.tool_name_.Release();
}
inline void RegisterInputSchemaRequest::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterInputSchemaRequest.tool_name)
}

// .mcp.InputSchema schema = 2;
inline bool RegisterInputSchemaRequest::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool RegisterInputSchemaRequest::has_schema() const {
  return _internal_has_schema();
}
inline const ::mcp::InputSchema& RegisterInputSchemaRequest::_internal_schema() const {
  const ::mcp::InputSchema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::InputSchema&>(
      ::mcp::_InputSchema_default_instance_);
}
inline const ::mcp::InputSchema& RegisterInputSchemaRequest::schema() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaRequest.schema)
  return _internal_schema();
}
inline void RegisterInputSchemaRequest::unsafe_arena_set_allocated_schema(
    ::mcp::InputSchema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RegisterInputSchemaRequest.schema)
}
inline ::mcp::InputSchema* RegisterInputSchemaRequest::release_schema() {
  
  ::mcp::InputSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::InputSchema* RegisterInputSchemaRequest::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:mcp.RegisterInputSchemaRequest.schema)
  
  ::mcp::InputSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::mcp::InputSchema* RegisterInputSchemaRequest::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::InputSchema>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::mcp::InputSchema* RegisterInputSchemaRequest::mutable_schema() {
  ::mcp::InputSchema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterInputSchemaRequest.schema)
  return _msg;
}
inline void RegisterInputSchemaRequest::set_allocated_schema(::mcp::InputSchema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema));
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterInputSchemaRequest.schema)
}

// -------------------------------------------------------------------

// RegisterInputSchemaResponse

// bool success = 1;
inline void RegisterInputSchemaResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterInputSchemaResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RegisterInputSchemaResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaResponse.success)
  return _internal_success();
}
inline void RegisterInputSchemaResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RegisterInputSchemaResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mcp.RegisterInputSchemaResponse.success)
}

// string schema_id = 2;
inline void RegisterInputSchemaResponse::clear_schema_id() {
  _impl_.schema_id_.ClearToEmpty();
}
inline const std::string& RegisterInputSchemaResponse::schema_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaResponse.schema_id)
  return _internal_schema_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterInputSchemaResponse::set_schema_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.RegisterInputSchemaResponse.schema_id)
}
inline std::string* RegisterInputSchemaResponse::mutable_schema_id() {
  std::string* _s = _internal_mutable_schema_id();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterInputSchemaResponse.schema_id)
  return _s;
}
inline const std::string& RegisterInputSchemaResponse::_internal_schema_id() const {
  return _impl_.schema_id_.Get();
}
inline void RegisterInputSchemaResponse::_internal_set_schema_id(const std::string& value) {
  
  _impl_.schema_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterInputSchemaResponse::_internal_mutable_schema_id() {
  
  return _impl_.schema_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterInputSchemaResponse::release_schema_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterInputSchemaResponse.schema_id)
  return _impl_.schema_id_.Release();
}
inline void RegisterInputSchemaResponse::set_allocated_schema_id(std::string* schema_id) {
  if (schema_id != nullptr) {
    
  } else {
    
  }
  _impl_.schema_id_.SetAllocated(schema_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_id_.IsDefault()) {
    _impl_.schema_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterInputSchemaResponse.schema_id)
}

// -------------------------------------------------------------------

// GetInputSchemaRequest

// string tool_name = 1;
inline void GetInputSchemaRequest::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& GetInputSchemaRequest::tool_name() const {
  // @@protoc_insertion_point(field_get:mcp.GetInputSchemaRequest.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInputSchemaRequest::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.GetInputSchemaRequest.tool_name)
}
inline std::string* GetInputSchemaRequest::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:mcp.GetInputSchemaRequest.tool_name)
  return _s;
}
inline const std::string& GetInputSchemaRequest::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void GetInputSchemaRequest::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInputSchemaRequest::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInputSchemaRequest::release_tool_name() {
  // @@protoc_insertion_point(field_release:mcp.GetInputSchemaRequest.tool_name)
  return _impl_.tool_name_.Release();
}
inline void GetInputSchemaRequest::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.GetInputSchemaRequest.tool_name)
}

// -------------------------------------------------------------------

// RegisterToolRequest

// .mcp.Tool tool = 1;
inline bool RegisterToolRequest::_internal_has_tool() const {
  return this != internal_default_instance() && _impl_.tool_ != nullptr;
}
inline bool RegisterToolRequest::has_tool() const {
  return _internal_has_tool();
}
inline const ::mcp::Tool& RegisterToolRequest::_internal_tool() const {
  const ::mcp::Tool* p = _impl_.tool_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Tool&>(
      ::mcp::_Tool_default_instance_);
}
inline const ::mcp::Tool& RegisterToolRequest::tool() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterToolRequest.tool)
  return _internal_tool();
}
inline void RegisterToolRequest::unsafe_arena_set_allocated_tool(
    ::mcp::Tool* tool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_);
  }
  _impl_.tool_ = tool;
  if (tool) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RegisterToolRequest.tool)
}
inline ::mcp::Tool* RegisterToolRequest::release_tool() {
  
  ::mcp::Tool* temp = _impl_.tool_;
  _impl_.tool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Tool* RegisterToolRequest::unsafe_arena_release_tool() {
  // @@protoc_insertion_point(field_release:mcp.RegisterToolRequest.tool)
  
  ::mcp::Tool* temp = _impl_.tool_;
  _impl_.tool_ = nullptr;
  return temp;
}
inline ::mcp::Tool* RegisterToolRequest::_internal_mutable_tool() {
  
  if (_impl_.tool_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Tool>(GetArenaForAllocation());
    _impl_.tool_ = p;
  }
  return _impl_.tool_;
}
inline ::mcp::Tool* RegisterToolRequest::mutable_tool() {
  ::mcp::Tool* _msg = _internal_mutable_tool();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterToolRequest.tool)
  return _msg;
}
inline void RegisterToolRequest::set_allocated_tool(::mcp::Tool* tool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_);
  }
  if (tool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tool));
    if (message_arena != submessage_arena) {
      tool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tool, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tool_ = tool;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterToolRequest.tool)
}

// -------------------------------------------------------------------

// RegisterToolResponse

// bool success = 1;
inline void RegisterToolResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterToolResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RegisterToolResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterToolResponse.success)
  return _internal_success();
}
inline void RegisterToolResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RegisterToolResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mcp.RegisterToolResponse.success)
}

// string tool_id = 2;
inline void RegisterToolResponse::clear_tool_id() {
  _impl_.tool_id_.ClearToEmpty();
}
inline const std::string& RegisterToolResponse::tool_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterToolResponse.tool_id)
  return _internal_tool_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterToolResponse::set_tool_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.RegisterToolResponse.tool_id)
}
inline std::string* RegisterToolResponse::mutable_tool_id() {
  std::string* _s = _internal_mutable_tool_id();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterToolResponse.tool_id)
  return _s;
}
inline const std::string& RegisterToolResponse::_internal_tool_id() const {
  return _impl_.tool_id_.Get();
}
inline void RegisterToolResponse::_internal_set_tool_id(const std::string& value) {
  
  _impl_.tool_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterToolResponse::_internal_mutable_tool_id() {
  
  return _impl_.tool_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterToolResponse::release_tool_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterToolResponse.tool_id)
  return _impl_.tool_id_.Release();
}
inline void RegisterToolResponse::set_allocated_tool_id(std::string* tool_id) {
  if (tool_id != nullptr) {
    
  } else {
    
  }
  _impl_.tool_id_.SetAllocated(tool_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_id_.IsDefault()) {
    _impl_.tool_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterToolResponse.tool_id)
}

// -------------------------------------------------------------------

// ListToolsRequest

// .mcp.PaginatedParams params = 1;
inline bool ListToolsRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ListToolsRequest::has_params() const {
  return _internal_has_params();
}
inline const ::mcp::PaginatedParams& ListToolsRequest::_internal_params() const {
  const ::mcp::PaginatedParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::PaginatedParams&>(
      ::mcp::_PaginatedParams_default_instance_);
}
inline const ::mcp::PaginatedParams& ListToolsRequest::params() const {
  // @@protoc_insertion_point(field_get:mcp.ListToolsRequest.params)
  return _internal_params();
}
inline void ListToolsRequest::unsafe_arena_set_allocated_params(
    ::mcp::PaginatedParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ListToolsRequest.params)
}
inline ::mcp::PaginatedParams* ListToolsRequest::release_params() {
  
  ::mcp::PaginatedParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::PaginatedParams* ListToolsRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:mcp.ListToolsRequest.params)
  
  ::mcp::PaginatedParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::mcp::PaginatedParams* ListToolsRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::PaginatedParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::mcp::PaginatedParams* ListToolsRequest::mutable_params() {
  ::mcp::PaginatedParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:mcp.ListToolsRequest.params)
  return _msg;
}
inline void ListToolsRequest::set_allocated_params(::mcp::PaginatedParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ListToolsRequest.params)
}

// -------------------------------------------------------------------

// ListToolsResponse

// repeated .mcp.Tool tools = 1;
inline int ListToolsResponse::_internal_tools_size() const {
  return _impl_.tools_.size();
}
inline int ListToolsResponse::tools_size() const {
  return _internal_tools_size();
}
inline ::mcp::Tool* ListToolsResponse::mutable_tools(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ListToolsResponse.tools)
  return _impl_.tools_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Tool >*
ListToolsResponse::mutable_tools() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ListToolsResponse.tools)
  return &_impl_.tools_;
}
inline const ::mcp::Tool& ListToolsResponse::_internal_tools(int index) const {
  return _impl_.tools_.Get(index);
}
inline const ::mcp::Tool& ListToolsResponse::tools(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ListToolsResponse.tools)
  return _internal_tools(index);
}
inline ::mcp::Tool* ListToolsResponse::_internal_add_tools() {
  return _impl_.tools_.Add();
}
inline ::mcp::Tool* ListToolsResponse::add_tools() {
  ::mcp::Tool* _add = _internal_add_tools();
  // @@protoc_insertion_point(field_add:mcp.ListToolsResponse.tools)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Tool >&
ListToolsResponse::tools() const {
  // @@protoc_insertion_point(field_list:mcp.ListToolsResponse.tools)
  return _impl_.tools_;
}

// string next_cursor = 2;
inline void ListToolsResponse::clear_next_cursor() {
  _impl_.next_cursor_.ClearToEmpty();
}
inline const std::string& ListToolsResponse::next_cursor() const {
  // @@protoc_insertion_point(field_get:mcp.ListToolsResponse.next_cursor)
  return _internal_next_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListToolsResponse::set_next_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ListToolsResponse.next_cursor)
}
inline std::string* ListToolsResponse::mutable_next_cursor() {
  std::string* _s = _internal_mutable_next_cursor();
  // @@protoc_insertion_point(field_mutable:mcp.ListToolsResponse.next_cursor)
  return _s;
}
inline const std::string& ListToolsResponse::_internal_next_cursor() const {
  return _impl_.next_cursor_.Get();
}
inline void ListToolsResponse::_internal_set_next_cursor(const std::string& value) {
  
  _impl_.next_cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* ListToolsResponse::_internal_mutable_next_cursor() {
  
  return _impl_.next_cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* ListToolsResponse::release_next_cursor() {
  // @@protoc_insertion_point(field_release:mcp.ListToolsResponse.next_cursor)
  return _impl_.next_cursor_.Release();
}
inline void ListToolsResponse::set_allocated_next_cursor(std::string* next_cursor) {
  if (next_cursor != nullptr) {
    
  } else {
    
  }
  _impl_.next_cursor_.SetAllocated(next_cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_cursor_.IsDefault()) {
    _impl_.next_cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ListToolsResponse.next_cursor)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Prompt

// string name = 1;
inline void Prompt::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Prompt::name() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Prompt::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Prompt.name)
}
inline std::string* Prompt::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.name)
  return _s;
}
inline const std::string& Prompt::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Prompt::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Prompt::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Prompt::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.name)
  return _impl_.name_.Release();
}
inline void Prompt::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.name)
}

// string content = 2;
inline void Prompt::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Prompt::content() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Prompt::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Prompt.content)
}
inline std::string* Prompt::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.content)
  return _s;
}
inline const std::string& Prompt::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Prompt::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Prompt::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Prompt::release_content() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.content)
  return _impl_.content_.Release();
}
inline void Prompt::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.content)
}

// string description = 3;
inline void Prompt::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Prompt::description() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Prompt::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.Prompt.description)
}
inline std::string* Prompt::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.description)
  return _s;
}
inline const std::string& Prompt::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Prompt::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Prompt::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Prompt::release_description() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.description)
  return _impl_.description_.Release();
}
inline void Prompt::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.description)
}

// .mcp.ModelPreferences model_preferences = 4;
inline bool Prompt::_internal_has_model_preferences() const {
  return this != internal_default_instance() && _impl_.model_preferences_ != nullptr;
}
inline bool Prompt::has_model_preferences() const {
  return _internal_has_model_preferences();
}
inline const ::mcp::ModelPreferences& Prompt::_internal_model_preferences() const {
  const ::mcp::ModelPreferences* p = _impl_.model_preferences_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::ModelPreferences&>(
      ::mcp::_ModelPreferences_default_instance_);
}
inline const ::mcp::ModelPreferences& Prompt::model_preferences() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.model_preferences)
  return _internal_model_preferences();
}
inline void Prompt::unsafe_arena_set_allocated_model_preferences(
    ::mcp::ModelPreferences* model_preferences) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_preferences_);
  }
  _impl_.model_preferences_ = model_preferences;
  if (model_preferences) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.Prompt.model_preferences)
}
inline ::mcp::ModelPreferences* Prompt::release_model_preferences() {
  
  ::mcp::ModelPreferences* temp = _impl_.model_preferences_;
  _impl_.model_preferences_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::ModelPreferences* Prompt::unsafe_arena_release_model_preferences() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.model_preferences)
  
  ::mcp::ModelPreferences* temp = _impl_.model_preferences_;
  _impl_.model_preferences_ = nullptr;
  return temp;
}
inline ::mcp::ModelPreferences* Prompt::_internal_mutable_model_preferences() {
  
  if (_impl_.model_preferences_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::ModelPreferences>(GetArenaForAllocation());
    _impl_.model_preferences_ = p;
  }
  return _impl_.model_preferences_;
}
inline ::mcp::ModelPreferences* Prompt::mutable_model_preferences() {
  ::mcp::ModelPreferences* _msg = _internal_mutable_model_preferences();
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.model_preferences)
  return _msg;
}
inline void Prompt::set_allocated_model_preferences(::mcp::ModelPreferences* model_preferences) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_preferences_);
  }
  if (model_preferences) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_preferences));
    if (message_arena != submessage_arena) {
      model_preferences = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_preferences, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_preferences_ = model_preferences;
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.model_preferences)
}

// .mcp.Annotations annotations = 5;
inline bool Prompt::_internal_has_annotations() const {
  return this != internal_default_instance() && _impl_.annotations_ != nullptr;
}
inline bool Prompt::has_annotations() const {
  return _internal_has_annotations();
}
inline const ::mcp::Annotations& Prompt::_internal_annotations() const {
  const ::mcp::Annotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Annotations&>(
      ::mcp::_Annotations_default_instance_);
}
inline const ::mcp::Annotations& Prompt::annotations() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.annotations)
  return _internal_annotations();
}
inline void Prompt::unsafe_arena_set_allocated_annotations(
    ::mcp::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.Prompt.annotations)
}
inline ::mcp::Annotations* Prompt::release_annotations() {
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Annotations* Prompt::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.annotations)
  
  ::mcp::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::mcp::Annotations* Prompt::_internal_mutable_annotations() {
  
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::mcp::Annotations* Prompt::mutable_annotations() {
  ::mcp::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.annotations)
  return _msg;
}
inline void Prompt::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotations));
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.annotations)
}

// map<string, bytes> metadata = 6;
inline int Prompt::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int Prompt::metadata_size() const {
  return _internal_metadata_size();
}
inline void Prompt::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Prompt::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Prompt::metadata() const {
  // @@protoc_insertion_point(field_map:mcp.Prompt.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Prompt::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Prompt::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:mcp.Prompt.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// RegisterPromptRequest

// .mcp.Prompt prompt = 1;
inline bool RegisterPromptRequest::_internal_has_prompt() const {
  return this != internal_default_instance() && _impl_.prompt_ != nullptr;
}
inline bool RegisterPromptRequest::has_prompt() const {
  return _internal_has_prompt();
}
inline void RegisterPromptRequest::clear_prompt() {
  if (GetArenaForAllocation() == nullptr && _impl_.prompt_ != nullptr) {
    delete _impl_.prompt_;
  }
  _impl_.prompt_ = nullptr;
}
inline const ::mcp::Prompt& RegisterPromptRequest::_internal_prompt() const {
  const ::mcp::Prompt* p = _impl_.prompt_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Prompt&>(
      ::mcp::_Prompt_default_instance_);
}
inline const ::mcp::Prompt& RegisterPromptRequest::prompt() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterPromptRequest.prompt)
  return _internal_prompt();
}
inline void RegisterPromptRequest::unsafe_arena_set_allocated_prompt(
    ::mcp::Prompt* prompt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_);
  }
  _impl_.prompt_ = prompt;
  if (prompt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.RegisterPromptRequest.prompt)
}
inline ::mcp::Prompt* RegisterPromptRequest::release_prompt() {
  
  ::mcp::Prompt* temp = _impl_.prompt_;
  _impl_.prompt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Prompt* RegisterPromptRequest::unsafe_arena_release_prompt() {
  // @@protoc_insertion_point(field_release:mcp.RegisterPromptRequest.prompt)
  
  ::mcp::Prompt* temp = _impl_.prompt_;
  _impl_.prompt_ = nullptr;
  return temp;
}
inline ::mcp::Prompt* RegisterPromptRequest::_internal_mutable_prompt() {
  
  if (_impl_.prompt_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Prompt>(GetArenaForAllocation());
    _impl_.prompt_ = p;
  }
  return _impl_.prompt_;
}
inline ::mcp::Prompt* RegisterPromptRequest::mutable_prompt() {
  ::mcp::Prompt* _msg = _internal_mutable_prompt();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterPromptRequest.prompt)
  return _msg;
}
inline void RegisterPromptRequest::set_allocated_prompt(::mcp::Prompt* prompt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prompt_;
  }
  if (prompt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prompt);
    if (message_arena != submessage_arena) {
      prompt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prompt_ = prompt;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterPromptRequest.prompt)
}

// -------------------------------------------------------------------

// RegisterPromptResponse

// bool success = 1;
inline void RegisterPromptResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterPromptResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RegisterPromptResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterPromptResponse.success)
  return _internal_success();
}
inline void RegisterPromptResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RegisterPromptResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mcp.RegisterPromptResponse.success)
}

// string prompt_id = 2;
inline void RegisterPromptResponse::clear_prompt_id() {
  _impl_.prompt_id_.ClearToEmpty();
}
inline const std::string& RegisterPromptResponse::prompt_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterPromptResponse.prompt_id)
  return _internal_prompt_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterPromptResponse::set_prompt_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prompt_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.RegisterPromptResponse.prompt_id)
}
inline std::string* RegisterPromptResponse::mutable_prompt_id() {
  std::string* _s = _internal_mutable_prompt_id();
  // @@protoc_insertion_point(field_mutable:mcp.RegisterPromptResponse.prompt_id)
  return _s;
}
inline const std::string& RegisterPromptResponse::_internal_prompt_id() const {
  return _impl_.prompt_id_.Get();
}
inline void RegisterPromptResponse::_internal_set_prompt_id(const std::string& value) {
  
  _impl_.prompt_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterPromptResponse::_internal_mutable_prompt_id() {
  
  return _impl_.prompt_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterPromptResponse::release_prompt_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterPromptResponse.prompt_id)
  return _impl_.prompt_id_.Release();
}
inline void RegisterPromptResponse::set_allocated_prompt_id(std::string* prompt_id) {
  if (prompt_id != nullptr) {
    
  } else {
    
  }
  _impl_.prompt_id_.SetAllocated(prompt_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prompt_id_.IsDefault()) {
    _impl_.prompt_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterPromptResponse.prompt_id)
}

// -------------------------------------------------------------------

// GetPromptRequest

// string name = 1;
inline void GetPromptRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetPromptRequest::name() const {
  // @@protoc_insertion_point(field_get:mcp.GetPromptRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPromptRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.GetPromptRequest.name)
}
inline std::string* GetPromptRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.GetPromptRequest.name)
  return _s;
}
inline const std::string& GetPromptRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetPromptRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPromptRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPromptRequest::release_name() {
  // @@protoc_insertion_point(field_release:mcp.GetPromptRequest.name)
  return _impl_.name_.Release();
}
inline void GetPromptRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.GetPromptRequest.name)
}

// -------------------------------------------------------------------

// ListPromptsRequest

// .mcp.PaginatedParams params = 1;
inline bool ListPromptsRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ListPromptsRequest::has_params() const {
  return _internal_has_params();
}
inline const ::mcp::PaginatedParams& ListPromptsRequest::_internal_params() const {
  const ::mcp::PaginatedParams* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::PaginatedParams&>(
      ::mcp::_PaginatedParams_default_instance_);
}
inline const ::mcp::PaginatedParams& ListPromptsRequest::params() const {
  // @@protoc_insertion_point(field_get:mcp.ListPromptsRequest.params)
  return _internal_params();
}
inline void ListPromptsRequest::unsafe_arena_set_allocated_params(
    ::mcp::PaginatedParams* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.ListPromptsRequest.params)
}
inline ::mcp::PaginatedParams* ListPromptsRequest::release_params() {
  
  ::mcp::PaginatedParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::PaginatedParams* ListPromptsRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:mcp.ListPromptsRequest.params)
  
  ::mcp::PaginatedParams* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::mcp::PaginatedParams* ListPromptsRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::PaginatedParams>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::mcp::PaginatedParams* ListPromptsRequest::mutable_params() {
  ::mcp::PaginatedParams* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsRequest.params)
  return _msg;
}
inline void ListPromptsRequest::set_allocated_params(::mcp::PaginatedParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ListPromptsRequest.params)
}

// string filter = 2;
inline void ListPromptsRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListPromptsRequest::filter() const {
  // @@protoc_insertion_point(field_get:mcp.ListPromptsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPromptsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ListPromptsRequest.filter)
}
inline std::string* ListPromptsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsRequest.filter)
  return _s;
}
inline const std::string& ListPromptsRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListPromptsRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListPromptsRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListPromptsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:mcp.ListPromptsRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListPromptsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ListPromptsRequest.filter)
}

// -------------------------------------------------------------------

// ListPromptsResponse

// repeated .mcp.Prompt prompts = 1;
inline int ListPromptsResponse::_internal_prompts_size() const {
  return _impl_.prompts_.size();
}
inline int ListPromptsResponse::prompts_size() const {
  return _internal_prompts_size();
}
inline void ListPromptsResponse::clear_prompts() {
  _impl_.prompts_.Clear();
}
inline ::mcp::Prompt* ListPromptsResponse::mutable_prompts(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsResponse.prompts)
  return _impl_.prompts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Prompt >*
ListPromptsResponse::mutable_prompts() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ListPromptsResponse.prompts)
  return &_impl_.prompts_;
}
inline const ::mcp::Prompt& ListPromptsResponse::_internal_prompts(int index) const {
  return _impl_.prompts_.Get(index);
}
inline const ::mcp::Prompt& ListPromptsResponse::prompts(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ListPromptsResponse.prompts)
  return _internal_prompts(index);
}
inline ::mcp::Prompt* ListPromptsResponse::_internal_add_prompts() {
  return _impl_.prompts_.Add();
}
inline ::mcp::Prompt* ListPromptsResponse::add_prompts() {
  ::mcp::Prompt* _add = _internal_add_prompts();
  // @@protoc_insertion_point(field_add:mcp.ListPromptsResponse.prompts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcp::Prompt >&
ListPromptsResponse::prompts() const {
  // @@protoc_insertion_point(field_list:mcp.ListPromptsResponse.prompts)
  return _impl_.prompts_;
}

// string next_cursor = 2;
inline void ListPromptsResponse::clear_next_cursor() {
  _impl_.next_cursor_.ClearToEmpty();
}
inline const std::string& ListPromptsResponse::next_cursor() const {
  // @@protoc_insertion_point(field_get:mcp.ListPromptsResponse.next_cursor)
  return _internal_next_cursor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPromptsResponse::set_next_cursor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_cursor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.ListPromptsResponse.next_cursor)
}
inline std::string* ListPromptsResponse::mutable_next_cursor() {
  std::string* _s = _internal_mutable_next_cursor();
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsResponse.next_cursor)
  return _s;
}
inline const std::string& ListPromptsResponse::_internal_next_cursor() const {
  return _impl_.next_cursor_.Get();
}
inline void ListPromptsResponse::_internal_set_next_cursor(const std::string& value) {
  
  _impl_.next_cursor_.Set(value, GetArenaForAllocation());
}
inline std::string* ListPromptsResponse::_internal_mutable_next_cursor() {
  
  return _impl_.next_cursor_.Mutable(GetArenaForAllocation());
}
inline std::string* ListPromptsResponse::release_next_cursor() {
  // @@protoc_insertion_point(field_release:mcp.ListPromptsResponse.next_cursor)
  return _impl_.next_cursor_.Release();
}
inline void ListPromptsResponse::set_allocated_next_cursor(std::string* next_cursor) {
  if (next_cursor != nullptr) {
    
  } else {
    
  }
  _impl_.next_cursor_.SetAllocated(next_cursor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_cursor_.IsDefault()) {
    _impl_.next_cursor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.ListPromptsResponse.next_cursor)
}

// -------------------------------------------------------------------

// UpdatePromptRequest

// string name = 1;
inline void UpdatePromptRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdatePromptRequest::name() const {
  // @@protoc_insertion_point(field_get:mcp.UpdatePromptRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePromptRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.UpdatePromptRequest.name)
}
inline std::string* UpdatePromptRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.UpdatePromptRequest.name)
  return _s;
}
inline const std::string& UpdatePromptRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdatePromptRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdatePromptRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdatePromptRequest::release_name() {
  // @@protoc_insertion_point(field_release:mcp.UpdatePromptRequest.name)
  return _impl_.name_.Release();
}
inline void UpdatePromptRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.UpdatePromptRequest.name)
}

// .mcp.Prompt prompt = 2;
inline bool UpdatePromptRequest::_internal_has_prompt() const {
  return this != internal_default_instance() && _impl_.prompt_ != nullptr;
}
inline bool UpdatePromptRequest::has_prompt() const {
  return _internal_has_prompt();
}
inline void UpdatePromptRequest::clear_prompt() {
  if (GetArenaForAllocation() == nullptr && _impl_.prompt_ != nullptr) {
    delete _impl_.prompt_;
  }
  _impl_.prompt_ = nullptr;
}
inline const ::mcp::Prompt& UpdatePromptRequest::_internal_prompt() const {
  const ::mcp::Prompt* p = _impl_.prompt_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcp::Prompt&>(
      ::mcp::_Prompt_default_instance_);
}
inline const ::mcp::Prompt& UpdatePromptRequest::prompt() const {
  // @@protoc_insertion_point(field_get:mcp.UpdatePromptRequest.prompt)
  return _internal_prompt();
}
inline void UpdatePromptRequest::unsafe_arena_set_allocated_prompt(
    ::mcp::Prompt* prompt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_);
  }
  _impl_.prompt_ = prompt;
  if (prompt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcp.UpdatePromptRequest.prompt)
}
inline ::mcp::Prompt* UpdatePromptRequest::release_prompt() {
  
  ::mcp::Prompt* temp = _impl_.prompt_;
  _impl_.prompt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcp::Prompt* UpdatePromptRequest::unsafe_arena_release_prompt() {
  // @@protoc_insertion_point(field_release:mcp.UpdatePromptRequest.prompt)
  
  ::mcp::Prompt* temp = _impl_.prompt_;
  _impl_.prompt_ = nullptr;
  return temp;
}
inline ::mcp::Prompt* UpdatePromptRequest::_internal_mutable_prompt() {
  
  if (_impl_.prompt_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcp::Prompt>(GetArenaForAllocation());
    _impl_.prompt_ = p;
  }
  return _impl_.prompt_;
}
inline ::mcp::Prompt* UpdatePromptRequest::mutable_prompt() {
  ::mcp::Prompt* _msg = _internal_mutable_prompt();
  // @@protoc_insertion_point(field_mutable:mcp.UpdatePromptRequest.prompt)
  return _msg;
}
inline void UpdatePromptRequest::set_allocated_prompt(::mcp::Prompt* prompt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prompt_;
  }
  if (prompt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prompt);
    if (message_arena != submessage_arena) {
      prompt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prompt_ = prompt;
  // @@protoc_insertion_point(field_set_allocated:mcp.UpdatePromptRequest.prompt)
}

// -------------------------------------------------------------------

// UpdatePromptResponse

// bool success = 1;
inline void UpdatePromptResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool UpdatePromptResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool UpdatePromptResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.UpdatePromptResponse.success)
  return _internal_success();
}
inline void UpdatePromptResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void UpdatePromptResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mcp.UpdatePromptResponse.success)
}

// -------------------------------------------------------------------

// DeletePromptRequest

// string name = 1;
inline void DeletePromptRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeletePromptRequest::name() const {
  // @@protoc_insertion_point(field_get:mcp.DeletePromptRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePromptRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcp.DeletePromptRequest.name)
}
inline std::string* DeletePromptRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcp.DeletePromptRequest.name)
  return _s;
}
inline const std::string& DeletePromptRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeletePromptRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeletePromptRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeletePromptRequest::release_name() {
  // @@protoc_insertion_point(field_release:mcp.DeletePromptRequest.name)
  return _impl_.name_.Release();
}
inline void DeletePromptRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mcp.DeletePromptRequest.name)
}

// -------------------------------------------------------------------

// DeletePromptResponse

// bool success = 1;
inline void DeletePromptResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DeletePromptResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DeletePromptResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.DeletePromptResponse.success)
  return _internal_success();
}
inline void DeletePromptResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DeletePromptResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mcp.DeletePromptResponse.success)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mcp_5fservice_2eproto
