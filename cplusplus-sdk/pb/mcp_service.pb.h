// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcp_service.proto

#ifndef PROTOBUF_INCLUDED_mcp_5fservice_2eproto
#define PROTOBUF_INCLUDED_mcp_5fservice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "mcp.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mcp_5fservice_2eproto 

namespace protobuf_mcp_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mcp_5fservice_2eproto
namespace mcp {
class DeletePromptRequest;
class DeletePromptRequestDefaultTypeInternal;
extern DeletePromptRequestDefaultTypeInternal _DeletePromptRequest_default_instance_;
class DeletePromptResponse;
class DeletePromptResponseDefaultTypeInternal;
extern DeletePromptResponseDefaultTypeInternal _DeletePromptResponse_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class GetInputSchemaRequest;
class GetInputSchemaRequestDefaultTypeInternal;
extern GetInputSchemaRequestDefaultTypeInternal _GetInputSchemaRequest_default_instance_;
class GetPromptRequest;
class GetPromptRequestDefaultTypeInternal;
extern GetPromptRequestDefaultTypeInternal _GetPromptRequest_default_instance_;
class ListPromptsRequest;
class ListPromptsRequestDefaultTypeInternal;
extern ListPromptsRequestDefaultTypeInternal _ListPromptsRequest_default_instance_;
class ListPromptsResponse;
class ListPromptsResponseDefaultTypeInternal;
extern ListPromptsResponseDefaultTypeInternal _ListPromptsResponse_default_instance_;
class ListToolsRequest;
class ListToolsRequestDefaultTypeInternal;
extern ListToolsRequestDefaultTypeInternal _ListToolsRequest_default_instance_;
class ListToolsResponse;
class ListToolsResponseDefaultTypeInternal;
extern ListToolsResponseDefaultTypeInternal _ListToolsResponse_default_instance_;
class Prompt;
class PromptDefaultTypeInternal;
extern PromptDefaultTypeInternal _Prompt_default_instance_;
class Prompt_MetadataEntry_DoNotUse;
class Prompt_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Prompt_MetadataEntry_DoNotUseDefaultTypeInternal _Prompt_MetadataEntry_DoNotUse_default_instance_;
class RegisterInputSchemaRequest;
class RegisterInputSchemaRequestDefaultTypeInternal;
extern RegisterInputSchemaRequestDefaultTypeInternal _RegisterInputSchemaRequest_default_instance_;
class RegisterInputSchemaResponse;
class RegisterInputSchemaResponseDefaultTypeInternal;
extern RegisterInputSchemaResponseDefaultTypeInternal _RegisterInputSchemaResponse_default_instance_;
class RegisterPromptRequest;
class RegisterPromptRequestDefaultTypeInternal;
extern RegisterPromptRequestDefaultTypeInternal _RegisterPromptRequest_default_instance_;
class RegisterPromptResponse;
class RegisterPromptResponseDefaultTypeInternal;
extern RegisterPromptResponseDefaultTypeInternal _RegisterPromptResponse_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class RegisterToolRequest;
class RegisterToolRequestDefaultTypeInternal;
extern RegisterToolRequestDefaultTypeInternal _RegisterToolRequest_default_instance_;
class RegisterToolResponse;
class RegisterToolResponseDefaultTypeInternal;
extern RegisterToolResponseDefaultTypeInternal _RegisterToolResponse_default_instance_;
class UpdatePromptRequest;
class UpdatePromptRequestDefaultTypeInternal;
extern UpdatePromptRequestDefaultTypeInternal _UpdatePromptRequest_default_instance_;
class UpdatePromptResponse;
class UpdatePromptResponseDefaultTypeInternal;
extern UpdatePromptResponseDefaultTypeInternal _UpdatePromptResponse_default_instance_;
}  // namespace mcp
namespace google {
namespace protobuf {
template<> ::mcp::DeletePromptRequest* Arena::CreateMaybeMessage<::mcp::DeletePromptRequest>(Arena*);
template<> ::mcp::DeletePromptResponse* Arena::CreateMaybeMessage<::mcp::DeletePromptResponse>(Arena*);
template<> ::mcp::Empty* Arena::CreateMaybeMessage<::mcp::Empty>(Arena*);
template<> ::mcp::GetInputSchemaRequest* Arena::CreateMaybeMessage<::mcp::GetInputSchemaRequest>(Arena*);
template<> ::mcp::GetPromptRequest* Arena::CreateMaybeMessage<::mcp::GetPromptRequest>(Arena*);
template<> ::mcp::ListPromptsRequest* Arena::CreateMaybeMessage<::mcp::ListPromptsRequest>(Arena*);
template<> ::mcp::ListPromptsResponse* Arena::CreateMaybeMessage<::mcp::ListPromptsResponse>(Arena*);
template<> ::mcp::ListToolsRequest* Arena::CreateMaybeMessage<::mcp::ListToolsRequest>(Arena*);
template<> ::mcp::ListToolsResponse* Arena::CreateMaybeMessage<::mcp::ListToolsResponse>(Arena*);
template<> ::mcp::Prompt* Arena::CreateMaybeMessage<::mcp::Prompt>(Arena*);
template<> ::mcp::Prompt_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::mcp::Prompt_MetadataEntry_DoNotUse>(Arena*);
template<> ::mcp::RegisterInputSchemaRequest* Arena::CreateMaybeMessage<::mcp::RegisterInputSchemaRequest>(Arena*);
template<> ::mcp::RegisterInputSchemaResponse* Arena::CreateMaybeMessage<::mcp::RegisterInputSchemaResponse>(Arena*);
template<> ::mcp::RegisterPromptRequest* Arena::CreateMaybeMessage<::mcp::RegisterPromptRequest>(Arena*);
template<> ::mcp::RegisterPromptResponse* Arena::CreateMaybeMessage<::mcp::RegisterPromptResponse>(Arena*);
template<> ::mcp::RegisterRequest* Arena::CreateMaybeMessage<::mcp::RegisterRequest>(Arena*);
template<> ::mcp::RegisterResponse* Arena::CreateMaybeMessage<::mcp::RegisterResponse>(Arena*);
template<> ::mcp::RegisterToolRequest* Arena::CreateMaybeMessage<::mcp::RegisterToolRequest>(Arena*);
template<> ::mcp::RegisterToolResponse* Arena::CreateMaybeMessage<::mcp::RegisterToolResponse>(Arena*);
template<> ::mcp::UpdatePromptRequest* Arena::CreateMaybeMessage<::mcp::UpdatePromptRequest>(Arena*);
template<> ::mcp::UpdatePromptResponse* Arena::CreateMaybeMessage<::mcp::UpdatePromptResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mcp {

// ===================================================================

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterRequest>(NULL);
  }

  RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string client_id = 1;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // .mcp.ClientCapabilities capabilities = 2;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 2;
  private:
  const ::mcp::ClientCapabilities& _internal_capabilities() const;
  public:
  const ::mcp::ClientCapabilities& capabilities() const;
  ::mcp::ClientCapabilities* release_capabilities();
  ::mcp::ClientCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ClientCapabilities* capabilities);

  // .mcp.Implementation client_info = 3;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 3;
  private:
  const ::mcp::Implementation& _internal_client_info() const;
  public:
  const ::mcp::Implementation& client_info() const;
  ::mcp::Implementation* release_client_info();
  ::mcp::Implementation* mutable_client_info();
  void set_allocated_client_info(::mcp::Implementation* client_info);

  // @@protoc_insertion_point(class_scope:mcp.RegisterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::mcp::ClientCapabilities* capabilities_;
  ::mcp::Implementation* client_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(NULL);
  }

  RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // .mcp.ServerCapabilities capabilities = 3;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 3;
  private:
  const ::mcp::ServerCapabilities& _internal_capabilities() const;
  public:
  const ::mcp::ServerCapabilities& capabilities() const;
  ::mcp::ServerCapabilities* release_capabilities();
  ::mcp::ServerCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::mcp::ServerCapabilities* capabilities);

  // .mcp.Implementation server_info = 4;
  bool has_server_info() const;
  void clear_server_info();
  static const int kServerInfoFieldNumber = 4;
  private:
  const ::mcp::Implementation& _internal_server_info() const;
  public:
  const ::mcp::Implementation& server_info() const;
  ::mcp::Implementation* release_server_info();
  ::mcp::Implementation* mutable_server_info();
  void set_allocated_server_info(::mcp::Implementation* server_info);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:mcp.RegisterResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::mcp::ServerCapabilities* capabilities_;
  ::mcp::Implementation* server_info_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterInputSchemaRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterInputSchemaRequest) */ {
 public:
  RegisterInputSchemaRequest();
  virtual ~RegisterInputSchemaRequest();

  RegisterInputSchemaRequest(const RegisterInputSchemaRequest& from);

  inline RegisterInputSchemaRequest& operator=(const RegisterInputSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterInputSchemaRequest(RegisterInputSchemaRequest&& from) noexcept
    : RegisterInputSchemaRequest() {
    *this = ::std::move(from);
  }

  inline RegisterInputSchemaRequest& operator=(RegisterInputSchemaRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterInputSchemaRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterInputSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterInputSchemaRequest*>(
               &_RegisterInputSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RegisterInputSchemaRequest* other);
  friend void swap(RegisterInputSchemaRequest& a, RegisterInputSchemaRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterInputSchemaRequest* New() const final {
    return CreateMaybeMessage<RegisterInputSchemaRequest>(NULL);
  }

  RegisterInputSchemaRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterInputSchemaRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterInputSchemaRequest& from);
  void MergeFrom(const RegisterInputSchemaRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterInputSchemaRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tool_name = 1;
  void clear_tool_name();
  static const int kToolNameFieldNumber = 1;
  const ::std::string& tool_name() const;
  void set_tool_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tool_name(::std::string&& value);
  #endif
  void set_tool_name(const char* value);
  void set_tool_name(const char* value, size_t size);
  ::std::string* mutable_tool_name();
  ::std::string* release_tool_name();
  void set_allocated_tool_name(::std::string* tool_name);

  // .mcp.InputSchema schema = 2;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 2;
  private:
  const ::mcp::InputSchema& _internal_schema() const;
  public:
  const ::mcp::InputSchema& schema() const;
  ::mcp::InputSchema* release_schema();
  ::mcp::InputSchema* mutable_schema();
  void set_allocated_schema(::mcp::InputSchema* schema);

  // @@protoc_insertion_point(class_scope:mcp.RegisterInputSchemaRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tool_name_;
  ::mcp::InputSchema* schema_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterInputSchemaResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterInputSchemaResponse) */ {
 public:
  RegisterInputSchemaResponse();
  virtual ~RegisterInputSchemaResponse();

  RegisterInputSchemaResponse(const RegisterInputSchemaResponse& from);

  inline RegisterInputSchemaResponse& operator=(const RegisterInputSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterInputSchemaResponse(RegisterInputSchemaResponse&& from) noexcept
    : RegisterInputSchemaResponse() {
    *this = ::std::move(from);
  }

  inline RegisterInputSchemaResponse& operator=(RegisterInputSchemaResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterInputSchemaResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterInputSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterInputSchemaResponse*>(
               &_RegisterInputSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RegisterInputSchemaResponse* other);
  friend void swap(RegisterInputSchemaResponse& a, RegisterInputSchemaResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterInputSchemaResponse* New() const final {
    return CreateMaybeMessage<RegisterInputSchemaResponse>(NULL);
  }

  RegisterInputSchemaResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterInputSchemaResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterInputSchemaResponse& from);
  void MergeFrom(const RegisterInputSchemaResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterInputSchemaResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string schema_id = 2;
  void clear_schema_id();
  static const int kSchemaIdFieldNumber = 2;
  const ::std::string& schema_id() const;
  void set_schema_id(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_id(::std::string&& value);
  #endif
  void set_schema_id(const char* value);
  void set_schema_id(const char* value, size_t size);
  ::std::string* mutable_schema_id();
  ::std::string* release_schema_id();
  void set_allocated_schema_id(::std::string* schema_id);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:mcp.RegisterInputSchemaResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr schema_id_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetInputSchemaRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.GetInputSchemaRequest) */ {
 public:
  GetInputSchemaRequest();
  virtual ~GetInputSchemaRequest();

  GetInputSchemaRequest(const GetInputSchemaRequest& from);

  inline GetInputSchemaRequest& operator=(const GetInputSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetInputSchemaRequest(GetInputSchemaRequest&& from) noexcept
    : GetInputSchemaRequest() {
    *this = ::std::move(from);
  }

  inline GetInputSchemaRequest& operator=(GetInputSchemaRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInputSchemaRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetInputSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const GetInputSchemaRequest*>(
               &_GetInputSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetInputSchemaRequest* other);
  friend void swap(GetInputSchemaRequest& a, GetInputSchemaRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetInputSchemaRequest* New() const final {
    return CreateMaybeMessage<GetInputSchemaRequest>(NULL);
  }

  GetInputSchemaRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetInputSchemaRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetInputSchemaRequest& from);
  void MergeFrom(const GetInputSchemaRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInputSchemaRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tool_name = 1;
  void clear_tool_name();
  static const int kToolNameFieldNumber = 1;
  const ::std::string& tool_name() const;
  void set_tool_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tool_name(::std::string&& value);
  #endif
  void set_tool_name(const char* value);
  void set_tool_name(const char* value, size_t size);
  ::std::string* mutable_tool_name();
  ::std::string* release_tool_name();
  void set_allocated_tool_name(::std::string* tool_name);

  // @@protoc_insertion_point(class_scope:mcp.GetInputSchemaRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tool_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterToolRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterToolRequest) */ {
 public:
  RegisterToolRequest();
  virtual ~RegisterToolRequest();

  RegisterToolRequest(const RegisterToolRequest& from);

  inline RegisterToolRequest& operator=(const RegisterToolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterToolRequest(RegisterToolRequest&& from) noexcept
    : RegisterToolRequest() {
    *this = ::std::move(from);
  }

  inline RegisterToolRequest& operator=(RegisterToolRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterToolRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterToolRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterToolRequest*>(
               &_RegisterToolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RegisterToolRequest* other);
  friend void swap(RegisterToolRequest& a, RegisterToolRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterToolRequest* New() const final {
    return CreateMaybeMessage<RegisterToolRequest>(NULL);
  }

  RegisterToolRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterToolRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterToolRequest& from);
  void MergeFrom(const RegisterToolRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterToolRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mcp.Tool tool = 1;
  bool has_tool() const;
  void clear_tool();
  static const int kToolFieldNumber = 1;
  private:
  const ::mcp::Tool& _internal_tool() const;
  public:
  const ::mcp::Tool& tool() const;
  ::mcp::Tool* release_tool();
  ::mcp::Tool* mutable_tool();
  void set_allocated_tool(::mcp::Tool* tool);

  // @@protoc_insertion_point(class_scope:mcp.RegisterToolRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mcp::Tool* tool_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterToolResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterToolResponse) */ {
 public:
  RegisterToolResponse();
  virtual ~RegisterToolResponse();

  RegisterToolResponse(const RegisterToolResponse& from);

  inline RegisterToolResponse& operator=(const RegisterToolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterToolResponse(RegisterToolResponse&& from) noexcept
    : RegisterToolResponse() {
    *this = ::std::move(from);
  }

  inline RegisterToolResponse& operator=(RegisterToolResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterToolResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterToolResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterToolResponse*>(
               &_RegisterToolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RegisterToolResponse* other);
  friend void swap(RegisterToolResponse& a, RegisterToolResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterToolResponse* New() const final {
    return CreateMaybeMessage<RegisterToolResponse>(NULL);
  }

  RegisterToolResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterToolResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterToolResponse& from);
  void MergeFrom(const RegisterToolResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterToolResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tool_id = 2;
  void clear_tool_id();
  static const int kToolIdFieldNumber = 2;
  const ::std::string& tool_id() const;
  void set_tool_id(const ::std::string& value);
  #if LANG_CXX11
  void set_tool_id(::std::string&& value);
  #endif
  void set_tool_id(const char* value);
  void set_tool_id(const char* value, size_t size);
  ::std::string* mutable_tool_id();
  ::std::string* release_tool_id();
  void set_allocated_tool_id(::std::string* tool_id);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:mcp.RegisterToolResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tool_id_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListToolsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ListToolsRequest) */ {
 public:
  ListToolsRequest();
  virtual ~ListToolsRequest();

  ListToolsRequest(const ListToolsRequest& from);

  inline ListToolsRequest& operator=(const ListToolsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListToolsRequest(ListToolsRequest&& from) noexcept
    : ListToolsRequest() {
    *this = ::std::move(from);
  }

  inline ListToolsRequest& operator=(ListToolsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListToolsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListToolsRequest* internal_default_instance() {
    return reinterpret_cast<const ListToolsRequest*>(
               &_ListToolsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ListToolsRequest* other);
  friend void swap(ListToolsRequest& a, ListToolsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListToolsRequest* New() const final {
    return CreateMaybeMessage<ListToolsRequest>(NULL);
  }

  ListToolsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListToolsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListToolsRequest& from);
  void MergeFrom(const ListToolsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListToolsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mcp.PaginatedParams params = 1;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 1;
  private:
  const ::mcp::PaginatedParams& _internal_params() const;
  public:
  const ::mcp::PaginatedParams& params() const;
  ::mcp::PaginatedParams* release_params();
  ::mcp::PaginatedParams* mutable_params();
  void set_allocated_params(::mcp::PaginatedParams* params);

  // @@protoc_insertion_point(class_scope:mcp.ListToolsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mcp::PaginatedParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListToolsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ListToolsResponse) */ {
 public:
  ListToolsResponse();
  virtual ~ListToolsResponse();

  ListToolsResponse(const ListToolsResponse& from);

  inline ListToolsResponse& operator=(const ListToolsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListToolsResponse(ListToolsResponse&& from) noexcept
    : ListToolsResponse() {
    *this = ::std::move(from);
  }

  inline ListToolsResponse& operator=(ListToolsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListToolsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListToolsResponse* internal_default_instance() {
    return reinterpret_cast<const ListToolsResponse*>(
               &_ListToolsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ListToolsResponse* other);
  friend void swap(ListToolsResponse& a, ListToolsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListToolsResponse* New() const final {
    return CreateMaybeMessage<ListToolsResponse>(NULL);
  }

  ListToolsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListToolsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListToolsResponse& from);
  void MergeFrom(const ListToolsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListToolsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.Tool tools = 1;
  int tools_size() const;
  void clear_tools();
  static const int kToolsFieldNumber = 1;
  ::mcp::Tool* mutable_tools(int index);
  ::google::protobuf::RepeatedPtrField< ::mcp::Tool >*
      mutable_tools();
  const ::mcp::Tool& tools(int index) const;
  ::mcp::Tool* add_tools();
  const ::google::protobuf::RepeatedPtrField< ::mcp::Tool >&
      tools() const;

  // string next_cursor = 2;
  void clear_next_cursor();
  static const int kNextCursorFieldNumber = 2;
  const ::std::string& next_cursor() const;
  void set_next_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_next_cursor(::std::string&& value);
  #endif
  void set_next_cursor(const char* value);
  void set_next_cursor(const char* value, size_t size);
  ::std::string* mutable_next_cursor();
  ::std::string* release_next_cursor();
  void set_allocated_next_cursor(::std::string* next_cursor);

  // @@protoc_insertion_point(class_scope:mcp.ListToolsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mcp::Tool > tools_;
  ::google::protobuf::internal::ArenaStringPtr next_cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Prompt_MetadataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Prompt_MetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Prompt_MetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  Prompt_MetadataEntry_DoNotUse();
  Prompt_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Prompt_MetadataEntry_DoNotUse& other);
  static const Prompt_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Prompt_MetadataEntry_DoNotUse*>(&_Prompt_MetadataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Prompt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Prompt) */ {
 public:
  Prompt();
  virtual ~Prompt();

  Prompt(const Prompt& from);

  inline Prompt& operator=(const Prompt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Prompt(Prompt&& from) noexcept
    : Prompt() {
    *this = ::std::move(from);
  }

  inline Prompt& operator=(Prompt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Prompt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Prompt* internal_default_instance() {
    return reinterpret_cast<const Prompt*>(
               &_Prompt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Prompt* other);
  friend void swap(Prompt& a, Prompt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Prompt* New() const final {
    return CreateMaybeMessage<Prompt>(NULL);
  }

  Prompt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Prompt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Prompt& from);
  void MergeFrom(const Prompt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Prompt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> metadata = 6;
  int metadata_size() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      metadata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_metadata();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string content = 2;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .mcp.ModelPreferences model_preferences = 4;
  bool has_model_preferences() const;
  void clear_model_preferences();
  static const int kModelPreferencesFieldNumber = 4;
  private:
  const ::mcp::ModelPreferences& _internal_model_preferences() const;
  public:
  const ::mcp::ModelPreferences& model_preferences() const;
  ::mcp::ModelPreferences* release_model_preferences();
  ::mcp::ModelPreferences* mutable_model_preferences();
  void set_allocated_model_preferences(::mcp::ModelPreferences* model_preferences);

  // .mcp.Annotations annotations = 5;
  bool has_annotations() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 5;
  private:
  const ::mcp::Annotations& _internal_annotations() const;
  public:
  const ::mcp::Annotations& annotations() const;
  ::mcp::Annotations* release_annotations();
  ::mcp::Annotations* mutable_annotations();
  void set_allocated_annotations(::mcp::Annotations* annotations);

  // @@protoc_insertion_point(class_scope:mcp.Prompt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Prompt_MetadataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::mcp::ModelPreferences* model_preferences_;
  ::mcp::Annotations* annotations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterPromptRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterPromptRequest) */ {
 public:
  RegisterPromptRequest();
  virtual ~RegisterPromptRequest();

  RegisterPromptRequest(const RegisterPromptRequest& from);

  inline RegisterPromptRequest& operator=(const RegisterPromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterPromptRequest(RegisterPromptRequest&& from) noexcept
    : RegisterPromptRequest() {
    *this = ::std::move(from);
  }

  inline RegisterPromptRequest& operator=(RegisterPromptRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterPromptRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterPromptRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterPromptRequest*>(
               &_RegisterPromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RegisterPromptRequest* other);
  friend void swap(RegisterPromptRequest& a, RegisterPromptRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterPromptRequest* New() const final {
    return CreateMaybeMessage<RegisterPromptRequest>(NULL);
  }

  RegisterPromptRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterPromptRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterPromptRequest& from);
  void MergeFrom(const RegisterPromptRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPromptRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mcp.Prompt prompt = 1;
  bool has_prompt() const;
  void clear_prompt();
  static const int kPromptFieldNumber = 1;
  private:
  const ::mcp::Prompt& _internal_prompt() const;
  public:
  const ::mcp::Prompt& prompt() const;
  ::mcp::Prompt* release_prompt();
  ::mcp::Prompt* mutable_prompt();
  void set_allocated_prompt(::mcp::Prompt* prompt);

  // @@protoc_insertion_point(class_scope:mcp.RegisterPromptRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mcp::Prompt* prompt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterPromptResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.RegisterPromptResponse) */ {
 public:
  RegisterPromptResponse();
  virtual ~RegisterPromptResponse();

  RegisterPromptResponse(const RegisterPromptResponse& from);

  inline RegisterPromptResponse& operator=(const RegisterPromptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterPromptResponse(RegisterPromptResponse&& from) noexcept
    : RegisterPromptResponse() {
    *this = ::std::move(from);
  }

  inline RegisterPromptResponse& operator=(RegisterPromptResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterPromptResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterPromptResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterPromptResponse*>(
               &_RegisterPromptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RegisterPromptResponse* other);
  friend void swap(RegisterPromptResponse& a, RegisterPromptResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterPromptResponse* New() const final {
    return CreateMaybeMessage<RegisterPromptResponse>(NULL);
  }

  RegisterPromptResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterPromptResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterPromptResponse& from);
  void MergeFrom(const RegisterPromptResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPromptResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string prompt_id = 2;
  void clear_prompt_id();
  static const int kPromptIdFieldNumber = 2;
  const ::std::string& prompt_id() const;
  void set_prompt_id(const ::std::string& value);
  #if LANG_CXX11
  void set_prompt_id(::std::string&& value);
  #endif
  void set_prompt_id(const char* value);
  void set_prompt_id(const char* value, size_t size);
  ::std::string* mutable_prompt_id();
  ::std::string* release_prompt_id();
  void set_allocated_prompt_id(::std::string* prompt_id);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:mcp.RegisterPromptResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr prompt_id_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPromptRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.GetPromptRequest) */ {
 public:
  GetPromptRequest();
  virtual ~GetPromptRequest();

  GetPromptRequest(const GetPromptRequest& from);

  inline GetPromptRequest& operator=(const GetPromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPromptRequest(GetPromptRequest&& from) noexcept
    : GetPromptRequest() {
    *this = ::std::move(from);
  }

  inline GetPromptRequest& operator=(GetPromptRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPromptRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPromptRequest* internal_default_instance() {
    return reinterpret_cast<const GetPromptRequest*>(
               &_GetPromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetPromptRequest* other);
  friend void swap(GetPromptRequest& a, GetPromptRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPromptRequest* New() const final {
    return CreateMaybeMessage<GetPromptRequest>(NULL);
  }

  GetPromptRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetPromptRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetPromptRequest& from);
  void MergeFrom(const GetPromptRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPromptRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mcp.GetPromptRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListPromptsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ListPromptsRequest) */ {
 public:
  ListPromptsRequest();
  virtual ~ListPromptsRequest();

  ListPromptsRequest(const ListPromptsRequest& from);

  inline ListPromptsRequest& operator=(const ListPromptsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListPromptsRequest(ListPromptsRequest&& from) noexcept
    : ListPromptsRequest() {
    *this = ::std::move(from);
  }

  inline ListPromptsRequest& operator=(ListPromptsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListPromptsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListPromptsRequest* internal_default_instance() {
    return reinterpret_cast<const ListPromptsRequest*>(
               &_ListPromptsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ListPromptsRequest* other);
  friend void swap(ListPromptsRequest& a, ListPromptsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListPromptsRequest* New() const final {
    return CreateMaybeMessage<ListPromptsRequest>(NULL);
  }

  ListPromptsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListPromptsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListPromptsRequest& from);
  void MergeFrom(const ListPromptsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPromptsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filter = 2;
  void clear_filter();
  static const int kFilterFieldNumber = 2;
  const ::std::string& filter() const;
  void set_filter(const ::std::string& value);
  #if LANG_CXX11
  void set_filter(::std::string&& value);
  #endif
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  ::std::string* mutable_filter();
  ::std::string* release_filter();
  void set_allocated_filter(::std::string* filter);

  // .mcp.PaginatedParams params = 1;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 1;
  private:
  const ::mcp::PaginatedParams& _internal_params() const;
  public:
  const ::mcp::PaginatedParams& params() const;
  ::mcp::PaginatedParams* release_params();
  ::mcp::PaginatedParams* mutable_params();
  void set_allocated_params(::mcp::PaginatedParams* params);

  // @@protoc_insertion_point(class_scope:mcp.ListPromptsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filter_;
  ::mcp::PaginatedParams* params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListPromptsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.ListPromptsResponse) */ {
 public:
  ListPromptsResponse();
  virtual ~ListPromptsResponse();

  ListPromptsResponse(const ListPromptsResponse& from);

  inline ListPromptsResponse& operator=(const ListPromptsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListPromptsResponse(ListPromptsResponse&& from) noexcept
    : ListPromptsResponse() {
    *this = ::std::move(from);
  }

  inline ListPromptsResponse& operator=(ListPromptsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListPromptsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListPromptsResponse* internal_default_instance() {
    return reinterpret_cast<const ListPromptsResponse*>(
               &_ListPromptsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ListPromptsResponse* other);
  friend void swap(ListPromptsResponse& a, ListPromptsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListPromptsResponse* New() const final {
    return CreateMaybeMessage<ListPromptsResponse>(NULL);
  }

  ListPromptsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListPromptsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListPromptsResponse& from);
  void MergeFrom(const ListPromptsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPromptsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcp.Prompt prompts = 1;
  int prompts_size() const;
  void clear_prompts();
  static const int kPromptsFieldNumber = 1;
  ::mcp::Prompt* mutable_prompts(int index);
  ::google::protobuf::RepeatedPtrField< ::mcp::Prompt >*
      mutable_prompts();
  const ::mcp::Prompt& prompts(int index) const;
  ::mcp::Prompt* add_prompts();
  const ::google::protobuf::RepeatedPtrField< ::mcp::Prompt >&
      prompts() const;

  // string next_cursor = 2;
  void clear_next_cursor();
  static const int kNextCursorFieldNumber = 2;
  const ::std::string& next_cursor() const;
  void set_next_cursor(const ::std::string& value);
  #if LANG_CXX11
  void set_next_cursor(::std::string&& value);
  #endif
  void set_next_cursor(const char* value);
  void set_next_cursor(const char* value, size_t size);
  ::std::string* mutable_next_cursor();
  ::std::string* release_next_cursor();
  void set_allocated_next_cursor(::std::string* next_cursor);

  // @@protoc_insertion_point(class_scope:mcp.ListPromptsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mcp::Prompt > prompts_;
  ::google::protobuf::internal::ArenaStringPtr next_cursor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdatePromptRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.UpdatePromptRequest) */ {
 public:
  UpdatePromptRequest();
  virtual ~UpdatePromptRequest();

  UpdatePromptRequest(const UpdatePromptRequest& from);

  inline UpdatePromptRequest& operator=(const UpdatePromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdatePromptRequest(UpdatePromptRequest&& from) noexcept
    : UpdatePromptRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePromptRequest& operator=(UpdatePromptRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePromptRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePromptRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePromptRequest*>(
               &_UpdatePromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(UpdatePromptRequest* other);
  friend void swap(UpdatePromptRequest& a, UpdatePromptRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdatePromptRequest* New() const final {
    return CreateMaybeMessage<UpdatePromptRequest>(NULL);
  }

  UpdatePromptRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePromptRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdatePromptRequest& from);
  void MergeFrom(const UpdatePromptRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePromptRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .mcp.Prompt prompt = 2;
  bool has_prompt() const;
  void clear_prompt();
  static const int kPromptFieldNumber = 2;
  private:
  const ::mcp::Prompt& _internal_prompt() const;
  public:
  const ::mcp::Prompt& prompt() const;
  ::mcp::Prompt* release_prompt();
  ::mcp::Prompt* mutable_prompt();
  void set_allocated_prompt(::mcp::Prompt* prompt);

  // @@protoc_insertion_point(class_scope:mcp.UpdatePromptRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mcp::Prompt* prompt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdatePromptResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.UpdatePromptResponse) */ {
 public:
  UpdatePromptResponse();
  virtual ~UpdatePromptResponse();

  UpdatePromptResponse(const UpdatePromptResponse& from);

  inline UpdatePromptResponse& operator=(const UpdatePromptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdatePromptResponse(UpdatePromptResponse&& from) noexcept
    : UpdatePromptResponse() {
    *this = ::std::move(from);
  }

  inline UpdatePromptResponse& operator=(UpdatePromptResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePromptResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePromptResponse* internal_default_instance() {
    return reinterpret_cast<const UpdatePromptResponse*>(
               &_UpdatePromptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(UpdatePromptResponse* other);
  friend void swap(UpdatePromptResponse& a, UpdatePromptResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdatePromptResponse* New() const final {
    return CreateMaybeMessage<UpdatePromptResponse>(NULL);
  }

  UpdatePromptResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePromptResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdatePromptResponse& from);
  void MergeFrom(const UpdatePromptResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePromptResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:mcp.UpdatePromptResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeletePromptRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.DeletePromptRequest) */ {
 public:
  DeletePromptRequest();
  virtual ~DeletePromptRequest();

  DeletePromptRequest(const DeletePromptRequest& from);

  inline DeletePromptRequest& operator=(const DeletePromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeletePromptRequest(DeletePromptRequest&& from) noexcept
    : DeletePromptRequest() {
    *this = ::std::move(from);
  }

  inline DeletePromptRequest& operator=(DeletePromptRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeletePromptRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeletePromptRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePromptRequest*>(
               &_DeletePromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(DeletePromptRequest* other);
  friend void swap(DeletePromptRequest& a, DeletePromptRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeletePromptRequest* New() const final {
    return CreateMaybeMessage<DeletePromptRequest>(NULL);
  }

  DeletePromptRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeletePromptRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeletePromptRequest& from);
  void MergeFrom(const DeletePromptRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePromptRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mcp.DeletePromptRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeletePromptResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.DeletePromptResponse) */ {
 public:
  DeletePromptResponse();
  virtual ~DeletePromptResponse();

  DeletePromptResponse(const DeletePromptResponse& from);

  inline DeletePromptResponse& operator=(const DeletePromptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeletePromptResponse(DeletePromptResponse&& from) noexcept
    : DeletePromptResponse() {
    *this = ::std::move(from);
  }

  inline DeletePromptResponse& operator=(DeletePromptResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeletePromptResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeletePromptResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePromptResponse*>(
               &_DeletePromptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(DeletePromptResponse* other);
  friend void swap(DeletePromptResponse& a, DeletePromptResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeletePromptResponse* New() const final {
    return CreateMaybeMessage<DeletePromptResponse>(NULL);
  }

  DeletePromptResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeletePromptResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeletePromptResponse& from);
  void MergeFrom(const DeletePromptResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePromptResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:mcp.DeletePromptResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mcp.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcp.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_mcp_5fservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterRequest

// string client_id = 1;
inline void RegisterRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::client_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterRequest.client_id)
  return client_id_.GetNoArena();
}
inline void RegisterRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.RegisterRequest.client_id)
}
#if LANG_CXX11
inline void RegisterRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.RegisterRequest.client_id)
}
#endif
inline void RegisterRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.RegisterRequest.client_id)
}
inline void RegisterRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.RegisterRequest.client_id)
}
inline ::std::string* RegisterRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.RegisterRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterRequest.client_id)
}

// .mcp.ClientCapabilities capabilities = 2;
inline bool RegisterRequest::has_capabilities() const {
  return this != internal_default_instance() && capabilities_ != NULL;
}
inline const ::mcp::ClientCapabilities& RegisterRequest::_internal_capabilities() const {
  return *capabilities_;
}
inline const ::mcp::ClientCapabilities& RegisterRequest::capabilities() const {
  const ::mcp::ClientCapabilities* p = capabilities_;
  // @@protoc_insertion_point(field_get:mcp.RegisterRequest.capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ClientCapabilities*>(
      &::mcp::_ClientCapabilities_default_instance_);
}
inline ::mcp::ClientCapabilities* RegisterRequest::release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.RegisterRequest.capabilities)
  
  ::mcp::ClientCapabilities* temp = capabilities_;
  capabilities_ = NULL;
  return temp;
}
inline ::mcp::ClientCapabilities* RegisterRequest::mutable_capabilities() {
  
  if (capabilities_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ClientCapabilities>(GetArenaNoVirtual());
    capabilities_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RegisterRequest.capabilities)
  return capabilities_;
}
inline void RegisterRequest::set_allocated_capabilities(::mcp::ClientCapabilities* capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(capabilities_);
  }
  if (capabilities) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterRequest.capabilities)
}

// .mcp.Implementation client_info = 3;
inline bool RegisterRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::mcp::Implementation& RegisterRequest::_internal_client_info() const {
  return *client_info_;
}
inline const ::mcp::Implementation& RegisterRequest::client_info() const {
  const ::mcp::Implementation* p = client_info_;
  // @@protoc_insertion_point(field_get:mcp.RegisterRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Implementation*>(
      &::mcp::_Implementation_default_instance_);
}
inline ::mcp::Implementation* RegisterRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:mcp.RegisterRequest.client_info)
  
  ::mcp::Implementation* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::mcp::Implementation* RegisterRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaNoVirtual());
    client_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RegisterRequest.client_info)
  return client_info_;
}
inline void RegisterRequest::set_allocated_client_info(::mcp::Implementation* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterRequest.client_info)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool success = 1;
inline void RegisterResponse::clear_success() {
  success_ = false;
}
inline bool RegisterResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.success)
  return success_;
}
inline void RegisterResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:mcp.RegisterResponse.success)
}

// string session_id = 2;
inline void RegisterResponse::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterResponse::session_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.session_id)
  return session_id_.GetNoArena();
}
inline void RegisterResponse::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.RegisterResponse.session_id)
}
#if LANG_CXX11
inline void RegisterResponse::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.RegisterResponse.session_id)
}
#endif
inline void RegisterResponse::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.RegisterResponse.session_id)
}
inline void RegisterResponse::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.RegisterResponse.session_id)
}
inline ::std::string* RegisterResponse::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.RegisterResponse.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterResponse.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponse::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterResponse.session_id)
}

// .mcp.ServerCapabilities capabilities = 3;
inline bool RegisterResponse::has_capabilities() const {
  return this != internal_default_instance() && capabilities_ != NULL;
}
inline const ::mcp::ServerCapabilities& RegisterResponse::_internal_capabilities() const {
  return *capabilities_;
}
inline const ::mcp::ServerCapabilities& RegisterResponse::capabilities() const {
  const ::mcp::ServerCapabilities* p = capabilities_;
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ServerCapabilities*>(
      &::mcp::_ServerCapabilities_default_instance_);
}
inline ::mcp::ServerCapabilities* RegisterResponse::release_capabilities() {
  // @@protoc_insertion_point(field_release:mcp.RegisterResponse.capabilities)
  
  ::mcp::ServerCapabilities* temp = capabilities_;
  capabilities_ = NULL;
  return temp;
}
inline ::mcp::ServerCapabilities* RegisterResponse::mutable_capabilities() {
  
  if (capabilities_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ServerCapabilities>(GetArenaNoVirtual());
    capabilities_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RegisterResponse.capabilities)
  return capabilities_;
}
inline void RegisterResponse::set_allocated_capabilities(::mcp::ServerCapabilities* capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(capabilities_);
  }
  if (capabilities) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterResponse.capabilities)
}

// .mcp.Implementation server_info = 4;
inline bool RegisterResponse::has_server_info() const {
  return this != internal_default_instance() && server_info_ != NULL;
}
inline const ::mcp::Implementation& RegisterResponse::_internal_server_info() const {
  return *server_info_;
}
inline const ::mcp::Implementation& RegisterResponse::server_info() const {
  const ::mcp::Implementation* p = server_info_;
  // @@protoc_insertion_point(field_get:mcp.RegisterResponse.server_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Implementation*>(
      &::mcp::_Implementation_default_instance_);
}
inline ::mcp::Implementation* RegisterResponse::release_server_info() {
  // @@protoc_insertion_point(field_release:mcp.RegisterResponse.server_info)
  
  ::mcp::Implementation* temp = server_info_;
  server_info_ = NULL;
  return temp;
}
inline ::mcp::Implementation* RegisterResponse::mutable_server_info() {
  
  if (server_info_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Implementation>(GetArenaNoVirtual());
    server_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RegisterResponse.server_info)
  return server_info_;
}
inline void RegisterResponse::set_allocated_server_info(::mcp::Implementation* server_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(server_info_);
  }
  if (server_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_info, submessage_arena);
    }
    
  } else {
    
  }
  server_info_ = server_info;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterResponse.server_info)
}

// -------------------------------------------------------------------

// RegisterInputSchemaRequest

// string tool_name = 1;
inline void RegisterInputSchemaRequest::clear_tool_name() {
  tool_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterInputSchemaRequest::tool_name() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaRequest.tool_name)
  return tool_name_.GetNoArena();
}
inline void RegisterInputSchemaRequest::set_tool_name(const ::std::string& value) {
  
  tool_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.RegisterInputSchemaRequest.tool_name)
}
#if LANG_CXX11
inline void RegisterInputSchemaRequest::set_tool_name(::std::string&& value) {
  
  tool_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.RegisterInputSchemaRequest.tool_name)
}
#endif
inline void RegisterInputSchemaRequest::set_tool_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tool_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.RegisterInputSchemaRequest.tool_name)
}
inline void RegisterInputSchemaRequest::set_tool_name(const char* value, size_t size) {
  
  tool_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.RegisterInputSchemaRequest.tool_name)
}
inline ::std::string* RegisterInputSchemaRequest::mutable_tool_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.RegisterInputSchemaRequest.tool_name)
  return tool_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterInputSchemaRequest::release_tool_name() {
  // @@protoc_insertion_point(field_release:mcp.RegisterInputSchemaRequest.tool_name)
  
  return tool_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterInputSchemaRequest::set_allocated_tool_name(::std::string* tool_name) {
  if (tool_name != NULL) {
    
  } else {
    
  }
  tool_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tool_name);
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterInputSchemaRequest.tool_name)
}

// .mcp.InputSchema schema = 2;
inline bool RegisterInputSchemaRequest::has_schema() const {
  return this != internal_default_instance() && schema_ != NULL;
}
inline const ::mcp::InputSchema& RegisterInputSchemaRequest::_internal_schema() const {
  return *schema_;
}
inline const ::mcp::InputSchema& RegisterInputSchemaRequest::schema() const {
  const ::mcp::InputSchema* p = schema_;
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaRequest.schema)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::InputSchema*>(
      &::mcp::_InputSchema_default_instance_);
}
inline ::mcp::InputSchema* RegisterInputSchemaRequest::release_schema() {
  // @@protoc_insertion_point(field_release:mcp.RegisterInputSchemaRequest.schema)
  
  ::mcp::InputSchema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline ::mcp::InputSchema* RegisterInputSchemaRequest::mutable_schema() {
  
  if (schema_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::InputSchema>(GetArenaNoVirtual());
    schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RegisterInputSchemaRequest.schema)
  return schema_;
}
inline void RegisterInputSchemaRequest::set_allocated_schema(::mcp::InputSchema* schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(schema_);
  }
  if (schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterInputSchemaRequest.schema)
}

// -------------------------------------------------------------------

// RegisterInputSchemaResponse

// bool success = 1;
inline void RegisterInputSchemaResponse::clear_success() {
  success_ = false;
}
inline bool RegisterInputSchemaResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaResponse.success)
  return success_;
}
inline void RegisterInputSchemaResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:mcp.RegisterInputSchemaResponse.success)
}

// string schema_id = 2;
inline void RegisterInputSchemaResponse::clear_schema_id() {
  schema_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterInputSchemaResponse::schema_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterInputSchemaResponse.schema_id)
  return schema_id_.GetNoArena();
}
inline void RegisterInputSchemaResponse::set_schema_id(const ::std::string& value) {
  
  schema_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.RegisterInputSchemaResponse.schema_id)
}
#if LANG_CXX11
inline void RegisterInputSchemaResponse::set_schema_id(::std::string&& value) {
  
  schema_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.RegisterInputSchemaResponse.schema_id)
}
#endif
inline void RegisterInputSchemaResponse::set_schema_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  schema_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.RegisterInputSchemaResponse.schema_id)
}
inline void RegisterInputSchemaResponse::set_schema_id(const char* value, size_t size) {
  
  schema_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.RegisterInputSchemaResponse.schema_id)
}
inline ::std::string* RegisterInputSchemaResponse::mutable_schema_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.RegisterInputSchemaResponse.schema_id)
  return schema_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterInputSchemaResponse::release_schema_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterInputSchemaResponse.schema_id)
  
  return schema_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterInputSchemaResponse::set_allocated_schema_id(::std::string* schema_id) {
  if (schema_id != NULL) {
    
  } else {
    
  }
  schema_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_id);
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterInputSchemaResponse.schema_id)
}

// -------------------------------------------------------------------

// GetInputSchemaRequest

// string tool_name = 1;
inline void GetInputSchemaRequest::clear_tool_name() {
  tool_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetInputSchemaRequest::tool_name() const {
  // @@protoc_insertion_point(field_get:mcp.GetInputSchemaRequest.tool_name)
  return tool_name_.GetNoArena();
}
inline void GetInputSchemaRequest::set_tool_name(const ::std::string& value) {
  
  tool_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.GetInputSchemaRequest.tool_name)
}
#if LANG_CXX11
inline void GetInputSchemaRequest::set_tool_name(::std::string&& value) {
  
  tool_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.GetInputSchemaRequest.tool_name)
}
#endif
inline void GetInputSchemaRequest::set_tool_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tool_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.GetInputSchemaRequest.tool_name)
}
inline void GetInputSchemaRequest::set_tool_name(const char* value, size_t size) {
  
  tool_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.GetInputSchemaRequest.tool_name)
}
inline ::std::string* GetInputSchemaRequest::mutable_tool_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.GetInputSchemaRequest.tool_name)
  return tool_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetInputSchemaRequest::release_tool_name() {
  // @@protoc_insertion_point(field_release:mcp.GetInputSchemaRequest.tool_name)
  
  return tool_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetInputSchemaRequest::set_allocated_tool_name(::std::string* tool_name) {
  if (tool_name != NULL) {
    
  } else {
    
  }
  tool_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tool_name);
  // @@protoc_insertion_point(field_set_allocated:mcp.GetInputSchemaRequest.tool_name)
}

// -------------------------------------------------------------------

// RegisterToolRequest

// .mcp.Tool tool = 1;
inline bool RegisterToolRequest::has_tool() const {
  return this != internal_default_instance() && tool_ != NULL;
}
inline const ::mcp::Tool& RegisterToolRequest::_internal_tool() const {
  return *tool_;
}
inline const ::mcp::Tool& RegisterToolRequest::tool() const {
  const ::mcp::Tool* p = tool_;
  // @@protoc_insertion_point(field_get:mcp.RegisterToolRequest.tool)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Tool*>(
      &::mcp::_Tool_default_instance_);
}
inline ::mcp::Tool* RegisterToolRequest::release_tool() {
  // @@protoc_insertion_point(field_release:mcp.RegisterToolRequest.tool)
  
  ::mcp::Tool* temp = tool_;
  tool_ = NULL;
  return temp;
}
inline ::mcp::Tool* RegisterToolRequest::mutable_tool() {
  
  if (tool_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Tool>(GetArenaNoVirtual());
    tool_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RegisterToolRequest.tool)
  return tool_;
}
inline void RegisterToolRequest::set_allocated_tool(::mcp::Tool* tool) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tool_);
  }
  if (tool) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tool = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tool, submessage_arena);
    }
    
  } else {
    
  }
  tool_ = tool;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterToolRequest.tool)
}

// -------------------------------------------------------------------

// RegisterToolResponse

// bool success = 1;
inline void RegisterToolResponse::clear_success() {
  success_ = false;
}
inline bool RegisterToolResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterToolResponse.success)
  return success_;
}
inline void RegisterToolResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:mcp.RegisterToolResponse.success)
}

// string tool_id = 2;
inline void RegisterToolResponse::clear_tool_id() {
  tool_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterToolResponse::tool_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterToolResponse.tool_id)
  return tool_id_.GetNoArena();
}
inline void RegisterToolResponse::set_tool_id(const ::std::string& value) {
  
  tool_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.RegisterToolResponse.tool_id)
}
#if LANG_CXX11
inline void RegisterToolResponse::set_tool_id(::std::string&& value) {
  
  tool_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.RegisterToolResponse.tool_id)
}
#endif
inline void RegisterToolResponse::set_tool_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tool_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.RegisterToolResponse.tool_id)
}
inline void RegisterToolResponse::set_tool_id(const char* value, size_t size) {
  
  tool_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.RegisterToolResponse.tool_id)
}
inline ::std::string* RegisterToolResponse::mutable_tool_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.RegisterToolResponse.tool_id)
  return tool_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterToolResponse::release_tool_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterToolResponse.tool_id)
  
  return tool_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterToolResponse::set_allocated_tool_id(::std::string* tool_id) {
  if (tool_id != NULL) {
    
  } else {
    
  }
  tool_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tool_id);
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterToolResponse.tool_id)
}

// -------------------------------------------------------------------

// ListToolsRequest

// .mcp.PaginatedParams params = 1;
inline bool ListToolsRequest::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::mcp::PaginatedParams& ListToolsRequest::_internal_params() const {
  return *params_;
}
inline const ::mcp::PaginatedParams& ListToolsRequest::params() const {
  const ::mcp::PaginatedParams* p = params_;
  // @@protoc_insertion_point(field_get:mcp.ListToolsRequest.params)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::PaginatedParams*>(
      &::mcp::_PaginatedParams_default_instance_);
}
inline ::mcp::PaginatedParams* ListToolsRequest::release_params() {
  // @@protoc_insertion_point(field_release:mcp.ListToolsRequest.params)
  
  ::mcp::PaginatedParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::mcp::PaginatedParams* ListToolsRequest::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::PaginatedParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ListToolsRequest.params)
  return params_;
}
inline void ListToolsRequest::set_allocated_params(::mcp::PaginatedParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ListToolsRequest.params)
}

// -------------------------------------------------------------------

// ListToolsResponse

// repeated .mcp.Tool tools = 1;
inline int ListToolsResponse::tools_size() const {
  return tools_.size();
}
inline ::mcp::Tool* ListToolsResponse::mutable_tools(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ListToolsResponse.tools)
  return tools_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mcp::Tool >*
ListToolsResponse::mutable_tools() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ListToolsResponse.tools)
  return &tools_;
}
inline const ::mcp::Tool& ListToolsResponse::tools(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ListToolsResponse.tools)
  return tools_.Get(index);
}
inline ::mcp::Tool* ListToolsResponse::add_tools() {
  // @@protoc_insertion_point(field_add:mcp.ListToolsResponse.tools)
  return tools_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcp::Tool >&
ListToolsResponse::tools() const {
  // @@protoc_insertion_point(field_list:mcp.ListToolsResponse.tools)
  return tools_;
}

// string next_cursor = 2;
inline void ListToolsResponse::clear_next_cursor() {
  next_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListToolsResponse::next_cursor() const {
  // @@protoc_insertion_point(field_get:mcp.ListToolsResponse.next_cursor)
  return next_cursor_.GetNoArena();
}
inline void ListToolsResponse::set_next_cursor(const ::std::string& value) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ListToolsResponse.next_cursor)
}
#if LANG_CXX11
inline void ListToolsResponse::set_next_cursor(::std::string&& value) {
  
  next_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ListToolsResponse.next_cursor)
}
#endif
inline void ListToolsResponse::set_next_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ListToolsResponse.next_cursor)
}
inline void ListToolsResponse::set_next_cursor(const char* value, size_t size) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ListToolsResponse.next_cursor)
}
inline ::std::string* ListToolsResponse::mutable_next_cursor() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ListToolsResponse.next_cursor)
  return next_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListToolsResponse::release_next_cursor() {
  // @@protoc_insertion_point(field_release:mcp.ListToolsResponse.next_cursor)
  
  return next_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListToolsResponse::set_allocated_next_cursor(::std::string* next_cursor) {
  if (next_cursor != NULL) {
    
  } else {
    
  }
  next_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_cursor);
  // @@protoc_insertion_point(field_set_allocated:mcp.ListToolsResponse.next_cursor)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Prompt

// string name = 1;
inline void Prompt::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Prompt::name() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.name)
  return name_.GetNoArena();
}
inline void Prompt::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Prompt.name)
}
#if LANG_CXX11
inline void Prompt::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Prompt.name)
}
#endif
inline void Prompt::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Prompt.name)
}
inline void Prompt::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Prompt.name)
}
inline ::std::string* Prompt::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Prompt::release_name() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Prompt::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.name)
}

// string content = 2;
inline void Prompt::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Prompt::content() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.content)
  return content_.GetNoArena();
}
inline void Prompt::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Prompt.content)
}
#if LANG_CXX11
inline void Prompt::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Prompt.content)
}
#endif
inline void Prompt::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Prompt.content)
}
inline void Prompt::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Prompt.content)
}
inline ::std::string* Prompt::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Prompt::release_content() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Prompt::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.content)
}

// string description = 3;
inline void Prompt::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Prompt::description() const {
  // @@protoc_insertion_point(field_get:mcp.Prompt.description)
  return description_.GetNoArena();
}
inline void Prompt::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.Prompt.description)
}
#if LANG_CXX11
inline void Prompt::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.Prompt.description)
}
#endif
inline void Prompt::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.Prompt.description)
}
inline void Prompt::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.Prompt.description)
}
inline ::std::string* Prompt::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Prompt::release_description() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Prompt::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.description)
}

// .mcp.ModelPreferences model_preferences = 4;
inline bool Prompt::has_model_preferences() const {
  return this != internal_default_instance() && model_preferences_ != NULL;
}
inline const ::mcp::ModelPreferences& Prompt::_internal_model_preferences() const {
  return *model_preferences_;
}
inline const ::mcp::ModelPreferences& Prompt::model_preferences() const {
  const ::mcp::ModelPreferences* p = model_preferences_;
  // @@protoc_insertion_point(field_get:mcp.Prompt.model_preferences)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::ModelPreferences*>(
      &::mcp::_ModelPreferences_default_instance_);
}
inline ::mcp::ModelPreferences* Prompt::release_model_preferences() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.model_preferences)
  
  ::mcp::ModelPreferences* temp = model_preferences_;
  model_preferences_ = NULL;
  return temp;
}
inline ::mcp::ModelPreferences* Prompt::mutable_model_preferences() {
  
  if (model_preferences_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::ModelPreferences>(GetArenaNoVirtual());
    model_preferences_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.model_preferences)
  return model_preferences_;
}
inline void Prompt::set_allocated_model_preferences(::mcp::ModelPreferences* model_preferences) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(model_preferences_);
  }
  if (model_preferences) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model_preferences = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model_preferences, submessage_arena);
    }
    
  } else {
    
  }
  model_preferences_ = model_preferences;
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.model_preferences)
}

// .mcp.Annotations annotations = 5;
inline bool Prompt::has_annotations() const {
  return this != internal_default_instance() && annotations_ != NULL;
}
inline const ::mcp::Annotations& Prompt::_internal_annotations() const {
  return *annotations_;
}
inline const ::mcp::Annotations& Prompt::annotations() const {
  const ::mcp::Annotations* p = annotations_;
  // @@protoc_insertion_point(field_get:mcp.Prompt.annotations)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Annotations*>(
      &::mcp::_Annotations_default_instance_);
}
inline ::mcp::Annotations* Prompt::release_annotations() {
  // @@protoc_insertion_point(field_release:mcp.Prompt.annotations)
  
  ::mcp::Annotations* temp = annotations_;
  annotations_ = NULL;
  return temp;
}
inline ::mcp::Annotations* Prompt::mutable_annotations() {
  
  if (annotations_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Annotations>(GetArenaNoVirtual());
    annotations_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.Prompt.annotations)
  return annotations_;
}
inline void Prompt::set_allocated_annotations(::mcp::Annotations* annotations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(annotations_);
  }
  if (annotations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      annotations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    
  } else {
    
  }
  annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:mcp.Prompt.annotations)
}

// map<string, bytes> metadata = 6;
inline int Prompt::metadata_size() const {
  return metadata_.size();
}
inline void Prompt::clear_metadata() {
  metadata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Prompt::metadata() const {
  // @@protoc_insertion_point(field_map:mcp.Prompt.metadata)
  return metadata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Prompt::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:mcp.Prompt.metadata)
  return metadata_.MutableMap();
}

// -------------------------------------------------------------------

// RegisterPromptRequest

// .mcp.Prompt prompt = 1;
inline bool RegisterPromptRequest::has_prompt() const {
  return this != internal_default_instance() && prompt_ != NULL;
}
inline void RegisterPromptRequest::clear_prompt() {
  if (GetArenaNoVirtual() == NULL && prompt_ != NULL) {
    delete prompt_;
  }
  prompt_ = NULL;
}
inline const ::mcp::Prompt& RegisterPromptRequest::_internal_prompt() const {
  return *prompt_;
}
inline const ::mcp::Prompt& RegisterPromptRequest::prompt() const {
  const ::mcp::Prompt* p = prompt_;
  // @@protoc_insertion_point(field_get:mcp.RegisterPromptRequest.prompt)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Prompt*>(
      &::mcp::_Prompt_default_instance_);
}
inline ::mcp::Prompt* RegisterPromptRequest::release_prompt() {
  // @@protoc_insertion_point(field_release:mcp.RegisterPromptRequest.prompt)
  
  ::mcp::Prompt* temp = prompt_;
  prompt_ = NULL;
  return temp;
}
inline ::mcp::Prompt* RegisterPromptRequest::mutable_prompt() {
  
  if (prompt_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Prompt>(GetArenaNoVirtual());
    prompt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.RegisterPromptRequest.prompt)
  return prompt_;
}
inline void RegisterPromptRequest::set_allocated_prompt(::mcp::Prompt* prompt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prompt_;
  }
  if (prompt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prompt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prompt, submessage_arena);
    }
    
  } else {
    
  }
  prompt_ = prompt;
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterPromptRequest.prompt)
}

// -------------------------------------------------------------------

// RegisterPromptResponse

// bool success = 1;
inline void RegisterPromptResponse::clear_success() {
  success_ = false;
}
inline bool RegisterPromptResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterPromptResponse.success)
  return success_;
}
inline void RegisterPromptResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:mcp.RegisterPromptResponse.success)
}

// string prompt_id = 2;
inline void RegisterPromptResponse::clear_prompt_id() {
  prompt_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterPromptResponse::prompt_id() const {
  // @@protoc_insertion_point(field_get:mcp.RegisterPromptResponse.prompt_id)
  return prompt_id_.GetNoArena();
}
inline void RegisterPromptResponse::set_prompt_id(const ::std::string& value) {
  
  prompt_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.RegisterPromptResponse.prompt_id)
}
#if LANG_CXX11
inline void RegisterPromptResponse::set_prompt_id(::std::string&& value) {
  
  prompt_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.RegisterPromptResponse.prompt_id)
}
#endif
inline void RegisterPromptResponse::set_prompt_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prompt_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.RegisterPromptResponse.prompt_id)
}
inline void RegisterPromptResponse::set_prompt_id(const char* value, size_t size) {
  
  prompt_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.RegisterPromptResponse.prompt_id)
}
inline ::std::string* RegisterPromptResponse::mutable_prompt_id() {
  
  // @@protoc_insertion_point(field_mutable:mcp.RegisterPromptResponse.prompt_id)
  return prompt_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterPromptResponse::release_prompt_id() {
  // @@protoc_insertion_point(field_release:mcp.RegisterPromptResponse.prompt_id)
  
  return prompt_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterPromptResponse::set_allocated_prompt_id(::std::string* prompt_id) {
  if (prompt_id != NULL) {
    
  } else {
    
  }
  prompt_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prompt_id);
  // @@protoc_insertion_point(field_set_allocated:mcp.RegisterPromptResponse.prompt_id)
}

// -------------------------------------------------------------------

// GetPromptRequest

// string name = 1;
inline void GetPromptRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetPromptRequest::name() const {
  // @@protoc_insertion_point(field_get:mcp.GetPromptRequest.name)
  return name_.GetNoArena();
}
inline void GetPromptRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.GetPromptRequest.name)
}
#if LANG_CXX11
inline void GetPromptRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.GetPromptRequest.name)
}
#endif
inline void GetPromptRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.GetPromptRequest.name)
}
inline void GetPromptRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.GetPromptRequest.name)
}
inline ::std::string* GetPromptRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.GetPromptRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPromptRequest::release_name() {
  // @@protoc_insertion_point(field_release:mcp.GetPromptRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPromptRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.GetPromptRequest.name)
}

// -------------------------------------------------------------------

// ListPromptsRequest

// .mcp.PaginatedParams params = 1;
inline bool ListPromptsRequest::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::mcp::PaginatedParams& ListPromptsRequest::_internal_params() const {
  return *params_;
}
inline const ::mcp::PaginatedParams& ListPromptsRequest::params() const {
  const ::mcp::PaginatedParams* p = params_;
  // @@protoc_insertion_point(field_get:mcp.ListPromptsRequest.params)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::PaginatedParams*>(
      &::mcp::_PaginatedParams_default_instance_);
}
inline ::mcp::PaginatedParams* ListPromptsRequest::release_params() {
  // @@protoc_insertion_point(field_release:mcp.ListPromptsRequest.params)
  
  ::mcp::PaginatedParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::mcp::PaginatedParams* ListPromptsRequest::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::PaginatedParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsRequest.params)
  return params_;
}
inline void ListPromptsRequest::set_allocated_params(::mcp::PaginatedParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:mcp.ListPromptsRequest.params)
}

// string filter = 2;
inline void ListPromptsRequest::clear_filter() {
  filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListPromptsRequest::filter() const {
  // @@protoc_insertion_point(field_get:mcp.ListPromptsRequest.filter)
  return filter_.GetNoArena();
}
inline void ListPromptsRequest::set_filter(const ::std::string& value) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ListPromptsRequest.filter)
}
#if LANG_CXX11
inline void ListPromptsRequest::set_filter(::std::string&& value) {
  
  filter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ListPromptsRequest.filter)
}
#endif
inline void ListPromptsRequest::set_filter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ListPromptsRequest.filter)
}
inline void ListPromptsRequest::set_filter(const char* value, size_t size) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ListPromptsRequest.filter)
}
inline ::std::string* ListPromptsRequest::mutable_filter() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsRequest.filter)
  return filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListPromptsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:mcp.ListPromptsRequest.filter)
  
  return filter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListPromptsRequest::set_allocated_filter(::std::string* filter) {
  if (filter != NULL) {
    
  } else {
    
  }
  filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter);
  // @@protoc_insertion_point(field_set_allocated:mcp.ListPromptsRequest.filter)
}

// -------------------------------------------------------------------

// ListPromptsResponse

// repeated .mcp.Prompt prompts = 1;
inline int ListPromptsResponse::prompts_size() const {
  return prompts_.size();
}
inline void ListPromptsResponse::clear_prompts() {
  prompts_.Clear();
}
inline ::mcp::Prompt* ListPromptsResponse::mutable_prompts(int index) {
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsResponse.prompts)
  return prompts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mcp::Prompt >*
ListPromptsResponse::mutable_prompts() {
  // @@protoc_insertion_point(field_mutable_list:mcp.ListPromptsResponse.prompts)
  return &prompts_;
}
inline const ::mcp::Prompt& ListPromptsResponse::prompts(int index) const {
  // @@protoc_insertion_point(field_get:mcp.ListPromptsResponse.prompts)
  return prompts_.Get(index);
}
inline ::mcp::Prompt* ListPromptsResponse::add_prompts() {
  // @@protoc_insertion_point(field_add:mcp.ListPromptsResponse.prompts)
  return prompts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcp::Prompt >&
ListPromptsResponse::prompts() const {
  // @@protoc_insertion_point(field_list:mcp.ListPromptsResponse.prompts)
  return prompts_;
}

// string next_cursor = 2;
inline void ListPromptsResponse::clear_next_cursor() {
  next_cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListPromptsResponse::next_cursor() const {
  // @@protoc_insertion_point(field_get:mcp.ListPromptsResponse.next_cursor)
  return next_cursor_.GetNoArena();
}
inline void ListPromptsResponse::set_next_cursor(const ::std::string& value) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.ListPromptsResponse.next_cursor)
}
#if LANG_CXX11
inline void ListPromptsResponse::set_next_cursor(::std::string&& value) {
  
  next_cursor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.ListPromptsResponse.next_cursor)
}
#endif
inline void ListPromptsResponse::set_next_cursor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.ListPromptsResponse.next_cursor)
}
inline void ListPromptsResponse::set_next_cursor(const char* value, size_t size) {
  
  next_cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.ListPromptsResponse.next_cursor)
}
inline ::std::string* ListPromptsResponse::mutable_next_cursor() {
  
  // @@protoc_insertion_point(field_mutable:mcp.ListPromptsResponse.next_cursor)
  return next_cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListPromptsResponse::release_next_cursor() {
  // @@protoc_insertion_point(field_release:mcp.ListPromptsResponse.next_cursor)
  
  return next_cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListPromptsResponse::set_allocated_next_cursor(::std::string* next_cursor) {
  if (next_cursor != NULL) {
    
  } else {
    
  }
  next_cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_cursor);
  // @@protoc_insertion_point(field_set_allocated:mcp.ListPromptsResponse.next_cursor)
}

// -------------------------------------------------------------------

// UpdatePromptRequest

// string name = 1;
inline void UpdatePromptRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdatePromptRequest::name() const {
  // @@protoc_insertion_point(field_get:mcp.UpdatePromptRequest.name)
  return name_.GetNoArena();
}
inline void UpdatePromptRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.UpdatePromptRequest.name)
}
#if LANG_CXX11
inline void UpdatePromptRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.UpdatePromptRequest.name)
}
#endif
inline void UpdatePromptRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.UpdatePromptRequest.name)
}
inline void UpdatePromptRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.UpdatePromptRequest.name)
}
inline ::std::string* UpdatePromptRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.UpdatePromptRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdatePromptRequest::release_name() {
  // @@protoc_insertion_point(field_release:mcp.UpdatePromptRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdatePromptRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.UpdatePromptRequest.name)
}

// .mcp.Prompt prompt = 2;
inline bool UpdatePromptRequest::has_prompt() const {
  return this != internal_default_instance() && prompt_ != NULL;
}
inline void UpdatePromptRequest::clear_prompt() {
  if (GetArenaNoVirtual() == NULL && prompt_ != NULL) {
    delete prompt_;
  }
  prompt_ = NULL;
}
inline const ::mcp::Prompt& UpdatePromptRequest::_internal_prompt() const {
  return *prompt_;
}
inline const ::mcp::Prompt& UpdatePromptRequest::prompt() const {
  const ::mcp::Prompt* p = prompt_;
  // @@protoc_insertion_point(field_get:mcp.UpdatePromptRequest.prompt)
  return p != NULL ? *p : *reinterpret_cast<const ::mcp::Prompt*>(
      &::mcp::_Prompt_default_instance_);
}
inline ::mcp::Prompt* UpdatePromptRequest::release_prompt() {
  // @@protoc_insertion_point(field_release:mcp.UpdatePromptRequest.prompt)
  
  ::mcp::Prompt* temp = prompt_;
  prompt_ = NULL;
  return temp;
}
inline ::mcp::Prompt* UpdatePromptRequest::mutable_prompt() {
  
  if (prompt_ == NULL) {
    auto* p = CreateMaybeMessage<::mcp::Prompt>(GetArenaNoVirtual());
    prompt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mcp.UpdatePromptRequest.prompt)
  return prompt_;
}
inline void UpdatePromptRequest::set_allocated_prompt(::mcp::Prompt* prompt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prompt_;
  }
  if (prompt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prompt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prompt, submessage_arena);
    }
    
  } else {
    
  }
  prompt_ = prompt;
  // @@protoc_insertion_point(field_set_allocated:mcp.UpdatePromptRequest.prompt)
}

// -------------------------------------------------------------------

// UpdatePromptResponse

// bool success = 1;
inline void UpdatePromptResponse::clear_success() {
  success_ = false;
}
inline bool UpdatePromptResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.UpdatePromptResponse.success)
  return success_;
}
inline void UpdatePromptResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:mcp.UpdatePromptResponse.success)
}

// -------------------------------------------------------------------

// DeletePromptRequest

// string name = 1;
inline void DeletePromptRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeletePromptRequest::name() const {
  // @@protoc_insertion_point(field_get:mcp.DeletePromptRequest.name)
  return name_.GetNoArena();
}
inline void DeletePromptRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcp.DeletePromptRequest.name)
}
#if LANG_CXX11
inline void DeletePromptRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcp.DeletePromptRequest.name)
}
#endif
inline void DeletePromptRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcp.DeletePromptRequest.name)
}
inline void DeletePromptRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcp.DeletePromptRequest.name)
}
inline ::std::string* DeletePromptRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mcp.DeletePromptRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeletePromptRequest::release_name() {
  // @@protoc_insertion_point(field_release:mcp.DeletePromptRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeletePromptRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcp.DeletePromptRequest.name)
}

// -------------------------------------------------------------------

// DeletePromptResponse

// bool success = 1;
inline void DeletePromptResponse::clear_success() {
  success_ = false;
}
inline bool DeletePromptResponse::success() const {
  // @@protoc_insertion_point(field_get:mcp.DeletePromptResponse.success)
  return success_;
}
inline void DeletePromptResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:mcp.DeletePromptResponse.success)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcp

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mcp_5fservice_2eproto
